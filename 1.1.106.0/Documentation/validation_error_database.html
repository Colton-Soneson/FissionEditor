<!DOCTYPE html>
<html>
<head>
<style>
table, th, td {
 border: 1px solid black;
 border-collapse: collapse; 
}
</style>
<body>
<h2>Valid Usage Database</h2>
<font size="2" face="Arial">
<table style="width:100%">
<tr><th>VUID NAME</th><th>CHECKED</th><th>TEST</th><th>TYPE</th><th>API/STRUCT</th><th>EXTENSION</th><th>VUID TEXT</th></tr>
<tr><th>VUID-VkAccelerationStructureCreateInfoNV-compactedSize-02421</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkAccelerationStructureCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If compactedSize is not 0 then both info.geometryCount and info.instanceCount must be 0</th></tr>
<tr><th>VUID-VkAccelerationStructureCreateInfoNV-info-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> info must be a valid VkAccelerationStructureInfoNV structure</th></tr>
<tr><th>VUID-VkAccelerationStructureCreateInfoNV-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkAccelerationStructureCreateInfoNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-flags-02592</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If flags has the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV bit set, then it must not have the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV bit set</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> flags must be a valid combination of VkBuildAccelerationStructureFlagBitsNV values</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-geometryCount-02422</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> geometryCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-instanceCount-02423</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> instanceCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxInstanceCount</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-maxTriangleCount-02424</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> The total number of triangles in all geometries must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxTriangleCount</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-pGeometries-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If geometryCount is not 0, pGeometries must be a valid pointer to an array of geometryCount valid VkGeometryNV structures</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-type-02425</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If type is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV then geometryCount must be 0</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-type-02426</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV then instanceCount must be 0</th></tr>
<tr><th>VUID-VkAccelerationStructureInfoNV-type-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureInfoNV</th><th>(VK_NV_ray_tracing)</th><th> type must be a valid VkAccelerationStructureTypeNV value</th></tr>
<tr><th>VUID-VkAccelerationStructureMemoryRequirementsInfoNV-accelerationStructure-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureMemoryRequirementsInfoNV</th><th>(VK_NV_ray_tracing)</th><th> accelerationStructure must be a valid VkAccelerationStructureNV handle</th></tr>
<tr><th>VUID-VkAccelerationStructureMemoryRequirementsInfoNV-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureMemoryRequirementsInfoNV</th><th>(VK_NV_ray_tracing)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkAccelerationStructureMemoryRequirementsInfoNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureMemoryRequirementsInfoNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV</th></tr>
<tr><th>VUID-VkAccelerationStructureMemoryRequirementsInfoNV-type-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAccelerationStructureMemoryRequirementsInfoNV</th><th>(VK_NV_ray_tracing)</th><th> type must be a valid VkAccelerationStructureMemoryRequirementsTypeNV value</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> Each of fence, semaphore, and swapchain that are valid handles must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-deviceMask-01290</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceMask must be a valid device mask</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-deviceMask-01291</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceMask must not be zero</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-fence-01289</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If fence is not VK_NULL_HANDLE it must be unsignaled and must not be associated with any other queue command that has not yet completed execution on that queue</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-fence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-semaphore-01288</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If semaphore is not VK_NULL_HANDLE it must be unsignaled</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-semaphore-01781</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If semaphore is not VK_NULL_HANDLE it must not have any uncompleted signal or wait operations pending</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-semaphore-01782</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> semaphore and fence must not both be equal to VK_NULL_HANDLE</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-semaphore-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-swapchain-01675</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> swapchain must not be in the retired state</th></tr>
<tr><th>VUID-VkAcquireNextImageInfoKHR-swapchain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAcquireNextImageInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-VkAllocationCallbacks-pfnAllocation-00632</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkAllocationCallbacks</th><th>core</th><th> pfnAllocation must be a valid pointer to a valid user-defined PFN_vkAllocationFunction</th></tr>
<tr><th>VUID-VkAllocationCallbacks-pfnFree-00634</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkAllocationCallbacks</th><th>core</th><th> pfnFree must be a valid pointer to a valid user-defined PFN_vkFreeFunction</th></tr>
<tr><th>VUID-VkAllocationCallbacks-pfnInternalAllocation-00635</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAllocationCallbacks</th><th>core</th><th> If either of pfnInternalAllocation or pfnInternalFree is not NULL, both must be valid callbacks</th></tr>
<tr><th>VUID-VkAllocationCallbacks-pfnReallocation-00633</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkAllocationCallbacks</th><th>core</th><th> pfnReallocation must be a valid pointer to a valid user-defined PFN_vkReallocationFunction</th></tr>
<tr><th>VUID-VkAndroidHardwareBufferFormatPropertiesANDROID-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkAndroidHardwareBufferFormatPropertiesANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID</th></tr>
<tr><th>VUID-VkAndroidHardwareBufferPropertiesANDROID-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkAndroidHardwareBufferPropertiesANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> pNext must be NULL or a pointer to a valid instance of VkAndroidHardwareBufferFormatPropertiesANDROID</th></tr>
<tr><th>VUID-VkAndroidHardwareBufferPropertiesANDROID-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAndroidHardwareBufferPropertiesANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID</th></tr>
<tr><th>VUID-VkAndroidHardwareBufferUsageANDROID-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkAndroidHardwareBufferUsageANDROID</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID</th></tr>
<tr><th>VUID-VkAndroidSurfaceCreateInfoKHR-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAndroidSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_android_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkAndroidSurfaceCreateInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAndroidSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_android_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkAndroidSurfaceCreateInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAndroidSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_android_surface)</th><th> sType must be VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkAndroidSurfaceCreateInfoKHR-window-01248</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkAndroidSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_android_surface)</th><th> window must point to a valid Android ANativeWindow.</th></tr>
<tr><th>VUID-VkApplicationInfo-pApplicationName-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkApplicationInfo</th><th>core</th><th> If pApplicationName is not NULL, pApplicationName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-VkApplicationInfo-pEngineName-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkApplicationInfo</th><th>core</th><th> If pEngineName is not NULL, pEngineName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-VkApplicationInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkApplicationInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkApplicationInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkApplicationInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_APPLICATION_INFO</th></tr>
<tr><th>VUID-VkAttachmentDescription-finalLayout-00843</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentDescriptionInvalidFinalLayout</th><th>explicit</th><th>VkAttachmentDescription</th><th>core</th><th> finalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED</th></tr>
<tr><th>VUID-VkAttachmentDescription-finalLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription</th><th>core</th><th> finalLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-VkAttachmentDescription-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription</th><th>core</th><th> flags must be a valid combination of VkAttachmentDescriptionFlagBits values</th></tr>
<tr><th>VUID-VkAttachmentDescription-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription</th><th>core</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkAttachmentDescription-initialLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription</th><th>core</th><th> initialLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-VkAttachmentDescription-loadOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription</th><th>core</th><th> loadOp must be a valid VkAttachmentLoadOp value</th></tr>
<tr><th>VUID-VkAttachmentDescription-samples-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription</th><th>core</th><th> samples must be a valid VkSampleCountFlagBits value</th></tr>
<tr><th>VUID-VkAttachmentDescription-stencilLoadOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription</th><th>core</th><th> stencilLoadOp must be a valid VkAttachmentLoadOp value</th></tr>
<tr><th>VUID-VkAttachmentDescription-stencilStoreOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription</th><th>core</th><th> stencilStoreOp must be a valid VkAttachmentStoreOp value</th></tr>
<tr><th>VUID-VkAttachmentDescription-storeOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription</th><th>core</th><th> storeOp must be a valid VkAttachmentStoreOp value</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-finalLayout-03061</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentDescriptionInvalidFinalLayout</th><th>explicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> finalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-finalLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> finalLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> flags must be a valid combination of VkAttachmentDescriptionFlagBits values</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-initialLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> initialLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-loadOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> loadOp must be a valid VkAttachmentLoadOp value</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> sType must be VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-samples-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> samples must be a valid VkSampleCountFlagBits value</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-stencilLoadOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> stencilLoadOp must be a valid VkAttachmentLoadOp value</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-stencilStoreOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> stencilStoreOp must be a valid VkAttachmentStoreOp value</th></tr>
<tr><th>VUID-VkAttachmentDescription2KHR-storeOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> storeOp must be a valid VkAttachmentStoreOp value</th></tr>
<tr><th>VUID-VkAttachmentReference-layout-00857</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentReferenceInvalidLayout</th><th>explicit</th><th>VkAttachmentReference</th><th>core</th><th> If attachment is not VK_ATTACHMENT_UNUSED, layout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED</th></tr>
<tr><th>VUID-VkAttachmentReference-layout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentReference</th><th>core</th><th> layout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-VkAttachmentReference2KHR-layout-03077</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentReferenceInvalidLayout</th><th>explicit</th><th>VkAttachmentReference2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If attachment is not VK_ATTACHMENT_UNUSED, layout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED</th></tr>
<tr><th>VUID-VkAttachmentReference2KHR-layout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentReference2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> layout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-VkAttachmentReference2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkAttachmentReference2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> sType must be VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR</th></tr>
<tr><th>VUID-VkAttachmentSampleLocationsEXT-attachmentIndex-01531</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginSampleLocationsInvalidIndicesEXT</th><th>explicit</th><th>VkAttachmentSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> attachmentIndex must be less than the attachmentCount specified in VkRenderPassCreateInfo the render pass specified by VkRenderPassBeginInfo::renderPass was created with</th></tr>
<tr><th>VUID-VkAttachmentSampleLocationsEXT-sampleLocationsInfo-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkAttachmentSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-accelerationStructure-02450</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> accelerationStructure must not already be backed by a memory object</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-accelerationStructure-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> accelerationStructure must be a valid VkAccelerationStructureNV handle</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> Both of accelerationStructure, and memory must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-memory-02593</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-memoryOffset-02451</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> memoryOffset must be less than the size of memory</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-memoryOffset-02594</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-pDeviceIndices-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV</th></tr>
<tr><th>VUID-VkBindAccelerationStructureMemoryInfoNV-size-02595</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindAccelerationStructureMemoryInfoNV</th><th>(VK_NV_ray_tracing)</th><th> The size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV must be less than or equal to the size of memory minus memoryOffset</th></tr>
<tr><th>VUID-VkBindBufferMemoryDeviceGroupInfo-deviceIndexCount-01606</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceIndexCount must either be zero or equal to the number of physical devices in the logical device</th></tr>
<tr><th>VUID-VkBindBufferMemoryDeviceGroupInfo-pDeviceIndices-01607</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> All elements of pDeviceIndices must be valid device indices</th></tr>
<tr><th>VUID-VkBindBufferMemoryDeviceGroupInfo-pDeviceIndices-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindBufferMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values</th></tr>
<tr><th>VUID-VkBindBufferMemoryDeviceGroupInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBindBufferMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-buffer-01593</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> buffer must not already be backed by a memory object</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-buffer-01594</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> buffer must not have been created with any sparse memory binding flags</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-buffer-01602</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If buffer requires a dedicated allocation(as reported by vkGetBufferMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for buffer), memory must have been created with VkMemoryDedicatedAllocateInfo::buffer equal to buffer and memoryOffset must be zero</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-buffer-01603</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_NV_dedicated_allocation)</th><th> If buffer was created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::buffer equal to buffer and memoryOffset must be zero</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-buffer-01604</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_NV_dedicated_allocation)+!(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If buffer was not created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> Both of buffer, and memory must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-memory-01599</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-memory-01900</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::buffer was not VK_NULL_HANDLE, then buffer must equal VkMemoryDedicatedAllocateInfo::buffer and memoryOffset must be zero.</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-memoryOffset-01595</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> memoryOffset must be less than the size of memory</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-memoryOffset-01600</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-pNext-01605</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If the pNext chain includes VkBindBufferMemoryDeviceGroupInfo, all instances of memory specified by VkBindBufferMemoryDeviceGroupInfo::pDeviceIndices must have been allocated</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> pNext must be NULL or a pointer to a valid instance of VkBindBufferMemoryDeviceGroupInfo</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> sType must be VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO</th></tr>
<tr><th>VUID-VkBindBufferMemoryInfo-size-01601</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindBufferMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> The size member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer must be less than or equal to the size of memory minus memoryOffset</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01633</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> At least one of deviceIndexCount and splitInstanceBindRegionCount must be zero.</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01634</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceIndexCount must either be zero or equal to the number of physical devices in the logical device</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-extent-01640</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> The extent.width member of any element of pSplitInstanceBindRegions must either be a multiple of the sparse image block width of all non-metadata aspects of the image, or else extent.width + offset.x must equal the width of the image subresource</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-extent-01641</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> The extent.height member of any element of pSplitInstanceBindRegions must either be a multiple of the sparse image block height of all non-metadata aspects of the image, or else extent.height offset.y must equal the width of the image subresource</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-offset-01638</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> The offset.x member of any element of pSplitInstanceBindRegions must be a multiple of the sparse image block width (VkSparseImageFormatProperties::imageGranularity.width) of all non-metadata aspects of the image</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-offset-01639</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> The offset.y member of any element of pSplitInstanceBindRegions must be a multiple of the sparse image block height (VkSparseImageFormatProperties::imageGranularity.height) of all non-metadata aspects of the image</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-pDeviceIndices-01635</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> All elements of pDeviceIndices must be valid device indices.</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-pDeviceIndices-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-pSplitInstanceBindRegions-01637</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> Elements of pSplitInstanceBindRegions that correspond to the same instance of an image must not overlap.</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-pSplitInstanceBindRegions-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If splitInstanceBindRegionCount is not 0, pSplitInstanceBindRegions must be a valid pointer to an array of splitInstanceBindRegionCount VkRect2D structures</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO</th></tr>
<tr><th>VUID-VkBindImageMemoryDeviceGroupInfo-splitInstanceBindRegionCount-01636</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryDeviceGroupInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> splitInstanceBindRegionCount must either be zero or equal to the number of physical devices in the logical device squared</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> Both of image, and memory that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-image-01609</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> image must not already be backed by a memory object</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-image-01610</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> image must not have been created with any sparse memory binding flags</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-image-01622</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If image requires a dedicated allocation (as reported by vkGetImageMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for image), memory must have been created with VkMemoryDedicatedAllocateInfo::image equal to image and memoryOffset must be zero</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-image-01623</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_NV_dedicated_allocation)</th><th> If image was created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::image equal to image and memoryOffset must be zero</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-image-01624</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_NV_dedicated_allocation)+!(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If image was not created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-image-01630</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)</th><th> If image was created with a valid swapchain handle in VkImageSwapchainCreateInfoKHR::swapchain, then the pNext chain must include a valid instance of VkBindImageMemorySwapchainInfoKHR</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-memory-01612</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-memory-01614</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> The difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with the same image</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-memory-01625</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+!(VK_VERSION_1_1+VK_KHR_swapchain)+!(VK_KHR_device_group+VK_KHR_swapchain)</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-memory-01903</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+!(VK_NV_dedicated_allocation_image_aliasing)</th><th> If the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero.</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-memory-02630</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_NV_dedicated_allocation_image_aliasing)</th><th> If the dedicated allocation image aliasing feature is not enabled, and the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero.</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-memory-02631</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_NV_dedicated_allocation_image_aliasing)</th><th> If the dedicated allocation image aliasing feature is enabled, and the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then memoryOffset must be zero, and image must be either equal to VkMemoryDedicatedAllocateInfo::image or an image that was created using the same parameters in VkImageCreateInfo, with the exception that extent and arrayLayers may differ subject to the following restrictions: every dimension in the extent parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created; and the arrayLayers parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created.</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-memoryOffset-01611</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> memoryOffset must be less than the size of memory</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-memoryOffset-01613</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01615</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the pNext chain does not include an instance of the VkBindImagePlaneMemoryInfo structure, memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01616</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the pNext chain does not include an instance of the VkBindImagePlaneMemoryInfo structure, memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01617</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the pNext chain does not include an instance of the VkBindImagePlaneMemoryInfo structure, the difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with the same image</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01618</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, image must have been created with the VK_IMAGE_CREATE_DISJOINT_BIT bit set.</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01619</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image and the correct planeAspect for this plane in the VkImagePlaneMemoryRequirementsInfo structure attached to the VkImageMemoryRequirementsInfo2's pNext chain</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01620</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image and the correct planeAspect for this plane in the VkImagePlaneMemoryRequirementsInfo structure attached to the VkImageMemoryRequirementsInfo2's pNext chain</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01621</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, the difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with the same image and the correct planeAspect for this plane in the VkImagePlaneMemoryRequirementsInfo structure attached to the VkImageMemoryRequirementsInfo2's pNext chain</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01626</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, all instances of memory specified by VkBindImageMemoryDeviceGroupInfo::pDeviceIndices must have been allocated</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01627</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, and VkBindImageMemoryDeviceGroupInfo::splitInstanceBindRegionCount is not zero, then image must have been created with the VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT bit set</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01628</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, all elements of VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions must be valid rectangles contained within the dimensions of image</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01629</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, the union of the areas of all elements of VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions that correspond to the same instance of image must cover the entire image.</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01631</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)</th><th> If the pNext chain includes an instance of VkBindImageMemorySwapchainInfoKHR, memory must be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-01632</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)</th><th> If the pNext chain does not include an instance of VkBindImageMemorySwapchainInfoKHR, memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkBindImageMemoryDeviceGroupInfo, VkBindImageMemorySwapchainInfoKHR, or VkBindImagePlaneMemoryInfo</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO</th></tr>
<tr><th>VUID-VkBindImageMemoryInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBindImageMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkBindImageMemorySwapchainInfoKHR-imageIndex-01644</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImageMemorySwapchainInfoKHR</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)</th><th> imageIndex must be less than the number of images in swapchain</th></tr>
<tr><th>VUID-VkBindImageMemorySwapchainInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBindImageMemorySwapchainInfoKHR</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)</th><th> sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR</th></tr>
<tr><th>VUID-VkBindImageMemorySwapchainInfoKHR-swapchain-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBindImageMemorySwapchainInfoKHR</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)</th><th> swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-VkBindImagePlaneMemoryInfo-None-01643</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImagePlaneMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> A single call to vkBindImageMemory2 must bind all or none of the planes of an image (i.e. bindings to all planes of an image must be made in a single vkBindImageMemory2 call), as separate bindings</th></tr>
<tr><th>VUID-VkBindImagePlaneMemoryInfo-planeAspect-02283</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImagePlaneMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the image's tiling is VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, then planeAspect must be a single valid format plane for the image. (That is, planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT for '_2PLANE' formats and planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT for '_3PLANE' formats.)</th></tr>
<tr><th>VUID-VkBindImagePlaneMemoryInfo-planeAspect-02284</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBindImagePlaneMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_EXT_image_drm_format_modifier)</th><th>  If the image's tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,  then planeAspect must be a single valid memory plane for the  image.  (That is, aspectMask must specify a plane index that is less than  the  drmFormatModifierPlaneCount  associated with the image's format and drmFormatModifier.)</th></tr>
<tr><th>VUID-VkBindImagePlaneMemoryInfo-planeAspect-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindImagePlaneMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> planeAspect must be a valid VkImageAspectFlagBits value</th></tr>
<tr><th>VUID-VkBindImagePlaneMemoryInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBindImagePlaneMemoryInfo</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO</th></tr>
<tr><th>VUID-VkBindSparseInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindSparseInfo</th><th>core</th><th> Both of the elements of pSignalSemaphores, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkBindSparseInfo-pBufferBinds-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindSparseInfo</th><th>core</th><th> If bufferBindCount is not 0, pBufferBinds must be a valid pointer to an array of bufferBindCount valid VkSparseBufferMemoryBindInfo structures</th></tr>
<tr><th>VUID-VkBindSparseInfo-pImageBinds-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindSparseInfo</th><th>core</th><th> If imageBindCount is not 0, pImageBinds must be a valid pointer to an array of imageBindCount valid VkSparseImageMemoryBindInfo structures</th></tr>
<tr><th>VUID-VkBindSparseInfo-pImageOpaqueBinds-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindSparseInfo</th><th>core</th><th> If imageOpaqueBindCount is not 0, pImageOpaqueBinds must be a valid pointer to an array of imageOpaqueBindCount valid VkSparseImageOpaqueMemoryBindInfo structures</th></tr>
<tr><th>VUID-VkBindSparseInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindSparseInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkDeviceGroupBindSparseInfo</th></tr>
<tr><th>VUID-VkBindSparseInfo-pSignalSemaphores-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindSparseInfo</th><th>core</th><th> If signalSemaphoreCount is not 0, pSignalSemaphores must be a valid pointer to an array of signalSemaphoreCount valid VkSemaphore handles</th></tr>
<tr><th>VUID-VkBindSparseInfo-pWaitSemaphores-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindSparseInfo</th><th>core</th><th> If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles</th></tr>
<tr><th>VUID-VkBindSparseInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBindSparseInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_BIND_SPARSE_INFO</th></tr>
<tr><th>VUID-VkBufferCopy-size-01988</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferCopy</th><th>core</th><th> The size must be greater than 0</th></tr>
<tr><th>VUID-VkBufferCreateInfo-None-01888</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferCreateInfo</th><th>(VK_VERSION_1_1)</th><th> If any of the bits VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT are set, VK_BUFFER_CREATE_PROTECTED_BIT must not also be set</th></tr>
<tr><th>VUID-VkBufferCreateInfo-deviceAddress-02604</th><th><span style="color:limegreen;">Y</span></th><th>BufferDeviceAddressEXT</th><th>explicit</th><th>VkBufferCreateInfo</th><th>(VK_EXT_buffer_device_address)</th><th> If VkBufferDeviceAddressCreateInfoEXT::deviceAddress is not zero, flags must include VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT</th></tr>
<tr><th>VUID-VkBufferCreateInfo-flags-00915</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkBufferCreateInfo</th><th>core</th><th> If the sparse bindings feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_BINDING_BIT</th></tr>
<tr><th>VUID-VkBufferCreateInfo-flags-00916</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkBufferCreateInfo</th><th>core</th><th> If the sparse buffer residency feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</th></tr>
<tr><th>VUID-VkBufferCreateInfo-flags-00917</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkBufferCreateInfo</th><th>core</th><th> If the sparse aliased residency feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</th></tr>
<tr><th>VUID-VkBufferCreateInfo-flags-00918</th><th><span style="color:limegreen;">Y</span></th><th>SparseBindingImageBufferCreate</th><th>explicit</th><th>VkBufferCreateInfo</th><th>core</th><th> If flags contains VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT, it must also contain VK_BUFFER_CREATE_SPARSE_BINDING_BIT</th></tr>
<tr><th>VUID-VkBufferCreateInfo-flags-01887</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferCreateInfo</th><th>(VK_VERSION_1_1)</th><th> If the protected memory feature is not enabled, flags must not contain VK_BUFFER_CREATE_PROTECTED_BIT</th></tr>
<tr><th>VUID-VkBufferCreateInfo-flags-02605</th><th><span style="color:limegreen;">Y</span></th><th>BufferDeviceAddressEXT</th><th>explicit</th><th>VkBufferCreateInfo</th><th>(VK_EXT_buffer_device_address)</th><th> If flags includes VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT, the bufferDeviceAddressCaptureReplay feature must be enabled</th></tr>
<tr><th>VUID-VkBufferCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferCreateInfo</th><th>core</th><th> flags must be a valid combination of VkBufferCreateFlagBits values</th></tr>
<tr><th>VUID-VkBufferCreateInfo-pNext-00920</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If the pNext chain contains an instance of VkExternalMemoryBufferCreateInfo, its handleTypes member must only contain bits that are also in VkExternalBufferProperties::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalBufferProperties with pExternalBufferInfo->handleType equal to any one of the handle types specified in VkExternalMemoryBufferCreateInfo::handleTypes</th></tr>
<tr><th>VUID-VkBufferCreateInfo-pNext-01571</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferCreateInfo</th><th>(VK_NV_dedicated_allocation)</th><th> If the pNext chain contains an instance of VkDedicatedAllocationBufferCreateInfoNV, and the dedicatedAllocation member of the chained structure is VK_TRUE, then flags must not include VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</th></tr>
<tr><th>VUID-VkBufferCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkBufferDeviceAddressCreateInfoEXT, VkDedicatedAllocationBufferCreateInfoNV, or VkExternalMemoryBufferCreateInfo</th></tr>
<tr><th>VUID-VkBufferCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</th></tr>
<tr><th>VUID-VkBufferCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBufferCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkBufferCreateInfo-sharingMode-00913</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkBufferCreateInfo</th><th>core</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values</th></tr>
<tr><th>VUID-VkBufferCreateInfo-sharingMode-00914</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkBufferCreateInfo</th><th>core</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1</th></tr>
<tr><th>VUID-VkBufferCreateInfo-sharingMode-01391</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferCreateInfo</th><th>!(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the physicalDevice that was used to create device</th></tr>
<tr><th>VUID-VkBufferCreateInfo-sharingMode-01419</th><th><span style="color:limegreen;">Y</span></th><th>InvalidQueueFamilyIndex</th><th>explicit</th><th>VkBufferCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device</th></tr>
<tr><th>VUID-VkBufferCreateInfo-sharingMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferCreateInfo</th><th>core</th><th> sharingMode must be a valid VkSharingMode value</th></tr>
<tr><th>VUID-VkBufferCreateInfo-size-00912</th><th><span style="color:limegreen;">Y</span></th><th>InvalidCreateBufferSize</th><th>explicit</th><th>VkBufferCreateInfo</th><th>core</th><th> size must be greater than 0</th></tr>
<tr><th>VUID-VkBufferCreateInfo-usage-02606</th><th><span style="color:limegreen;">Y</span></th><th>BufferDeviceAddressEXTDisabled</th><th>explicit</th><th>VkBufferCreateInfo</th><th>(VK_EXT_buffer_device_address)</th><th> If usage includes VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT, the bufferDeviceAddress feature must be enabled</th></tr>
<tr><th>VUID-VkBufferCreateInfo-usage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBufferCreateInfo</th><th>core</th><th> usage must be a valid combination of VkBufferUsageFlagBits values</th></tr>
<tr><th>VUID-VkBufferCreateInfo-usage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferCreateInfo</th><th>core</th><th> usage must not be 0</th></tr>
<tr><th>VUID-VkBufferDeviceAddressCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBufferDeviceAddressCreateInfoEXT</th><th>(VK_EXT_buffer_device_address)</th><th> sType must be VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkBufferDeviceAddressInfoEXT-buffer-02600</th><th><span style="color:limegreen;">Y</span></th><th>BufferDeviceAddressEXTDisabled, BufferDeviceAddressEXT</th><th>explicit</th><th>VkBufferDeviceAddressInfoEXT</th><th>(VK_EXT_buffer_device_address)</th><th> If buffer is non-sparse and was not created with the VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT flag, then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-VkBufferDeviceAddressInfoEXT-buffer-02601</th><th><span style="color:limegreen;">Y</span></th><th>BufferDeviceAddressEXTDisabled</th><th>explicit</th><th>VkBufferDeviceAddressInfoEXT</th><th>(VK_EXT_buffer_device_address)</th><th> buffer must have been created with VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT</th></tr>
<tr><th>VUID-VkBufferDeviceAddressInfoEXT-buffer-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBufferDeviceAddressInfoEXT</th><th>(VK_EXT_buffer_device_address)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkBufferDeviceAddressInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferDeviceAddressInfoEXT</th><th>(VK_EXT_buffer_device_address)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkBufferDeviceAddressInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferDeviceAddressInfoEXT</th><th>(VK_EXT_buffer_device_address)</th><th> sType must be VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT</th></tr>
<tr><th>VUID-VkBufferImageCopy-None-00214</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>!(VK_EXT_depth_range_unrestricted)</th><th> When copying to the depth aspect of an image subresource, the data in the source buffer must be in the range [0,1]</th></tr>
<tr><th>VUID-VkBufferImageCopy-None-01735</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, bufferRowLength must be a multiple of the compressed texel block width</th></tr>
<tr><th>VUID-VkBufferImageCopy-None-01736</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, bufferImageHeight must be a multiple of the compressed texel block height</th></tr>
<tr><th>VUID-VkBufferImageCopy-None-01737</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, all members of imageOffset must be a multiple of the corresponding dimensions of the compressed texel block</th></tr>
<tr><th>VUID-VkBufferImageCopy-None-01738</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, bufferOffset must be a multiple of the compressed texel block size in bytes</th></tr>
<tr><th>VUID-VkBufferImageCopy-None-01739</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, imageExtent.width must be a multiple of the compressed texel block width or (imageExtent.width + imageOffset.x) must equal the image subresource width</th></tr>
<tr><th>VUID-VkBufferImageCopy-None-01740</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, imageExtent.height must be a multiple of the compressed texel block height or (imageExtent.height + imageOffset.y) must equal the image subresource height</th></tr>
<tr><th>VUID-VkBufferImageCopy-None-01741</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, imageExtent.depth must be a multiple of the compressed texel block depth or (imageExtent.depth + imageOffset.z) must equal the image subresource depth</th></tr>
<tr><th>VUID-VkBufferImageCopy-aspectMask-00211</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> The aspectMask member of imageSubresource must specify aspects present in the calling command's VkImage parameter</th></tr>
<tr><th>VUID-VkBufferImageCopy-aspectMask-00212</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> The aspectMask member of imageSubresource must only have a single bit set</th></tr>
<tr><th>VUID-VkBufferImageCopy-aspectMask-01560</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter's format is a multi-planar format, then the aspectMask member of imageSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT (with VK_IMAGE_ASPECT_PLANE_2_BIT valid only for image formats with three planes)</th></tr>
<tr><th>VUID-VkBufferImageCopy-baseArrayLayer-00213</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> If the calling command's VkImage parameter is of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of imageSubresource must be 0 and 1, respectively</th></tr>
<tr><th>VUID-VkBufferImageCopy-bufferImageHeight-00196</th><th><span style="color:limegreen;">Y</span></th><th>MiscImageLayerTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> bufferImageHeight must be 0, or greater than or equal to the height member of imageExtent</th></tr>
<tr><th>VUID-VkBufferImageCopy-bufferImageHeight-00204</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, bufferImageHeight must be a multiple of the compressed texel block height</th></tr>
<tr><th>VUID-VkBufferImageCopy-bufferOffset-00193</th><th><span style="color:limegreen;">Y</span></th><th>MiscImageLayerTests, ImageBufferCopyTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter's format is not a depth/stencil format, then bufferOffset must be a multiple of the format's texel block size.</th></tr>
<tr><th>VUID-VkBufferImageCopy-bufferOffset-00194</th><th><span style="color:limegreen;">Y</span></th><th>MiscImageLayerTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> bufferOffset must be a multiple of 4</th></tr>
<tr><th>VUID-VkBufferImageCopy-bufferOffset-00206</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, bufferOffset must be a multiple of the compressed texel block size in bytes</th></tr>
<tr><th>VUID-VkBufferImageCopy-bufferOffset-01558</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter's format is not a depth/stencil format or a multi-planar format, then bufferOffset must be a multiple of the format's texel block size.</th></tr>
<tr><th>VUID-VkBufferImageCopy-bufferOffset-01559</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter's format is a multi-planar format, then bufferOffset must be a multiple of the element size of the compatible format for the format and the aspectMask of the imageSubresource as defined in Compatible formats of planes of multi-planar formats</th></tr>
<tr><th>VUID-VkBufferImageCopy-bufferRowLength-00195</th><th><span style="color:limegreen;">Y</span></th><th>MiscImageLayerTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> bufferRowLength must be 0, or greater than or equal to the width member of imageExtent</th></tr>
<tr><th>VUID-VkBufferImageCopy-bufferRowLength-00203</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, bufferRowLength must be a multiple of the compressed texel block width</th></tr>
<tr><th>VUID-VkBufferImageCopy-imageExtent-00207</th><th><span style="color:limegreen;">Y</span></th><th>CompressedImageMipCopyTests, ImageBufferCopyTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, imageExtent.width must be a multiple of the compressed texel block width or (imageExtent.width + imageOffset.x) must equal the image subresource width</th></tr>
<tr><th>VUID-VkBufferImageCopy-imageExtent-00208</th><th><span style="color:limegreen;">Y</span></th><th>CompressedImageMipCopyTests, ImageBufferCopyTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, imageExtent.height must be a multiple of the compressed texel block height or (imageExtent.height + imageOffset.y) must equal the image subresource height</th></tr>
<tr><th>VUID-VkBufferImageCopy-imageExtent-00209</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, imageExtent.depth must be a multiple of the compressed texel block depth or (imageExtent.depth + imageOffset.z) must equal the image subresource depth</th></tr>
<tr><th>VUID-VkBufferImageCopy-imageOffset-00197</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> imageOffset.x and (imageExtent.width + imageOffset.x) must both be greater than or equal to 0 and less than or equal to the image subresource width</th></tr>
<tr><th>VUID-VkBufferImageCopy-imageOffset-00198</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> imageOffset.y and (imageExtent.height + imageOffset.y) must both be greater than or equal to 0 and less than or equal to the image subresource height</th></tr>
<tr><th>VUID-VkBufferImageCopy-imageOffset-00200</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> imageOffset.z and (imageExtent.depth + imageOffset.z) must both be greater than or equal to 0 and less than or equal to the image subresource depth</th></tr>
<tr><th>VUID-VkBufferImageCopy-imageOffset-00205</th><th><span style="color:limegreen;">Y</span></th><th>CompressedImageMipCopyTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's VkImage parameter is a compressed image, all members of imageOffset must be a multiple of the corresponding dimensions of the compressed texel block</th></tr>
<tr><th>VUID-VkBufferImageCopy-imageSubresource-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkBufferImageCopy</th><th>core</th><th> imageSubresource must be a valid VkImageSubresourceLayers structure</th></tr>
<tr><th>VUID-VkBufferImageCopy-srcImage-00199</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> If the calling command's srcImage (vkCmdCopyImageToBuffer) or dstImage (vkCmdCopyBufferToImage) is of type VK_IMAGE_TYPE_1D, then imageOffset.y must be 0 and imageExtent.height must be 1.</th></tr>
<tr><th>VUID-VkBufferImageCopy-srcImage-00201</th><th><span style="color:limegreen;">Y</span></th><th>MiscImageLayerTests</th><th>explicit</th><th>VkBufferImageCopy</th><th>core</th><th> If the calling command's srcImage (vkCmdCopyImageToBuffer) or dstImage (vkCmdCopyBufferToImage) is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then imageOffset.z must be 0 and imageExtent.depth must be 1</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-buffer-01190</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamily</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>!(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, srcQueueFamilyIndex and dstQueueFamilyIndex must both be VK_QUEUE_FAMILY_IGNORED</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-buffer-01191</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamilyWithMemExt</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, at least one of srcQueueFamilyIndex and dstQueueFamilyIndex must be VK_QUEUE_FAMILY_IGNORED</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-buffer-01192</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamily</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>!(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, srcQueueFamilyIndex and dstQueueFamilyIndex must either both be VK_QUEUE_FAMILY_IGNORED, or both be a valid queue family (see Queue Family Properties)</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-buffer-01193</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamilyWithMemExt</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, dstQueueFamilyIndex must also be VK_QUEUE_FAMILY_IGNORED</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-buffer-01196</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamily</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>core</th><th> If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not VK_QUEUE_FAMILY_IGNORED, at least one of them must be the same as the family of the queue that will execute this barrier</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-buffer-01763</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamilyWithMemExt</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, and one of srcQueueFamilyIndex and dstQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, the other must be VK_QUEUE_FAMILY_IGNORED or a special queue family reserved for external memory ownership transfers, as described in Queue Family Ownership Transfer.</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-buffer-01764</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamilyWithMemExt</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in Queue Family Ownership Transfer.</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-buffer-01765</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamilyWithMemExt</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and dstQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in Queue Family Ownership Transfer.</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-buffer-01931</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>core</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferMemoryBarrier</th><th>core</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-dstAccessMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferMemoryBarrier</th><th>core</th><th> dstAccessMask must be a valid combination of VkAccessFlagBits values</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-offset-01187</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>core</th><th> offset must be less than the size of buffer</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferMemoryBarrier</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferMemoryBarrier</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-size-01188</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>core</th><th> If size is not equal to VK_WHOLE_SIZE, size must be greater than 0</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-size-01189</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>VkBufferMemoryBarrier</th><th>core</th><th> If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to than the size of buffer minus offset</th></tr>
<tr><th>VUID-VkBufferMemoryBarrier-srcAccessMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferMemoryBarrier</th><th>core</th><th> srcAccessMask must be a valid combination of VkAccessFlagBits values</th></tr>
<tr><th>VUID-VkBufferMemoryRequirementsInfo2-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkBufferMemoryRequirementsInfo2-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkBufferMemoryRequirementsInfo2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-buffer-00932</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBufferViewCreateInfoEntries</th><th>explicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> buffer must have been created with a usage value containing at least one of VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-buffer-00933</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBufferViewCreateInfoEntries</th><th>explicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> If buffer was created with usage containing VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, format must be supported for uniform texel buffers, as specified by the VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-buffer-00934</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBufferViewCreateInfoEntries</th><th>explicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> If buffer was created with usage containing VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, format must be supported for storage texel buffers, as specified by the VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-buffer-00935</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-offset-00925</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBufferViewCreateInfoEntries</th><th>explicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> offset must be less than the size of buffer</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-offset-00926</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBufferViewCreateInfoEntries</th><th>explicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> offset must be a multiple of VkPhysicalDeviceLimits::minTexelBufferOffsetAlignment</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-offset-00931</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBufferViewCreateInfoEntries</th><th>explicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> If range is not equal to VK_WHOLE_SIZE, the sum of offset and range must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-range-00928</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBufferViewCreateInfoEntries</th><th>explicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> If range is not equal to VK_WHOLE_SIZE, range must be greater than 0</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-range-00929</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBufferViewCreateInfoEntries</th><th>explicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> If range is not equal to VK_WHOLE_SIZE, range must be an integer multiple of the texel block size of format</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-range-00930</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBufferViewCreateInfoEntries</th><th>explicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> If range is not equal to VK_WHOLE_SIZE, range divided by the texel block size of format, multiplied by the number of texels per texel block for that format (as defined in the Compatible Formats table), must be less than or equal to VkPhysicalDeviceLimits::maxTexelBufferElements</th></tr>
<tr><th>VUID-VkBufferViewCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkBufferViewCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO</th></tr>
<tr><th>VUID-VkCalibratedTimestampInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCalibratedTimestampInfoEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkCalibratedTimestampInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCalibratedTimestampInfoEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> sType must be VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT</th></tr>
<tr><th>VUID-VkCalibratedTimestampInfoEXT-timeDomain-02354</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCalibratedTimestampInfoEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> timeDomain must be one of the VkTimeDomainEXT values returned by vkGetPhysicalDeviceCalibrateableTimeDomainsEXT</th></tr>
<tr><th>VUID-VkCalibratedTimestampInfoEXT-timeDomain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCalibratedTimestampInfoEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> timeDomain must be a valid VkTimeDomainEXT value</th></tr>
<tr><th>VUID-VkCheckpointDataNV-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkCheckpointDataNV</th><th>(VK_NV_device_diagnostic_checkpoints)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkCheckpointDataNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCheckpointDataNV</th><th>(VK_NV_device_diagnostic_checkpoints)</th><th> sType must be VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV</th></tr>
<tr><th>VUID-VkClearAttachment-aspectMask-00019</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkClearAttachment</th><th>core</th><th> If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, it must not include VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT</th></tr>
<tr><th>VUID-VkClearAttachment-aspectMask-00020</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkClearAttachment</th><th>core</th><th> aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT</th></tr>
<tr><th>VUID-VkClearAttachment-aspectMask-02246</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkClearAttachment</th><th>(VK_EXT_image_drm_format_modifier)</th><th> aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.</th></tr>
<tr><th>VUID-VkClearAttachment-aspectMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkClearAttachment</th><th>core</th><th> aspectMask must be a valid combination of VkImageAspectFlagBits values</th></tr>
<tr><th>VUID-VkClearAttachment-aspectMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkClearAttachment</th><th>core</th><th> aspectMask must not be 0</th></tr>
<tr><th>VUID-VkClearAttachment-clearValue-00021</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkClearAttachment</th><th>core</th><th> clearValue must be a valid VkClearValue union</th></tr>
<tr><th>VUID-VkClearDepthStencilValue-depth-00022</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkClearDepthStencilValue</th><th>(VK_EXT_depth_range_unrestricted)</th><th> Unless the VK_EXT_depth_range_unrestricted extension is enabled depth must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-VkClearDepthStencilValue-depth-02506</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkClearDepthStencilValue</th><th>!(VK_EXT_depth_range_unrestricted)</th><th> depth must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> Each of indirectCommandsLayout, objectTable, sequencesCountBuffer, sequencesIndexBuffer, and targetCommandBuffer that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-indirectCommandsLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-indirectCommandsTokenCount-01332</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> indirectCommandsTokenCount must match the indirectCommandsLayout's tokenCount</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-indirectCommandsTokenCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> indirectCommandsTokenCount must be greater than 0</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-objectTable-01331</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The provided objectTable must include all objects referenced by the generation process</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-objectTable-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectTable must be a valid VkObjectTableNVX handle</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-pIndirectCommandsTokens-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pIndirectCommandsTokens must be a valid pointer to an array of indirectCommandsTokenCount valid VkIndirectCommandsTokenNVX structures</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> sType must be VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-sequencesCountBuffer-01338</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If sequencesCountBuffer is used, its usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-sequencesCountBuffer-01339</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If sequencesCountBuffer is used, sequencesCountOffset must be aligned to VkDeviceGeneratedCommandsLimitsNVX::minSequenceCountBufferOffsetAlignment</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-sequencesCountBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If sequencesCountBuffer is not VK_NULL_HANDLE, sequencesCountBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-sequencesIndexBuffer-01340</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If sequencesIndexBuffer is used, its usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-sequencesIndexBuffer-01341</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If sequencesIndexBuffer is used, sequencesIndexOffset must be aligned to VkDeviceGeneratedCommandsLimitsNVX::minSequenceIndexBufferOffsetAlignment</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-sequencesIndexBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If sequencesIndexBuffer is not VK_NULL_HANDLE, sequencesIndexBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-targetCommandBuffer-01334</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If targetCommandBuffer is provided, it must have reserved command space</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-targetCommandBuffer-01335</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If targetCommandBuffer is provided, the objectTable must match the reservation's objectTable and must have had all referenced objects registered at reservation time</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-targetCommandBuffer-01336</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If targetCommandBuffer is provided, the indirectCommandsLayout must match the reservation's indirectCommandsLayout</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-targetCommandBuffer-01337</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If targetCommandBuffer is provided, the maxSequencesCount must not exceed the reservation's maxSequencesCount</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-targetCommandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If targetCommandBuffer is not NULL, targetCommandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-VkCmdProcessCommandsInfoNVX-tokenType-01333</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCmdProcessCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The tokenType member of each entry in the pIndirectCommandsTokens array must match the values used at creation time of indirectCommandsLayout</th></tr>
<tr><th>VUID-VkCmdReserveSpaceForCommandsInfoNVX-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdReserveSpaceForCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> Both of indirectCommandsLayout, and objectTable must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkCmdReserveSpaceForCommandsInfoNVX-indirectCommandsLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdReserveSpaceForCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle</th></tr>
<tr><th>VUID-VkCmdReserveSpaceForCommandsInfoNVX-objectTable-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdReserveSpaceForCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectTable must be a valid VkObjectTableNVX handle</th></tr>
<tr><th>VUID-VkCmdReserveSpaceForCommandsInfoNVX-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdReserveSpaceForCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkCmdReserveSpaceForCommandsInfoNVX-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCmdReserveSpaceForCommandsInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> sType must be VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX</th></tr>
<tr><th>VUID-VkCoarseSampleLocationNV-pixelX-02078</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkCoarseSampleLocationNV</th><th>(VK_NV_shading_rate_image)</th><th> pixelX must be less than the width (in pixels) of the fragment.</th></tr>
<tr><th>VUID-VkCoarseSampleLocationNV-pixelY-02079</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkCoarseSampleLocationNV</th><th>(VK_NV_shading_rate_image)</th><th> pixelY must be less than the height (in pixels) of the fragment.</th></tr>
<tr><th>VUID-VkCoarseSampleLocationNV-sample-02080</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkCoarseSampleLocationNV</th><th>(VK_NV_shading_rate_image)</th><th> sample must be less than the number of coverage samples in each pixel belonging to the fragment.</th></tr>
<tr><th>VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-02077</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkCoarseSampleOrderCustomNV</th><th>(VK_NV_shading_rate_image)</th><th> The array pSampleLocations must contain exactly one entry for every combination of valid values for pixelX, pixelY, and sample in the structure VkCoarseSampleOrderCustomNV.</th></tr>
<tr><th>VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCoarseSampleOrderCustomNV</th><th>(VK_NV_shading_rate_image)</th><th> pSampleLocations must be a valid pointer to an array of sampleLocationCount VkCoarseSampleLocationNV structures</th></tr>
<tr><th>VUID-VkCoarseSampleOrderCustomNV-sampleCount-02074</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkCoarseSampleOrderCustomNV</th><th>(VK_NV_shading_rate_image)</th><th> sampleCount must correspond to a sample count enumerated in VkSampleCountFlags whose corresponding bit is set in VkPhysicalDeviceLimits::framebufferNoAttachmentsSampleCounts.</th></tr>
<tr><th>VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-02075</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkCoarseSampleOrderCustomNV</th><th>(VK_NV_shading_rate_image)</th><th> sampleLocationCount must be equal to the product of sampleCount, the fragment width for shadingRate, and the fragment height for shadingRate.</th></tr>
<tr><th>VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-02076</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkCoarseSampleOrderCustomNV</th><th>(VK_NV_shading_rate_image)</th><th> sampleLocationCount must be less than or equal to the value of VkPhysicalDeviceShadingRateImagePropertiesNV::shadingRateMaxCoarseSamples.</th></tr>
<tr><th>VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCoarseSampleOrderCustomNV</th><th>(VK_NV_shading_rate_image)</th><th> sampleLocationCount must be greater than 0</th></tr>
<tr><th>VUID-VkCoarseSampleOrderCustomNV-shadingRate-02073</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkCoarseSampleOrderCustomNV</th><th>(VK_NV_shading_rate_image)</th><th> shadingRate must be a shading rate that generates fragments with more than one pixel.</th></tr>
<tr><th>VUID-VkCoarseSampleOrderCustomNV-shadingRate-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCoarseSampleOrderCustomNV</th><th>(VK_NV_shading_rate_image)</th><th> shadingRate must be a valid VkShadingRatePaletteEntryNV value</th></tr>
<tr><th>VUID-VkCommandBufferAllocateInfo-commandBufferCount-00044</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCommandBufferAllocateInfo</th><th>core</th><th> commandBufferCount must be greater than 0</th></tr>
<tr><th>VUID-VkCommandBufferAllocateInfo-commandPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandBufferAllocateInfo</th><th>core</th><th> commandPool must be a valid VkCommandPool handle</th></tr>
<tr><th>VUID-VkCommandBufferAllocateInfo-level-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandBufferAllocateInfo</th><th>core</th><th> level must be a valid VkCommandBufferLevel value</th></tr>
<tr><th>VUID-VkCommandBufferAllocateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandBufferAllocateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkCommandBufferAllocateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandBufferAllocateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</th></tr>
<tr><th>VUID-VkCommandBufferBeginInfo-flags-00053</th><th><span style="color:limegreen;">Y</span></th><th>SecondaryCommandBufferNullRenderpass</th><th>explicit</th><th>VkCommandBufferBeginInfo</th><th>core</th><th> If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the renderPass member of pInheritanceInfo must be a valid VkRenderPass</th></tr>
<tr><th>VUID-VkCommandBufferBeginInfo-flags-00054</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCommandBufferBeginInfo</th><th>core</th><th> If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the subpass member of pInheritanceInfo must be a valid subpass index within the renderPass member of pInheritanceInfo</th></tr>
<tr><th>VUID-VkCommandBufferBeginInfo-flags-00055</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCommandBufferBeginInfo</th><th>core</th><th> If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the framebuffer member of pInheritanceInfo must be either VK_NULL_HANDLE, or a valid VkFramebuffer that is compatible with the renderPass member of pInheritanceInfo</th></tr>
<tr><th>VUID-VkCommandBufferBeginInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandBufferBeginInfo</th><th>core</th><th> flags must be a valid combination of VkCommandBufferUsageFlagBits values</th></tr>
<tr><th>VUID-VkCommandBufferBeginInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandBufferBeginInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkDeviceGroupCommandBufferBeginInfo</th></tr>
<tr><th>VUID-VkCommandBufferBeginInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandBufferBeginInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</th></tr>
<tr><th>VUID-VkCommandBufferInheritanceConditionalRenderingInfoEXT-conditionalRenderingEnable-01977</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCommandBufferInheritanceConditionalRenderingInfoEXT</th><th>(VK_EXT_conditional_rendering)</th><th> If the inherited conditional rendering feature is not enabled, conditionalRenderingEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkCommandBufferInheritanceConditionalRenderingInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkCommandBufferInheritanceConditionalRenderingInfoEXT</th><th>(VK_EXT_conditional_rendering)</th><th> sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT</th></tr>
<tr><th>VUID-VkCommandBufferInheritanceInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandBufferInheritanceInfo</th><th>core</th><th> Both of framebuffer, and renderPass that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkCommandBufferInheritanceInfo-occlusionQueryEnable-00056</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCommandBufferInheritanceInfo</th><th>core</th><th> If the inherited queries feature is not enabled, occlusionQueryEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkCommandBufferInheritanceInfo-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkCommandBufferInheritanceInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkCommandBufferInheritanceConditionalRenderingInfoEXT</th></tr>
<tr><th>VUID-VkCommandBufferInheritanceInfo-pipelineStatistics-00058</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCommandBufferInheritanceInfo</th><th>core</th><th> If the pipeline statistics queries feature is not enabled, pipelineStatistics must be 0</th></tr>
<tr><th>VUID-VkCommandBufferInheritanceInfo-queryFlags-00057</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCommandBufferInheritanceInfo</th><th>core</th><th> If the inherited queries feature is enabled, queryFlags must be a valid combination of VkQueryControlFlagBits values</th></tr>
<tr><th>VUID-VkCommandBufferInheritanceInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkCommandBufferInheritanceInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO</th></tr>
<tr><th>VUID-VkCommandPoolCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandPoolCreateInfo</th><th>core</th><th> flags must be a valid combination of VkCommandPoolCreateFlagBits values</th></tr>
<tr><th>VUID-VkCommandPoolCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandPoolCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkCommandPoolCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCommandPoolCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</th></tr>
<tr><th>VUID-VkComponentMapping-a-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkComponentMapping</th><th>core</th><th> a must be a valid VkComponentSwizzle value</th></tr>
<tr><th>VUID-VkComponentMapping-b-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkComponentMapping</th><th>core</th><th> b must be a valid VkComponentSwizzle value</th></tr>
<tr><th>VUID-VkComponentMapping-g-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkComponentMapping</th><th>core</th><th> g must be a valid VkComponentSwizzle value</th></tr>
<tr><th>VUID-VkComponentMapping-r-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkComponentMapping</th><th>core</th><th> r must be a valid VkComponentSwizzle value</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> Both of basePipelineHandle, and layout that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-flags-00697</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a compute VkPipeline</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-flags-00698</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-flags-00699</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-flags-00700</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> flags must be a valid combination of VkPipelineCreateFlagBits values</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-layout-00703</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> layout must be consistent with the layout of the compute shader specified in stage</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-layout-01687</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> The number of resources in layout accessible to the compute shader stage must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-layout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> layout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfoEXT</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-stage-00701</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> The stage member of stage must be VK_SHADER_STAGE_COMPUTE_BIT</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-stage-00702</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> The shader code for the entry point identified by stage and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter</th></tr>
<tr><th>VUID-VkComputePipelineCreateInfo-stage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkComputePipelineCreateInfo</th><th>core</th><th> stage must be a valid VkPipelineShaderStageCreateInfo structure</th></tr>
<tr><th>VUID-VkConditionalRenderingBeginInfoEXT-buffer-01981</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkConditionalRenderingBeginInfoEXT</th><th>(VK_EXT_conditional_rendering)</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-VkConditionalRenderingBeginInfoEXT-buffer-01982</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkConditionalRenderingBeginInfoEXT</th><th>(VK_EXT_conditional_rendering)</th><th> buffer must have been created with the VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT bit set</th></tr>
<tr><th>VUID-VkConditionalRenderingBeginInfoEXT-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkConditionalRenderingBeginInfoEXT</th><th>(VK_EXT_conditional_rendering)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkConditionalRenderingBeginInfoEXT-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkConditionalRenderingBeginInfoEXT</th><th>(VK_EXT_conditional_rendering)</th><th> flags must be a valid combination of VkConditionalRenderingFlagBitsEXT values</th></tr>
<tr><th>VUID-VkConditionalRenderingBeginInfoEXT-offset-01983</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkConditionalRenderingBeginInfoEXT</th><th>(VK_EXT_conditional_rendering)</th><th> offset must be less than the size of buffer by at least 32 bits.</th></tr>
<tr><th>VUID-VkConditionalRenderingBeginInfoEXT-offset-01984</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkConditionalRenderingBeginInfoEXT</th><th>(VK_EXT_conditional_rendering)</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-VkConditionalRenderingBeginInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkConditionalRenderingBeginInfoEXT</th><th>(VK_EXT_conditional_rendering)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkConditionalRenderingBeginInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkConditionalRenderingBeginInfoEXT</th><th>(VK_EXT_conditional_rendering)</th><th> sType must be VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT</th></tr>
<tr><th>VUID-VkCooperativeMatrixPropertiesNV-AType-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> AType must be a valid VkComponentTypeNV value</th></tr>
<tr><th>VUID-VkCooperativeMatrixPropertiesNV-BType-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> BType must be a valid VkComponentTypeNV value</th></tr>
<tr><th>VUID-VkCooperativeMatrixPropertiesNV-CType-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> CType must be a valid VkComponentTypeNV value</th></tr>
<tr><th>VUID-VkCooperativeMatrixPropertiesNV-DType-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> DType must be a valid VkComponentTypeNV value</th></tr>
<tr><th>VUID-VkCooperativeMatrixPropertiesNV-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkCooperativeMatrixPropertiesNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> sType must be VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV</th></tr>
<tr><th>VUID-VkCooperativeMatrixPropertiesNV-scope-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> scope must be a valid VkScopeNV value</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> Both of dstSet, and srcSet must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-dstArrayElement-00348</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> The sum of dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by dstBinding, and all applicable consecutive bindings, as described by consecutive binding updates</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-dstBinding-00347</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> dstBinding must be a valid binding within dstSet</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-dstBinding-02224</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>(VK_EXT_inline_uniform_block)</th><th> If the descriptor type of the descriptor set binding specified by dstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-dstBinding-02632</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> The type of dstBinding within dstSet must be equal to the type of srcBinding within srcSet</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-dstSet-parameter</th><th><span style="color:limegreen;">Y</span></th><th>UpdateDestroyDescriptorSetLayout</th><th>implicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> dstSet must be a valid VkDescriptorSet handle</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-srcArrayElement-00346</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> The sum of srcArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by srcBinding, and all applicable consecutive bindings, as described by consecutive binding updates</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-srcBinding-00345</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> srcBinding must be a valid binding within srcSet</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-srcBinding-02223</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>(VK_EXT_inline_uniform_block)</th><th> If the descriptor type of the descriptor set binding specified by srcBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, srcArrayElement must be an integer multiple of 4</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-srcBinding-02225</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>(VK_EXT_inline_uniform_block)</th><th> If the descriptor type of the descriptor set binding specified by either srcBinding or dstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-srcSet-00349</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> If srcSet is equal to dstSet, then the source and destination ranges of descriptors must not overlap, where the ranges may include array elements from consecutive bindings as described by consecutive binding updates</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-srcSet-01918</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>(VK_EXT_descriptor_indexing)</th><th> If srcSet's layout was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set, then dstSet's layout must also have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-srcSet-01919</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>(VK_EXT_descriptor_indexing)</th><th> If srcSet's layout was created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set, then dstSet's layout must also have been created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-srcSet-01920</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>(VK_EXT_descriptor_indexing)</th><th> If the descriptor pool from which srcSet was allocated was created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set, then the descriptor pool from which dstSet was allocated must also have been created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-srcSet-01921</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkCopyDescriptorSet</th><th>(VK_EXT_descriptor_indexing)</th><th> If the descriptor pool from which srcSet was allocated was created without the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set, then the descriptor pool from which dstSet was allocated must also have been created without the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set</th></tr>
<tr><th>VUID-VkCopyDescriptorSet-srcSet-parameter</th><th><span style="color:limegreen;">Y</span></th><th>UpdateDestroyDescriptorSetLayout</th><th>implicit</th><th>VkCopyDescriptorSet</th><th>core</th><th> srcSet must be a valid VkDescriptorSet handle</th></tr>
<tr><th>VUID-VkD3D12FenceSubmitInfoKHR-pSignalSemaphoreValues-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkD3D12FenceSubmitInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If signalSemaphoreValuesCount is not 0, and pSignalSemaphoreValues is not NULL, pSignalSemaphoreValues must be a valid pointer to an array of signalSemaphoreValuesCount uint64_t values</th></tr>
<tr><th>VUID-VkD3D12FenceSubmitInfoKHR-pWaitSemaphoreValues-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkD3D12FenceSubmitInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If waitSemaphoreValuesCount is not 0, and pWaitSemaphoreValues is not NULL, pWaitSemaphoreValues must be a valid pointer to an array of waitSemaphoreValuesCount uint64_t values</th></tr>
<tr><th>VUID-VkD3D12FenceSubmitInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkD3D12FenceSubmitInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> sType must be VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR</th></tr>
<tr><th>VUID-VkD3D12FenceSubmitInfoKHR-signalSemaphoreValuesCount-00080</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkD3D12FenceSubmitInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> signalSemaphoreValuesCount must be the same value as VkSubmitInfo::signalSemaphoreCount, where VkSubmitInfo is in the pNext chain of this VkD3D12FenceSubmitInfoKHR structure.</th></tr>
<tr><th>VUID-VkD3D12FenceSubmitInfoKHR-waitSemaphoreValuesCount-00079</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkD3D12FenceSubmitInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> waitSemaphoreValuesCount must be the same value as VkSubmitInfo::waitSemaphoreCount, where VkSubmitInfo is in the pNext chain of this VkD3D12FenceSubmitInfoKHR structure.</th></tr>
<tr><th>VUID-VkDebugMarkerMarkerInfoEXT-pMarkerName-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerMarkerInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> pMarkerName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-VkDebugMarkerMarkerInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerMarkerInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDebugMarkerMarkerInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerMarkerInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT</th></tr>
<tr><th>VUID-VkDebugMarkerObjectNameInfoEXT-object-01491</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugMarkerObjectNameInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> object must not be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-VkDebugMarkerObjectNameInfoEXT-object-01492</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugMarkerObjectNameInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> object must be a Vulkan object of the type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship.</th></tr>
<tr><th>VUID-VkDebugMarkerObjectNameInfoEXT-objectType-01490</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugMarkerObjectNameInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> objectType must not be VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT</th></tr>
<tr><th>VUID-VkDebugMarkerObjectNameInfoEXT-objectType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerObjectNameInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> objectType must be a valid VkDebugReportObjectTypeEXT value</th></tr>
<tr><th>VUID-VkDebugMarkerObjectNameInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerObjectNameInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDebugMarkerObjectNameInfoEXT-pObjectName-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerObjectNameInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> pObjectName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-VkDebugMarkerObjectNameInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerObjectNameInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT</th></tr>
<tr><th>VUID-VkDebugMarkerObjectTagInfoEXT-object-01494</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugMarkerObjectTagInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> object must not be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-VkDebugMarkerObjectTagInfoEXT-object-01495</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugMarkerObjectTagInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> object must be a Vulkan object of the type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship.</th></tr>
<tr><th>VUID-VkDebugMarkerObjectTagInfoEXT-objectType-01493</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugMarkerObjectTagInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> objectType must not be VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT</th></tr>
<tr><th>VUID-VkDebugMarkerObjectTagInfoEXT-objectType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerObjectTagInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> objectType must be a valid VkDebugReportObjectTypeEXT value</th></tr>
<tr><th>VUID-VkDebugMarkerObjectTagInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerObjectTagInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDebugMarkerObjectTagInfoEXT-pTag-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerObjectTagInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> pTag must be a valid pointer to an array of tagSize bytes</th></tr>
<tr><th>VUID-VkDebugMarkerObjectTagInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerObjectTagInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT</th></tr>
<tr><th>VUID-VkDebugMarkerObjectTagInfoEXT-tagSize-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugMarkerObjectTagInfoEXT</th><th>(VK_EXT_debug_marker)</th><th> tagSize must be greater than 0</th></tr>
<tr><th>VUID-VkDebugReportCallbackCreateInfoEXT-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugReportCallbackCreateInfoEXT</th><th>(VK_EXT_debug_report)</th><th> flags must be a valid combination of VkDebugReportFlagBitsEXT values</th></tr>
<tr><th>VUID-VkDebugReportCallbackCreateInfoEXT-pfnCallback-01385</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugReportCallbackCreateInfoEXT</th><th>(VK_EXT_debug_report)</th><th> pfnCallback must be a valid PFN_vkDebugReportCallbackEXT</th></tr>
<tr><th>VUID-VkDebugReportCallbackCreateInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugReportCallbackCreateInfoEXT</th><th>(VK_EXT_debug_report)</th><th> sType must be VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkDebugUtilsLabelEXT-pLabelName-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> pLabelName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-VkDebugUtilsLabelEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDebugUtilsLabelEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCallbackDataEXT-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCallbackDataEXT</th><th>(VK_EXT_debug_utils)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCallbackDataEXT-pCmdBufLabels-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCallbackDataEXT</th><th>(VK_EXT_debug_utils)</th><th> If cmdBufLabelCount is not 0, pCmdBufLabels must be a valid pointer to an array of cmdBufLabelCount valid VkDebugUtilsLabelEXT structures</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCallbackDataEXT-pMessage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCallbackDataEXT</th><th>(VK_EXT_debug_utils)</th><th> pMessage must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCallbackDataEXT-pMessageIdName-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCallbackDataEXT</th><th>(VK_EXT_debug_utils)</th><th> If pMessageIdName is not NULL, pMessageIdName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCallbackDataEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCallbackDataEXT</th><th>(VK_EXT_debug_utils)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCallbackDataEXT-pObjects-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCallbackDataEXT</th><th>(VK_EXT_debug_utils)</th><th> If objectCount is not 0, pObjects must be a valid pointer to an array of objectCount valid VkDebugUtilsObjectNameInfoEXT structures</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCallbackDataEXT-pQueueLabels-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCallbackDataEXT</th><th>(VK_EXT_debug_utils)</th><th> If queueLabelCount is not 0, pQueueLabels must be a valid pointer to an array of queueLabelCount valid VkDebugUtilsLabelEXT structures</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCallbackDataEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCallbackDataEXT</th><th>(VK_EXT_debug_utils)</th><th> sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCreateInfoEXT-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCreateInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCreateInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> messageSeverity must be a valid combination of VkDebugUtilsMessageSeverityFlagBitsEXT values</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCreateInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> messageSeverity must not be 0</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCreateInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> messageType must be a valid combination of VkDebugUtilsMessageTypeFlagBitsEXT values</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCreateInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> messageType must not be 0</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCreateInfoEXT-pfnUserCallback-01914</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugUtilsMessengerCreateInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> pfnUserCallback must be a valid PFN_vkDebugUtilsMessengerCallbackEXT</th></tr>
<tr><th>VUID-VkDebugUtilsMessengerCreateInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsMessengerCreateInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkDebugUtilsObjectNameInfoEXT-objectType-02589</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugUtilsObjectNameInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> If objectType is VK_OBJECT_TYPE_UNKNOWN, objectHandle must not be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-VkDebugUtilsObjectNameInfoEXT-objectType-02590</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugUtilsObjectNameInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> If objectType is not VK_OBJECT_TYPE_UNKNOWN, objectHandle must be VK_NULL_HANDLE or a valid Vulkan handle of the type associated with objectType as defined in the VkObjectType and Vulkan Handle Relationship table</th></tr>
<tr><th>VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsObjectNameInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> objectType must be a valid VkObjectType value</th></tr>
<tr><th>VUID-VkDebugUtilsObjectNameInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsObjectNameInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDebugUtilsObjectNameInfoEXT-pObjectName-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsObjectNameInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> If pObjectName is not NULL, pObjectName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsObjectNameInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT</th></tr>
<tr><th>VUID-VkDebugUtilsObjectTagInfoEXT-objectHandle-01910</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugUtilsObjectTagInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> objectHandle must be a valid Vulkan handle of the type associated with objectType as defined in the VkObjectType and Vulkan Handle Relationship table</th></tr>
<tr><th>VUID-VkDebugUtilsObjectTagInfoEXT-objectType-01908</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDebugUtilsObjectTagInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> objectType must not be VK_OBJECT_TYPE_UNKNOWN</th></tr>
<tr><th>VUID-VkDebugUtilsObjectTagInfoEXT-objectType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsObjectTagInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> objectType must be a valid VkObjectType value</th></tr>
<tr><th>VUID-VkDebugUtilsObjectTagInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsObjectTagInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDebugUtilsObjectTagInfoEXT-pTag-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsObjectTagInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> pTag must be a valid pointer to an array of tagSize bytes</th></tr>
<tr><th>VUID-VkDebugUtilsObjectTagInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsObjectTagInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT</th></tr>
<tr><th>VUID-VkDebugUtilsObjectTagInfoEXT-tagSize-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDebugUtilsObjectTagInfoEXT</th><th>(VK_EXT_debug_utils)</th><th> tagSize must be greater than 0</th></tr>
<tr><th>VUID-VkDedicatedAllocationBufferCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDedicatedAllocationBufferCreateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkDedicatedAllocationImageCreateInfoNV-dedicatedAllocation-00994</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDedicatedAllocationImageCreateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> If dedicatedAllocation is VK_TRUE, VkImageCreateInfo::flags must not include VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</th></tr>
<tr><th>VUID-VkDedicatedAllocationImageCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDedicatedAllocationImageCreateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-00651</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> If buffer is not VK_NULL_HANDLE, the buffer must have been created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-00653</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> If buffer is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the buffer</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-00655</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)+(VK_KHR_external_memory_win32,VK_KHR_external_memory_fd)</th><th> If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation, the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory.</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-commonparent</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> Both of buffer, and image that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00649</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> At least one of image and buffer must be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00650</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> If image is not VK_NULL_HANDLE, the image must have been created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00652</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> If image is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the image</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00654</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)+(VK_KHR_external_memory_win32,VK_KHR_external_memory_fd)</th><th> If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory.</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> If image is not VK_NULL_HANDLE, image must be a valid VkImage handle</th></tr>
<tr><th>VUID-VkDedicatedAllocationMemoryAllocateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDedicatedAllocationMemoryAllocateInfoNV</th><th>(VK_NV_dedicated_allocation)</th><th> sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV</th></tr>
<tr><th>VUID-VkDescriptorBufferInfo-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorBufferInfo</th><th>core</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkDescriptorBufferInfo-offset-00340</th><th><span style="color:limegreen;">Y</span></th><th>DSBufferInfoErrors</th><th>explicit</th><th>VkDescriptorBufferInfo</th><th>core</th><th> offset must be less than the size of buffer</th></tr>
<tr><th>VUID-VkDescriptorBufferInfo-range-00341</th><th><span style="color:limegreen;">Y</span></th><th>DSBufferInfoErrors</th><th>explicit</th><th>VkDescriptorBufferInfo</th><th>core</th><th> If range is not equal to VK_WHOLE_SIZE, range must be greater than 0</th></tr>
<tr><th>VUID-VkDescriptorBufferInfo-range-00342</th><th><span style="color:limegreen;">Y</span></th><th>DSBufferInfoErrors</th><th>explicit</th><th>VkDescriptorBufferInfo</th><th>core</th><th> If range is not equal to VK_WHOLE_SIZE, range must be less than or equal to the size of buffer minus offset</th></tr>
<tr><th>VUID-VkDescriptorImageInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorImageInfo</th><th>core</th><th> Both of imageView, and sampler that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkDescriptorImageInfo-imageLayout-00344</th><th><span style="color:limegreen;">Y</span></th><th>ImageDescriptorLayoutMismatchInternal</th><th>explicit</th><th>VkDescriptorImageInfo</th><th>core</th><th> imageLayout must match the actual VkImageLayout of each subresource accessible from imageView at the time this descriptor is accessed as defined by the image layout matching rules</th></tr>
<tr><th>VUID-VkDescriptorImageInfo-imageView-00343</th><th><span style="color:limegreen;">Y</span></th><th>Maint1BindingSliceOf3DImage</th><th>explicit</th><th>VkDescriptorImageInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> imageView must not be 2D or 2D array image view created from a 3D image</th></tr>
<tr><th>VUID-VkDescriptorImageInfo-imageView-01976</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDescriptorImageInfo</th><th>core</th><th> If imageView is created from a depth/stencil image, the aspectMask used to create the imageView must include either VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT but not both.</th></tr>
<tr><th>VUID-VkDescriptorImageInfo-sampler-01564</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDescriptorImageInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If sampler is used and the VkFormat of the image is a multi-planar format, the image must have been created with VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, and the aspectMask of the imageView must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or (for three-plane formats only) VK_IMAGE_ASPECT_PLANE_2_BIT</th></tr>
<tr><th>VUID-VkDescriptorPoolCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorPoolCreateInfo</th><th>core</th><th> flags must be a valid combination of VkDescriptorPoolCreateFlagBits values</th></tr>
<tr><th>VUID-VkDescriptorPoolCreateInfo-maxSets-00301</th><th><span style="color:limegreen;">Y</span></th><th>InvalidCreateDescriptorPool</th><th>explicit</th><th>VkDescriptorPoolCreateInfo</th><th>core</th><th> maxSets must be greater than 0</th></tr>
<tr><th>VUID-VkDescriptorPoolCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorPoolCreateInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkDescriptorPoolInlineUniformBlockCreateInfoEXT</th></tr>
<tr><th>VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorPoolCreateInfo</th><th>core</th><th> pPoolSizes must be a valid pointer to an array of poolSizeCount valid VkDescriptorPoolSize structures</th></tr>
<tr><th>VUID-VkDescriptorPoolCreateInfo-poolSizeCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorPoolCreateInfo</th><th>core</th><th> poolSizeCount must be greater than 0</th></tr>
<tr><th>VUID-VkDescriptorPoolCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorPoolCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO</th></tr>
<tr><th>VUID-VkDescriptorPoolInlineUniformBlockCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDescriptorPoolInlineUniformBlockCreateInfoEXT</th><th>(VK_EXT_inline_uniform_block)</th><th> sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkDescriptorPoolSize-descriptorCount-00302</th><th><span style="color:limegreen;">Y</span></th><th>InvalidCreateDescriptorPool</th><th>explicit</th><th>VkDescriptorPoolSize</th><th>core</th><th> descriptorCount must be greater than 0</th></tr>
<tr><th>VUID-VkDescriptorPoolSize-type-02218</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkDescriptorPoolSize</th><th>(VK_EXT_inline_uniform_block)</th><th> If type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount must be a multiple of 4</th></tr>
<tr><th>VUID-VkDescriptorPoolSize-type-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorPoolSize</th><th>core</th><th> type must be a valid VkDescriptorType value</th></tr>
<tr><th>VUID-VkDescriptorSetAllocateInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetAllocateInfo</th><th>core</th><th> Both of descriptorPool, and the elements of pSetLayouts must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkDescriptorSetAllocateInfo-descriptorPool-00307</th><th><span style="color:limegreen;">Y</span></th><th>AllocDescriptorFromEmptyPool</th><th>explicit</th><th>VkDescriptorSetAllocateInfo</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> descriptorPool must have enough free descriptor capacity remaining to allocate the descriptor sets of the specified layouts</th></tr>
<tr><th>VUID-VkDescriptorSetAllocateInfo-descriptorPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetAllocateInfo</th><th>core</th><th> descriptorPool must be a valid VkDescriptorPool handle</th></tr>
<tr><th>VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-00306</th><th><span style="color:limegreen;">Y</span></th><th>AllocDescriptorFromEmptyPool</th><th>explicit</th><th>VkDescriptorSetAllocateInfo</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> descriptorSetCount must not be greater than the number of sets that are currently available for allocation in descriptorPool</th></tr>
<tr><th>VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetAllocateInfo</th><th>core</th><th> descriptorSetCount must be greater than 0</th></tr>
<tr><th>VUID-VkDescriptorSetAllocateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetAllocateInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkDescriptorSetVariableDescriptorCountAllocateInfoEXT</th></tr>
<tr><th>VUID-VkDescriptorSetAllocateInfo-pSetLayouts-00308</th><th><span style="color:limegreen;">Y</span></th><th>AllocatePushDescriptorSet</th><th>explicit</th><th>VkDescriptorSetAllocateInfo</th><th>(VK_KHR_push_descriptor)</th><th> Each element of pSetLayouts must not have been created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set</th></tr>
<tr><th>VUID-VkDescriptorSetAllocateInfo-pSetLayouts-03044</th><th><span style="color:limegreen;">Y</span></th><th>DescriptorIndexingSetLayout</th><th>explicit</th><th>VkDescriptorSetAllocateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> If any element of pSetLayouts was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set, descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set</th></tr>
<tr><th>VUID-VkDescriptorSetAllocateInfo-pSetLayouts-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetAllocateInfo</th><th>core</th><th> pSetLayouts must be a valid pointer to an array of descriptorSetCount valid VkDescriptorSetLayout handles</th></tr>
<tr><th>VUID-VkDescriptorSetAllocateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetAllocateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBinding-descriptorCount-00283</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBinding</th><th>core</th><th> If descriptorCount is not 0, stageFlags must be a valid combination of VkShaderStageFlagBits values</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBinding-descriptorType-00282</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBinding</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and descriptorCount is not 0 and pImmutableSamplers is not NULL, pImmutableSamplers must be a valid pointer to an array of descriptorCount valid VkSampler handles</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBinding-descriptorType-01510</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBinding</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT and descriptorCount is not 0, then stageFlags must be 0 or VK_SHADER_STAGE_FRAGMENT_BIT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBinding-descriptorType-02209</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkDescriptorSetLayoutBinding</th><th>(VK_EXT_inline_uniform_block)</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount must be a multiple of 4</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBinding-descriptorType-02210</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkDescriptorSetLayoutBinding</th><th>(VK_EXT_inline_uniform_block)</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxInlineUniformBlockSize</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetLayoutBinding</th><th>core</th><th> descriptorType must be a valid VkDescriptorType value</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-None-03011</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> All bindings with descriptor type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-bindingCount-03002</th><th><span style="color:limegreen;">Y</span></th><th>DescriptorIndexingSetLayout</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If bindingCount is not zero, bindingCount must equal VkDescriptorSetLayoutCreateInfo::bindingCount</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingInlineUniformBlockUpdateAfterBind-02211</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block)</th><th> If VkPhysicalDeviceInlineUniformBlockFeaturesEXT::descriptorBindingInlineUniformBlockUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingPartiallyBound-03013</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingPartiallyBound is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingSampledImageUpdateAfterBind-03006</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingSampledImageUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingStorageBufferUpdateAfterBind-03008</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingStorageImageUpdateAfterBind-03007</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageImageUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingStorageTexelBufferUpdateAfterBind-03010</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageTexelBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingUniformBufferUpdateAfterBind-03005</th><th><span style="color:limegreen;">Y</span></th><th>DescriptorIndexingSetLayout</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUniformBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingUniformTexelBufferUpdateAfterBind-03009</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUniformTexelBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingUpdateUnusedWhilePending-03012</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUpdateUnusedWhilePending is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingVariableDescriptorCount-03014</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingVariableDescriptorCount is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-flags-03003</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)+(VK_KHR_push_descriptor)</th><th> If VkDescriptorSetLayoutCreateInfo::flags includes VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT, VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT, or VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-pBindingFlags-03004</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If an element of pBindingFlags includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT, then all other elements of VkDescriptorSetLayoutCreateInfo::pBindings must have a smaller value of binding</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-pBindingFlags-03015</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If an element of pBindingFlags includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT, that element's descriptorType must not be VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-pBindingFlags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If bindingCount is not 0, and pBindingFlags is not NULL, pBindingFlags must be a valid pointer to an array of bindingCount valid combinations of VkDescriptorBindingFlagBitsEXT values</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutCreateInfo-binding-00279</th><th><span style="color:limegreen;">Y</span></th><th>DuplicateDescriptorBinding</th><th>explicit</th><th>VkDescriptorSetLayoutCreateInfo</th><th>core</th><th> The VkDescriptorSetLayoutBinding::binding members of the elements of the pBindings array must each have different values.</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-03001</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit set, then all bindings must not have descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutCreateInfo-flags-00280</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPushDescriptorSetLayout</th><th>explicit</th><th>VkDescriptorSetLayoutCreateInfo</th><th>(VK_KHR_push_descriptor)</th><th> If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutCreateInfo-flags-00281</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPushDescriptorSetLayout, PushDescriptorSetLayoutWithoutExtension</th><th>explicit</th><th>VkDescriptorSetLayoutCreateInfo</th><th>(VK_KHR_push_descriptor)</th><th> If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then the total number of elements of all bindings must be less than or equal to VkPhysicalDevicePushDescriptorPropertiesKHR::maxPushDescriptors</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutCreateInfo-flags-02208</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetLayoutCreateInfo</th><th>(VK_KHR_push_descriptor)+(VK_EXT_inline_uniform_block)</th><th> If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutCreateInfo-flags-03000</th><th><span style="color:limegreen;">Y</span></th><th>DescriptorIndexingSetLayout</th><th>explicit</th><th>VkDescriptorSetLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit set, flags must include VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetLayoutCreateInfo</th><th>core</th><th> flags must be a valid combination of VkDescriptorSetLayoutCreateFlagBits values</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetLayoutCreateInfo</th><th>core</th><th> If bindingCount is not 0, pBindings must be a valid pointer to an array of bindingCount valid VkDescriptorSetLayoutBinding structures</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetLayoutCreateInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkDescriptorSetLayoutBindingFlagsCreateInfoEXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetLayoutCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutSupport-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetLayoutSupport</th><th>(VK_VERSION_1_1,VK_KHR_maintenance3)</th><th> pNext must be NULL or a pointer to a valid instance of VkDescriptorSetVariableDescriptorCountLayoutSupportEXT</th></tr>
<tr><th>VUID-VkDescriptorSetLayoutSupport-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetLayoutSupport</th><th>(VK_VERSION_1_1,VK_KHR_maintenance3)</th><th> sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT</th></tr>
<tr><th>VUID-VkDescriptorSetVariableDescriptorCountAllocateInfoEXT-descriptorSetCount-03045</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDescriptorSetVariableDescriptorCountAllocateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If descriptorSetCount is not zero, descriptorSetCount must equal VkDescriptorSetAllocateInfo::descriptorSetCount</th></tr>
<tr><th>VUID-VkDescriptorSetVariableDescriptorCountAllocateInfoEXT-pDescriptorCounts-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetVariableDescriptorCountAllocateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If descriptorSetCount is not 0, pDescriptorCounts must be a valid pointer to an array of descriptorSetCount uint32_t values</th></tr>
<tr><th>VUID-VkDescriptorSetVariableDescriptorCountAllocateInfoEXT-pSetLayouts-03046</th><th><span style="color:limegreen;">Y</span></th><th>DescriptorIndexingSetLayout</th><th>explicit</th><th>VkDescriptorSetVariableDescriptorCountAllocateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> If VkDescriptorSetAllocateInfo::pSetLayouts[i] has a variable descriptor count binding, then pDescriptorCounts[i] must be less than or equal to the descriptor count specified for that binding when the descriptor set layout was created.</th></tr>
<tr><th>VUID-VkDescriptorSetVariableDescriptorCountAllocateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetVariableDescriptorCountAllocateInfoEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT</th></tr>
<tr><th>VUID-VkDescriptorSetVariableDescriptorCountLayoutSupportEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDescriptorSetVariableDescriptorCountLayoutSupportEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> Both of descriptorSetLayout, and pipelineLayout that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorSetLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> If descriptorSetLayout is not VK_NULL_HANDLE, descriptorSetLayout must be a valid VkDescriptorSetLayout handle</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> descriptorUpdateEntryCount must be greater than 0</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> pDescriptorUpdateEntries must be a valid pointer to an array of descriptorUpdateEntryCount valid VkDescriptorUpdateTemplateEntry structures</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00350</th><th><span style="color:limegreen;">Y</span></th><th>CreateDescriptorUpdateTemplate</th><th>explicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET, descriptorSetLayout must be a valid VkDescriptorSetLayout handle</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00351</th><th><span style="color:limegreen;">Y</span></th><th>CreateDescriptorUpdateTemplate</th><th>explicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)+(VK_KHR_push_descriptor)</th><th> If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, pipelineBindPoint must be a valid VkPipelineBindPoint value</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00352</th><th><span style="color:limegreen;">Y</span></th><th>CreateDescriptorUpdateTemplate</th><th>explicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)+(VK_KHR_push_descriptor)</th><th> If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, pipelineLayout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00353</th><th><span style="color:limegreen;">Y</span></th><th>CreateDescriptorUpdateTemplate</th><th>explicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)+(VK_KHR_push_descriptor)</th><th> If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, set must be the unique set number in the pipeline layout that uses a descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorUpdateTemplateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> templateType must be a valid VkDescriptorUpdateTemplateType value</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateEntry-descriptor-02226</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDescriptorUpdateTemplateEntry</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)+(VK_EXT_inline_uniform_block)</th><th> If descriptor type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateEntry-descriptor-02227</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDescriptorUpdateTemplateEntry</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)+(VK_EXT_inline_uniform_block)</th><th> If descriptor type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDescriptorUpdateTemplateEntry</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> descriptorType must be a valid VkDescriptorType value</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateEntry-dstArrayElement-00355</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDescriptorUpdateTemplateEntry</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding implicitly specified when using a descriptor update template to update descriptors, and all applicable consecutive bindings, as described by consecutive binding updates</th></tr>
<tr><th>VUID-VkDescriptorUpdateTemplateEntry-dstBinding-00354</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDescriptorUpdateTemplateEntry</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> dstBinding must be a valid binding in the descriptor set layout implicitly specified when using a descriptor update template to update descriptors.</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-pEnabledFeatures-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceCreateInfo</th><th>core</th><th> If pEnabledFeatures is not NULL, pEnabledFeatures must be a valid pointer to a valid VkPhysicalDeviceFeatures structure</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-pNext-00373</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> If the pNext chain includes a VkPhysicalDeviceFeatures2 structure, then pEnabledFeatures must be NULL</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupDeviceCreateInfo, VkDeviceMemoryOverallocationCreateInfoAMD, VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice8BitStorageFeaturesKHR, VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDescriptorIndexingFeaturesEXT, VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceFeatures2, VkPhysicalDeviceFloat16Int8FeaturesKHR, VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, VkPhysicalDeviceHostQueryResetFeaturesEXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceScalarBlockLayoutFeaturesEXT, VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, or VkPhysicalDeviceYcbcrImageArraysFeaturesEXT</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-pQueueCreateInfos-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceCreateInfo</th><th>core</th><th> pQueueCreateInfos must be a valid pointer to an array of queueCreateInfoCount valid VkDeviceQueueCreateInfo structures</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-00374</th><th><span style="color:limegreen;">Y</span></th><th>Maintenance1AndNegativeViewport</th><th>explicit</th><th>VkDeviceCreateInfo</th><th>(VK_AMD_negative_viewport_height)+!(VK_VERSION_1_1)+(VK_KHR_maintenance1)</th><th> ppEnabledExtensionNames must not contain both VK_KHR_maintenance1 and VK_AMD_negative_viewport_height</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-01840</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceCreateInfo</th><th>(VK_AMD_negative_viewport_height)+(VK_VERSION_1_1)</th><th> ppEnabledExtensionNames must not contain VK_AMD_negative_viewport_height</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceCreateInfo</th><th>core</th><th> If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-ppEnabledLayerNames-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceCreateInfo</th><th>core</th><th> If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-queueCreateInfoCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceCreateInfo</th><th>core</th><th> queueCreateInfoCount must be greater than 0</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-queueFamilyIndex-00372</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDeviceCreateInfo</th><th>core</th><th></th></tr>
<tr><th>VUID-VkDeviceCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</th></tr>
<tr><th>VUID-VkDeviceCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkDeviceEventInfoEXT-deviceEvent-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceEventInfoEXT</th><th>(VK_EXT_display_control)</th><th> deviceEvent must be a valid VkDeviceEventTypeEXT value</th></tr>
<tr><th>VUID-VkDeviceEventInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceEventInfoEXT</th><th>(VK_EXT_display_control)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDeviceEventInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceEventInfoEXT</th><th>(VK_EXT_display_control)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT</th></tr>
<tr><th>VUID-VkDeviceGeneratedCommandsFeaturesNVX-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceGeneratedCommandsFeaturesNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDeviceGeneratedCommandsFeaturesNVX-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGeneratedCommandsFeaturesNVX</th><th>(VK_NVX_device_generated_commands)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX</th></tr>
<tr><th>VUID-VkDeviceGeneratedCommandsLimitsNVX-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceGeneratedCommandsLimitsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDeviceGeneratedCommandsLimitsNVX-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGeneratedCommandsLimitsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX</th></tr>
<tr><th>VUID-VkDeviceGroupBindSparseInfo-memoryDeviceIndex-01119</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupBindSparseInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> Each memory allocation bound in this batch must have allocated an instance for memoryDeviceIndex.</th></tr>
<tr><th>VUID-VkDeviceGroupBindSparseInfo-resourceDeviceIndex-01118</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupBindSparseInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> resourceDeviceIndex and memoryDeviceIndex must both be valid device indices.</th></tr>
<tr><th>VUID-VkDeviceGroupBindSparseInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupBindSparseInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO</th></tr>
<tr><th>VUID-VkDeviceGroupCommandBufferBeginInfo-deviceMask-00106</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkDeviceGroupCommandBufferBeginInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceMask must be a valid device mask value</th></tr>
<tr><th>VUID-VkDeviceGroupCommandBufferBeginInfo-deviceMask-00107</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkDeviceGroupCommandBufferBeginInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceMask must not be zero</th></tr>
<tr><th>VUID-VkDeviceGroupCommandBufferBeginInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupCommandBufferBeginInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO</th></tr>
<tr><th>VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-00375</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupDeviceCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group_creation)</th><th> Each element of pPhysicalDevices must be unique</th></tr>
<tr><th>VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-00376</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupDeviceCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group_creation)</th><th> All elements of pPhysicalDevices must be in the same device group as enumerated by vkEnumeratePhysicalDeviceGroups</th></tr>
<tr><th>VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupDeviceCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group_creation)</th><th> If physicalDeviceCount is not 0, pPhysicalDevices must be a valid pointer to an array of physicalDeviceCount valid VkPhysicalDevice handles</th></tr>
<tr><th>VUID-VkDeviceGroupDeviceCreateInfo-physicalDeviceCount-00377</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupDeviceCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group_creation)</th><th> If physicalDeviceCount is not 0, the physicalDevice parameter of vkCreateDevice must be an element of pPhysicalDevices.</th></tr>
<tr><th>VUID-VkDeviceGroupDeviceCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupDeviceCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group_creation)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO</th></tr>
<tr><th>VUID-VkDeviceGroupPresentCapabilitiesKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupPresentCapabilitiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDeviceGroupPresentCapabilitiesKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupPresentCapabilitiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR</th></tr>
<tr><th>VUID-VkDeviceGroupPresentInfoKHR-mode-01298</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, then each element of pDeviceMasks must have exactly one bit set, and the corresponding element of VkDeviceGroupPresentCapabilitiesKHR::presentMask must be non-zero</th></tr>
<tr><th>VUID-VkDeviceGroupPresentInfoKHR-mode-01299</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If mode is VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, then each element of pDeviceMasks must have exactly one bit set, and some physical device in the logical device must include that bit in its VkDeviceGroupPresentCapabilitiesKHR::presentMask.</th></tr>
<tr><th>VUID-VkDeviceGroupPresentInfoKHR-mode-01300</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If mode is VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, then each element of pDeviceMasks must have a value for which all set bits are set in one of the elements of VkDeviceGroupPresentCapabilitiesKHR::presentMask</th></tr>
<tr><th>VUID-VkDeviceGroupPresentInfoKHR-mode-01301</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then for each bit set in each element of pDeviceMasks, the corresponding element of VkDeviceGroupPresentCapabilitiesKHR::presentMask must be non-zero</th></tr>
<tr><th>VUID-VkDeviceGroupPresentInfoKHR-mode-01303</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> mode must have exactly one bit set, and that bit must have been included in VkDeviceGroupSwapchainCreateInfoKHR::modes</th></tr>
<tr><th>VUID-VkDeviceGroupPresentInfoKHR-mode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> mode must be a valid VkDeviceGroupPresentModeFlagBitsKHR value</th></tr>
<tr><th>VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-01302</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> The value of each element of pDeviceMasks must be equal to the device mask passed in VkAcquireNextImageInfoKHR::deviceMask when the image index was last acquired</th></tr>
<tr><th>VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If swapchainCount is not 0, pDeviceMasks must be a valid pointer to an array of swapchainCount uint32_t values</th></tr>
<tr><th>VUID-VkDeviceGroupPresentInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR</th></tr>
<tr><th>VUID-VkDeviceGroupPresentInfoKHR-swapchainCount-01297</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> swapchainCount must equal 0 or VkPresentInfoKHR::swapchainCount</th></tr>
<tr><th>VUID-VkDeviceGroupRenderPassBeginInfo-deviceMask-00905</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkDeviceGroupRenderPassBeginInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceMask must be a valid device mask value</th></tr>
<tr><th>VUID-VkDeviceGroupRenderPassBeginInfo-deviceMask-00906</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkDeviceGroupRenderPassBeginInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceMask must not be zero</th></tr>
<tr><th>VUID-VkDeviceGroupRenderPassBeginInfo-deviceMask-00907</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkDeviceGroupRenderPassBeginInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceMask must be a subset of the command buffer's initial device mask</th></tr>
<tr><th>VUID-VkDeviceGroupRenderPassBeginInfo-deviceRenderAreaCount-00908</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkDeviceGroupRenderPassBeginInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceRenderAreaCount must either be zero or equal to the number of physical devices in the logical device.</th></tr>
<tr><th>VUID-VkDeviceGroupRenderPassBeginInfo-pDeviceRenderAreas-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupRenderPassBeginInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If deviceRenderAreaCount is not 0, pDeviceRenderAreas must be a valid pointer to an array of deviceRenderAreaCount VkRect2D structures</th></tr>
<tr><th>VUID-VkDeviceGroupRenderPassBeginInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupRenderPassBeginInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO</th></tr>
<tr><th>VUID-VkDeviceGroupSubmitInfo-commandBufferCount-00083</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupSubmitInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> commandBufferCount must equal VkSubmitInfo::commandBufferCount</th></tr>
<tr><th>VUID-VkDeviceGroupSubmitInfo-pCommandBufferDeviceMasks-00086</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkDeviceGroupSubmitInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> All elements of pCommandBufferDeviceMasks must be valid device masks</th></tr>
<tr><th>VUID-VkDeviceGroupSubmitInfo-pCommandBufferDeviceMasks-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupSubmitInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If commandBufferCount is not 0, pCommandBufferDeviceMasks must be a valid pointer to an array of commandBufferCount uint32_t values</th></tr>
<tr><th>VUID-VkDeviceGroupSubmitInfo-pSignalSemaphoreDeviceIndices-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupSubmitInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If signalSemaphoreCount is not 0, pSignalSemaphoreDeviceIndices must be a valid pointer to an array of signalSemaphoreCount uint32_t values</th></tr>
<tr><th>VUID-VkDeviceGroupSubmitInfo-pWaitSemaphoreDeviceIndices-00085</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupSubmitInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> All elements of pWaitSemaphoreDeviceIndices and pSignalSemaphoreDeviceIndices must be valid device indices</th></tr>
<tr><th>VUID-VkDeviceGroupSubmitInfo-pWaitSemaphoreDeviceIndices-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupSubmitInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If waitSemaphoreCount is not 0, pWaitSemaphoreDeviceIndices must be a valid pointer to an array of waitSemaphoreCount uint32_t values</th></tr>
<tr><th>VUID-VkDeviceGroupSubmitInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupSubmitInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO</th></tr>
<tr><th>VUID-VkDeviceGroupSubmitInfo-signalSemaphoreCount-00084</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupSubmitInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> signalSemaphoreCount must equal VkSubmitInfo::signalSemaphoreCount</th></tr>
<tr><th>VUID-VkDeviceGroupSubmitInfo-waitSemaphoreCount-00082</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceGroupSubmitInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> waitSemaphoreCount must equal VkSubmitInfo::waitSemaphoreCount</th></tr>
<tr><th>VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> modes must be a valid combination of VkDeviceGroupPresentModeFlagBitsKHR values</th></tr>
<tr><th>VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> modes must not be 0</th></tr>
<tr><th>VUID-VkDeviceGroupSwapchainCreateInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceGroupSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkDeviceMemoryOverallocationCreateInfoAMD-overallocationBehavior-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceMemoryOverallocationCreateInfoAMD</th><th>(VK_AMD_memory_overallocation_behavior)</th><th> overallocationBehavior must be a valid VkMemoryOverallocationBehaviorAMD value</th></tr>
<tr><th>VUID-VkDeviceMemoryOverallocationCreateInfoAMD-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceMemoryOverallocationCreateInfoAMD</th><th>(VK_AMD_memory_overallocation_behavior)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD</th></tr>
<tr><th>VUID-VkDeviceQueueCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueCreateInfo</th><th>core</th><th> flags must be a valid combination of VkDeviceQueueCreateFlagBits values</th></tr>
<tr><th>VUID-VkDeviceQueueCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueCreateInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkDeviceQueueGlobalPriorityCreateInfoEXT</th></tr>
<tr><th>VUID-VkDeviceQueueCreateInfo-pQueuePriorities-00383</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDeviceQueueCreateInfo</th><th>core</th><th> Each element of pQueuePriorities must be between 0.0 and 1.0 inclusive</th></tr>
<tr><th>VUID-VkDeviceQueueCreateInfo-pQueuePriorities-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueCreateInfo</th><th>core</th><th> pQueuePriorities must be a valid pointer to an array of queueCount float values</th></tr>
<tr><th>VUID-VkDeviceQueueCreateInfo-queueCount-00382</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDeviceQueueCreateInfo</th><th>core</th><th> queueCount must be less than or equal to the queueCount member of the VkQueueFamilyProperties structure, as returned by vkGetPhysicalDeviceQueueFamilyProperties in the pQueueFamilyProperties[queueFamilyIndex]</th></tr>
<tr><th>VUID-VkDeviceQueueCreateInfo-queueCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueCreateInfo</th><th>core</th><th> queueCount must be greater than 0</th></tr>
<tr><th>VUID-VkDeviceQueueCreateInfo-queueFamilyIndex-00381</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkDeviceQueueCreateInfo</th><th>core</th><th> queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties</th></tr>
<tr><th>VUID-VkDeviceQueueCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</th></tr>
<tr><th>VUID-VkDeviceQueueGlobalPriorityCreateInfoEXT-globalPriority-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueGlobalPriorityCreateInfoEXT</th><th>(VK_EXT_global_priority)</th><th> globalPriority must be a valid VkQueueGlobalPriorityEXT value</th></tr>
<tr><th>VUID-VkDeviceQueueGlobalPriorityCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueGlobalPriorityCreateInfoEXT</th><th>(VK_EXT_global_priority)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkDeviceQueueInfo2-flags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueInfo2</th><th>(VK_VERSION_1_1)</th><th> flags must be a valid combination of VkDeviceQueueCreateFlagBits values</th></tr>
<tr><th>VUID-VkDeviceQueueInfo2-flags-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueInfo2</th><th>(VK_VERSION_1_1)</th><th> flags must not be 0</th></tr>
<tr><th>VUID-VkDeviceQueueInfo2-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueInfo2</th><th>(VK_VERSION_1_1)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDeviceQueueInfo2-queueFamilyIndex-01842</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceQueueInfo2</th><th>(VK_VERSION_1_1)</th><th> queueFamilyIndex must be one of the queue family indices specified when device was created, via the VkDeviceQueueCreateInfo structure</th></tr>
<tr><th>VUID-VkDeviceQueueInfo2-queueIndex-01843</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDeviceQueueInfo2</th><th>(VK_VERSION_1_1)</th><th> queueIndex must be less than the number of queues created for the specified queue family index and VkDeviceQueueCreateFlags member flags equal to this flags value when device was created, via the queueCount member of the VkDeviceQueueCreateInfo structure</th></tr>
<tr><th>VUID-VkDeviceQueueInfo2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDeviceQueueInfo2</th><th>(VK_VERSION_1_1)</th><th> sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2</th></tr>
<tr><th>VUID-VkDispatchIndirectCommand-x-00417</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDispatchIndirectCommand</th><th>core</th><th> x must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]</th></tr>
<tr><th>VUID-VkDispatchIndirectCommand-y-00418</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDispatchIndirectCommand</th><th>core</th><th> y must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]</th></tr>
<tr><th>VUID-VkDispatchIndirectCommand-z-00419</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDispatchIndirectCommand</th><th>core</th><th> z must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]</th></tr>
<tr><th>VUID-VkDisplayEventInfoEXT-displayEvent-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayEventInfoEXT</th><th>(VK_EXT_display_control)</th><th> displayEvent must be a valid VkDisplayEventTypeEXT value</th></tr>
<tr><th>VUID-VkDisplayEventInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayEventInfoEXT</th><th>(VK_EXT_display_control)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDisplayEventInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayEventInfoEXT</th><th>(VK_EXT_display_control)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT</th></tr>
<tr><th>VUID-VkDisplayModeCreateInfoKHR-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayModeCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkDisplayModeCreateInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayModeCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDisplayModeCreateInfoKHR-parameters-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDisplayModeCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> parameters must be a valid VkDisplayModeParametersKHR structure</th></tr>
<tr><th>VUID-VkDisplayModeCreateInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayModeCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkDisplayModeParametersKHR-height-01991</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplayModeParametersKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> The height member of visibleRegion must be greater than 0</th></tr>
<tr><th>VUID-VkDisplayModeParametersKHR-refreshRate-01992</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplayModeParametersKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> refreshRate must be greater than 0</th></tr>
<tr><th>VUID-VkDisplayModeParametersKHR-width-01990</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplayModeParametersKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> The width member of visibleRegion must be greater than 0</th></tr>
<tr><th>VUID-VkDisplayModeProperties2KHR-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDisplayModeProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDisplayModeProperties2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayModeProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR</th></tr>
<tr><th>VUID-VkDisplayNativeHdrSurfaceCapabilitiesAMD-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDisplayNativeHdrSurfaceCapabilitiesAMD</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_AMD_display_native_hdr)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD</th></tr>
<tr><th>VUID-VkDisplayPlaneCapabilities2KHR-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDisplayPlaneCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDisplayPlaneCapabilities2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayPlaneCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR</th></tr>
<tr><th>VUID-VkDisplayPlaneInfo2KHR-mode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayPlaneInfo2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> mode must be a valid VkDisplayModeKHR handle</th></tr>
<tr><th>VUID-VkDisplayPlaneInfo2KHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayPlaneInfo2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDisplayPlaneInfo2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayPlaneInfo2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR</th></tr>
<tr><th>VUID-VkDisplayPlaneProperties2KHR-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDisplayPlaneProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDisplayPlaneProperties2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayPlaneProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR</th></tr>
<tr><th>VUID-VkDisplayPowerInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayPowerInfoEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDisplayPowerInfoEXT-powerState-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayPowerInfoEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control)</th><th> powerState must be a valid VkDisplayPowerStateEXT value</th></tr>
<tr><th>VUID-VkDisplayPowerInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayPowerInfoEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT</th></tr>
<tr><th>VUID-VkDisplayPresentInfoKHR-dstRect-01258</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplayPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)</th><th> dstRect must specify a rectangular region that is a subset of the visibleRegion parameter of the display mode the swapchain being presented uses</th></tr>
<tr><th>VUID-VkDisplayPresentInfoKHR-persistentContent-01259</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplayPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)</th><th> If the persistentContent member of the VkDisplayPropertiesKHR structure returned by vkGetPhysicalDeviceDisplayPropertiesKHR for the display the present operation targets then persistent must be VK_FALSE</th></tr>
<tr><th>VUID-VkDisplayPresentInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDisplayPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR</th></tr>
<tr><th>VUID-VkDisplayPresentInfoKHR-srcRect-01257</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplayPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)</th><th> srcRect must specify a rectangular region that is a subset of the image being presented</th></tr>
<tr><th>VUID-VkDisplayProperties2KHR-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDisplayProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDisplayProperties2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplayProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01254</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> If alphaMode is VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR then globalAlpha must be between 0 and 1, inclusive</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01255</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> alphaMode must be 0 or one of the bits present in the supportedAlpha member of VkDisplayPlaneCapabilitiesKHR returned by vkGetDisplayPlaneCapabilitiesKHR for the display plane corresponding to displayMode</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> alphaMode must be a valid VkDisplayPlaneAlphaFlagBitsKHR value</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-displayMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> displayMode must be a valid VkDisplayModeKHR handle</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-planeIndex-01252</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> planeIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-planeReorderPossible-01253</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> If the planeReorderPossible member of the VkDisplayPropertiesKHR structure returned by vkGetPhysicalDeviceDisplayPropertiesKHR for the display corresponding to displayMode is VK_TRUE then planeStackIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR; otherwise planeStackIndex must equal the currentStackIndex member of VkDisplayPlanePropertiesKHR returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR for the display plane corresponding to displayMode</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> sType must be VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-transform-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> transform must be a valid VkSurfaceTransformFlagBitsKHR value</th></tr>
<tr><th>VUID-VkDisplaySurfaceCreateInfoKHR-width-01256</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDisplaySurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> The width and height members of imageExtent must be less than the maxImageDimensions2D member of VkPhysicalDeviceLimits</th></tr>
<tr><th>VUID-VkDrawIndexedIndirectCommand-None-00552</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDrawIndexedIndirectCommand</th><th>core</th><th> For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description</th></tr>
<tr><th>VUID-VkDrawIndexedIndirectCommand-firstInstance-00554</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDrawIndexedIndirectCommand</th><th>core</th><th> If the drawIndirectFirstInstance feature is not enabled, firstInstance must be 0</th></tr>
<tr><th>VUID-VkDrawIndexedIndirectCommand-indexSize-00553</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDrawIndexedIndirectCommand</th><th>core</th><th> (indexSize * (firstIndex + indexCount) + offset) must be less than or equal to the size of the bound index buffer, with indexSize being based on the type specified by indexType, where the index buffer, indexType, and offset are specified via vkCmdBindIndexBuffer</th></tr>
<tr><th>VUID-VkDrawIndirectCommand-None-00500</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDrawIndirectCommand</th><th>core</th><th> For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description</th></tr>
<tr><th>VUID-VkDrawIndirectCommand-firstInstance-00501</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDrawIndirectCommand</th><th>core</th><th> If the drawIndirectFirstInstance feature is not enabled, firstInstance must be 0</th></tr>
<tr><th>VUID-VkDrawMeshTasksIndirectCommandNV-taskCount-02175</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkDrawMeshTasksIndirectCommandNV</th><th>(VK_NV_mesh_shader)</th><th> taskCount must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount</th></tr>
<tr><th>VUID-VkDrmFormatModifierPropertiesListEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkDrmFormatModifierPropertiesListEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_image_drm_format_modifier)</th><th> sType must be VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT</th></tr>
<tr><th>VUID-VkEventCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkEventCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkEventCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkEventCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkEventCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkEventCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO</th></tr>
<tr><th>VUID-VkExportFenceCreateInfo-handleTypes-01446</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkExportFenceCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_fence)</th><th> The bits in handleTypes must be supported and compatible, as reported by VkExternalFenceProperties.</th></tr>
<tr><th>VUID-VkExportFenceCreateInfo-handleTypes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkExportFenceCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_fence)</th><th> handleTypes must be a valid combination of VkExternalFenceHandleTypeFlagBits values</th></tr>
<tr><th>VUID-VkExportFenceCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportFenceCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_fence)</th><th> sType must be VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO</th></tr>
<tr><th>VUID-VkExportFenceWin32HandleInfoKHR-handleTypes-01447</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkExportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If VkExportFenceCreateInfo::handleTypes does not include VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, VkExportFenceWin32HandleInfoKHR must not be in the pNext chain of VkFenceCreateInfo.</th></tr>
<tr><th>VUID-VkExportFenceWin32HandleInfoKHR-pAttributes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value</th></tr>
<tr><th>VUID-VkExportFenceWin32HandleInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> sType must be VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR</th></tr>
<tr><th>VUID-VkExportMemoryAllocateInfo-handleTypes-00656</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkExportMemoryAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> The bits in handleTypes must be supported and compatible, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties.</th></tr>
<tr><th>VUID-VkExportMemoryAllocateInfo-handleTypes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkExportMemoryAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values</th></tr>
<tr><th>VUID-VkExportMemoryAllocateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportMemoryAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO</th></tr>
<tr><th>VUID-VkExportMemoryAllocateInfoNV-handleTypes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkExportMemoryAllocateInfoNV</th><th>(VK_NV_external_memory)</th><th> handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values</th></tr>
<tr><th>VUID-VkExportMemoryAllocateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportMemoryAllocateInfoNV</th><th>(VK_NV_external_memory)</th><th> sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV</th></tr>
<tr><th>VUID-VkExportMemoryWin32HandleInfoKHR-handleTypes-00657</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkExportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If VkExportMemoryAllocateInfo::handleTypes does not include VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, VkExportMemoryWin32HandleInfoKHR must not be in the pNext chain of VkMemoryAllocateInfo.</th></tr>
<tr><th>VUID-VkExportMemoryWin32HandleInfoKHR-pAttributes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value</th></tr>
<tr><th>VUID-VkExportMemoryWin32HandleInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR</th></tr>
<tr><th>VUID-VkExportMemoryWin32HandleInfoNV-pAttributes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportMemoryWin32HandleInfoNV</th><th>(VK_NV_external_memory_win32)</th><th> If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value</th></tr>
<tr><th>VUID-VkExportMemoryWin32HandleInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportMemoryWin32HandleInfoNV</th><th>(VK_NV_external_memory_win32)</th><th> sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV</th></tr>
<tr><th>VUID-VkExportSemaphoreCreateInfo-handleTypes-01124</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkExportSemaphoreCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore)</th><th> The bits in handleTypes must be supported and compatible, as reported by VkExternalSemaphoreProperties.</th></tr>
<tr><th>VUID-VkExportSemaphoreCreateInfo-handleTypes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkExportSemaphoreCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore)</th><th> handleTypes must be a valid combination of VkExternalSemaphoreHandleTypeFlagBits values</th></tr>
<tr><th>VUID-VkExportSemaphoreCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportSemaphoreCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore)</th><th> sType must be VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO</th></tr>
<tr><th>VUID-VkExportSemaphoreWin32HandleInfoKHR-handleTypes-01125</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkExportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If VkExportSemaphoreCreateInfo::handleTypes does not include VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, VkExportSemaphoreWin32HandleInfoKHR must not be in the pNext chain of VkSemaphoreCreateInfo.</th></tr>
<tr><th>VUID-VkExportSemaphoreWin32HandleInfoKHR-pAttributes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value</th></tr>
<tr><th>VUID-VkExportSemaphoreWin32HandleInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> sType must be VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR</th></tr>
<tr><th>VUID-VkExternalBufferProperties-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExternalBufferProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkExternalBufferProperties-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkExternalBufferProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> sType must be VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES</th></tr>
<tr><th>VUID-VkExternalFenceProperties-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExternalFenceProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkExternalFenceProperties-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkExternalFenceProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)</th><th> sType must be VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES</th></tr>
<tr><th>VUID-VkExternalFormatANDROID-externalFormat-01894</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferImageCreate</th><th>explicit</th><th>VkExternalFormatANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> externalFormat must be 0 or a value returned in the externalFormat member of VkAndroidHardwareBufferFormatPropertiesANDROID by an earlier call to vkGetAndroidHardwareBufferPropertiesANDROID</th></tr>
<tr><th>VUID-VkExternalFormatANDROID-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExternalFormatANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> sType must be VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID</th></tr>
<tr><th>VUID-VkExternalImageFormatProperties-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExternalImageFormatProperties</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> sType must be VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES</th></tr>
<tr><th>VUID-VkExternalMemoryBufferCreateInfo-handleTypes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkExternalMemoryBufferCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values</th></tr>
<tr><th>VUID-VkExternalMemoryBufferCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExternalMemoryBufferCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO</th></tr>
<tr><th>VUID-VkExternalMemoryImageCreateInfo-handleTypes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExternalMemoryImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values</th></tr>
<tr><th>VUID-VkExternalMemoryImageCreateInfo-handleTypes-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkExternalMemoryImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> handleTypes must not be 0</th></tr>
<tr><th>VUID-VkExternalMemoryImageCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExternalMemoryImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO</th></tr>
<tr><th>VUID-VkExternalMemoryImageCreateInfoNV-handleTypes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkExternalMemoryImageCreateInfoNV</th><th>(VK_NV_external_memory)</th><th> handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values</th></tr>
<tr><th>VUID-VkExternalMemoryImageCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExternalMemoryImageCreateInfoNV</th><th>(VK_NV_external_memory)</th><th> sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkExternalSemaphoreProperties-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkExternalSemaphoreProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkExternalSemaphoreProperties-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkExternalSemaphoreProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)</th><th> sType must be VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES</th></tr>
<tr><th>VUID-VkFenceCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceCreateInfo</th><th>core</th><th> flags must be a valid combination of VkFenceCreateFlagBits values</th></tr>
<tr><th>VUID-VkFenceCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportFenceCreateInfo or VkExportFenceWin32HandleInfoKHR</th></tr>
<tr><th>VUID-VkFenceCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO</th></tr>
<tr><th>VUID-VkFenceCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkFenceCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkFenceGetFdInfoKHR-fence-01455</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFenceGetFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> fence must not currently have its payload replaced by an imported payload as described below in Importing Fence Payloads unless that imported payload's handle type was included in VkExternalFenceProperties::exportFromImportedHandleTypes for handleType.</th></tr>
<tr><th>VUID-VkFenceGetFdInfoKHR-fence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceGetFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> fence must be a valid VkFence handle</th></tr>
<tr><th>VUID-VkFenceGetFdInfoKHR-handleType-01453</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFenceGetFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> handleType must have been included in VkExportFenceCreateInfo::handleTypes when fence's current payload was created.</th></tr>
<tr><th>VUID-VkFenceGetFdInfoKHR-handleType-01454</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFenceGetFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> If handleType refers to a handle type with copy payload transference semantics, fence must be signaled, or have an associated fence signal operation pending execution.</th></tr>
<tr><th>VUID-VkFenceGetFdInfoKHR-handleType-01456</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFenceGetFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> handleType must be defined as a POSIX file descriptor handle.</th></tr>
<tr><th>VUID-VkFenceGetFdInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceGetFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> handleType must be a valid VkExternalFenceHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkFenceGetFdInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceGetFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkFenceGetFdInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceGetFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> sType must be VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR</th></tr>
<tr><th>VUID-VkFenceGetWin32HandleInfoKHR-fence-01450</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFenceGetWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> fence must not currently have its payload replaced by an imported payload as described below in Importing Fence Payloads unless that imported payload's handle type was included in VkExternalFenceProperties::exportFromImportedHandleTypes for handleType.</th></tr>
<tr><th>VUID-VkFenceGetWin32HandleInfoKHR-fence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceGetWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> fence must be a valid VkFence handle</th></tr>
<tr><th>VUID-VkFenceGetWin32HandleInfoKHR-handleType-01448</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFenceGetWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> handleType must have been included in VkExportFenceCreateInfo::handleTypes when the fence's current payload was created.</th></tr>
<tr><th>VUID-VkFenceGetWin32HandleInfoKHR-handleType-01449</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFenceGetWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If handleType is defined as an NT handle, vkGetFenceWin32HandleKHR must be called no more than once for each valid unique combination of fence and handleType.</th></tr>
<tr><th>VUID-VkFenceGetWin32HandleInfoKHR-handleType-01451</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFenceGetWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If handleType refers to a handle type with copy payload transference semantics, fence must be signaled, or have an associated fence signal operation pending execution.</th></tr>
<tr><th>VUID-VkFenceGetWin32HandleInfoKHR-handleType-01452</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFenceGetWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> handleType must be defined as an NT handle or a global share handle.</th></tr>
<tr><th>VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceGetWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> handleType must be a valid VkExternalFenceHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkFenceGetWin32HandleInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceGetWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkFenceGetWin32HandleInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFenceGetWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> sType must be VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR</th></tr>
<tr><th>VUID-VkFilterCubicImageViewImageFormatPropertiesEXT-pNext-02627</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFilterCubicImageViewImageFormatPropertiesEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_filter_cubic)</th><th> If the pNext chain of the VkImageFormatProperties2 structure contains an instance of VkFilterCubicImageViewImageFormatPropertiesEXT, the pNext chain of the VkPhysicalDeviceImageFormatInfo2 structure must contain an instance of VkPhysicalDeviceImageViewImageFormatInfoEXT with an imageViewType that is compatible with imageType.</th></tr>
<tr><th>VUID-VkFilterCubicImageViewImageFormatPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkFilterCubicImageViewImageFormatPropertiesEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_filter_cubic)</th><th> sType must be VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkFormatProperties2-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pNext must be NULL or a pointer to a valid instance of VkDrmFormatModifierPropertiesListEXT</th></tr>
<tr><th>VUID-VkFormatProperties2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-attachmentCount-00876</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> attachmentCount must be equal to the attachment count specified in renderPass</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> Both of renderPass, and the elements of pAttachments that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-height-00887</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> height must be greater than 0.</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-height-00888</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-layers-00889</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> layers must be greater than 0.</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-layers-00890</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> layers must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferLayers</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-00877</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> Each element of pAttachments that is used as a color attachment or resolve attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-00879</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> Each element of pAttachments that is used as an input attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-00880</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> Each element of pAttachments must have been created with an VkFormat value that matches the VkFormat specified by the corresponding VkAttachmentDescription in renderPass</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-00881</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> Each element of pAttachments must have been created with a samples value that matches the samples value specified by the corresponding VkAttachmentDescription in renderPass</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-00882</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>!(VK_EXT_fragment_density_map)</th><th> Each element of pAttachments must have dimensions at least as large as the corresponding framebuffer dimension</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-00883</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> Each element of pAttachments must only specify a single mip level</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-00884</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> Each element of pAttachments must have been created with the identity swizzle</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-00891</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> Each element of pAttachments that is a 2D or 2D array image view taken from a 3D image must not be a depth/stencil format</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-02552</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> Each element of pAttachments that is used as a fragment density map attachment by renderPass must not have been created with a flags value including VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT.</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-02554</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> Each element of pAttachments must have dimensions at least as large as the corresponding framebuffer dimension except for any element that is referenced by fragmentDensityMapAttachment</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-02555</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> An element of pAttachments that is referenced by fragmentDensityMapAttachment must have a width at least as large as the ceiling of width/maxFragmentDensityTexelSize.width</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-02556</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> An element of pAttachments that is referenced by fragmentDensityMapAttachment must have a height at least as large as the ceiling of height/maxFragmentDensityTexelSize.height</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-02633</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> Each element of pAttachments that is used as a depth/stencil attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-02634</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>(VK_KHR_depth_stencil_resolve)</th><th> Each element of pAttachments that is used as a depth/stencil resolve attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkImageView handles</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-renderPass-02531</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If renderPass was specified with non-zero view masks, layers must be greater than or equal to the greatest position of any bit included in any of those view masks</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-renderPass-02553</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If renderPass has a fragment density map attachment and non-subsample image feature is not enabled, each element of pAttachments must have been created with a flags value including VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT unless that element is the fragment density map attachment.</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-renderPass-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> renderPass must be a valid VkRenderPass handle</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-width-00885</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> width must be greater than 0.</th></tr>
<tr><th>VUID-VkFramebufferCreateInfo-width-00886</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferCreateErrors</th><th>explicit</th><th>VkFramebufferCreateInfo</th><th>core</th><th> width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth</th></tr>
<tr><th>VUID-VkGeometryAABBNV-aabbData-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkGeometryAABBNV</th><th>(VK_NV_ray_tracing)</th><th> If aabbData is not VK_NULL_HANDLE, aabbData must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkGeometryAABBNV-offset-02439</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryAABBNV</th><th>(VK_NV_ray_tracing)</th><th> offset must be less than the size of aabbData</th></tr>
<tr><th>VUID-VkGeometryAABBNV-offset-02440</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryAABBNV</th><th>(VK_NV_ray_tracing)</th><th> offset must be a multiple of 8</th></tr>
<tr><th>VUID-VkGeometryAABBNV-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGeometryAABBNV</th><th>(VK_NV_ray_tracing)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkGeometryAABBNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGeometryAABBNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV</th></tr>
<tr><th>VUID-VkGeometryAABBNV-stride-02441</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryAABBNV</th><th>(VK_NV_ray_tracing)</th><th> stride must be a multiple of 8</th></tr>
<tr><th>VUID-VkGeometryDataNV-aabbs-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkGeometryDataNV</th><th>(VK_NV_ray_tracing)</th><th> aabbs must be a valid VkGeometryAABBNV structure</th></tr>
<tr><th>VUID-VkGeometryDataNV-triangles-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkGeometryDataNV</th><th>(VK_NV_ray_tracing)</th><th> triangles must be a valid VkGeometryTrianglesNV structure</th></tr>
<tr><th>VUID-VkGeometryNV-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGeometryNV</th><th>(VK_NV_ray_tracing)</th><th> flags must be a valid combination of VkGeometryFlagBitsNV values</th></tr>
<tr><th>VUID-VkGeometryNV-geometry-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkGeometryNV</th><th>(VK_NV_ray_tracing)</th><th> geometry must be a valid VkGeometryDataNV structure</th></tr>
<tr><th>VUID-VkGeometryNV-geometryType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGeometryNV</th><th>(VK_NV_ray_tracing)</th><th> geometryType must be a valid VkGeometryTypeNV value</th></tr>
<tr><th>VUID-VkGeometryNV-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGeometryNV</th><th>(VK_NV_ray_tracing)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkGeometryNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGeometryNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_GEOMETRY_NV</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-commonparent</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> Each of indexData, transformData, and vertexData that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-indexCount-02436</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> indexCount must be 0 if indexType is VK_INDEX_TYPE_NONE_NV</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-indexData-02434</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> indexData must be VK_NULL_HANDLE if indexType is VK_INDEX_TYPE_NONE_NV</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-indexData-02435</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> indexData must be a valid VkBuffer handle if indexType is not VK_INDEX_TYPE_NONE_NV</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-indexData-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> If indexData is not VK_NULL_HANDLE, indexData must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-indexOffset-02431</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> indexOffset must be less than the size of indexData</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-indexOffset-02432</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> indexOffset must be a multiple of the element size of indexType</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-indexType-02433</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> indexType must be VK_INDEX_TYPE_UINT16, VK_INDEX_TYPE_UINT32, or VK_INDEX_TYPE_NONE_NV</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-indexType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> indexType must be a valid VkIndexType value</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-transformData-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> If transformData is not VK_NULL_HANDLE, transformData must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-transformOffset-02437</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> transformOffset must be less than the size of transformData</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-transformOffset-02438</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> transformOffset must be a multiple of 16</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-vertexData-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> If vertexData is not VK_NULL_HANDLE, vertexData must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-vertexFormat-02430</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> vertexFormat must be one of VK_FORMAT_R32G32B32_SFLOAT, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16B16_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R16G16_SNORM, or VK_FORMAT_R16G16B16_SNORM</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-vertexFormat-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> vertexFormat must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-vertexOffset-02428</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> vertexOffset must be less than the size of vertexData</th></tr>
<tr><th>VUID-VkGeometryTrianglesNV-vertexOffset-02429</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGeometryTrianglesNV</th><th>(VK_NV_ray_tracing)</th><th> vertexOffset must be a multiple of the component size of vertexFormat</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-None-02322</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_transform_feedback)+(VK_NV_mesh_shader)</th><th> If there are any mesh shader stages in the pipeline there must not be any shader stage in the pipeline with a Xfb execution mode.</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-attachmentCount-00746</th><th><span style="color:limegreen;">Y</span></th><th>NumBlendAttachMismatch</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If rasterization is not disabled and the subpass uses color attachments, the attachmentCount member of pColorBlendState must be equal to the colorAttachmentCount used to create subpass</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-blendEnable-02023</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If rasterization is not disabled and the subpass uses color attachments, then for each color attachment in the subpass the blendEnable member of the corresponding element of the pAttachment member of pColorBlendState must be VK_FALSE if the attached image's format features does not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT.</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> Each of basePipelineHandle, layout, and renderPass that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-flags-00722</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a graphics VkPipeline</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-flags-00723</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-flags-00724</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-flags-00725</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-flags-00764</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> flags must not contain the VK_PIPELINE_CREATE_DISPATCH_BASE flag.</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> flags must be a valid combination of VkPipelineCreateFlagBits values</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-geometryStreams-02321</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_transform_feedback)</th><th> If the last vertex processing stage is a geometry shader, and that geometry shader uses the GeometryStreams capability, then VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams feature must be enabled</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-layout-00756</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> layout must be consistent with all shaders specified in pStages</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-layout-01688</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> The number of resources in layout accessible to each shader stage that is used by the pipeline must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-layout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> layout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicState-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pDynamicState is not NULL, pDynamicState must be a valid pointer to a valid VkPipelineDynamicStateCreateInfo structure</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00747</th><th><span style="color:limegreen;">Y</span></th><th>PSOViewportStateMultiViewportTests, PSOViewportStateTests</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT, the pViewports member of pViewportState must be a valid pointer to an array of pViewportState::viewportCount valid VkViewport structures</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00748</th><th><span style="color:limegreen;">Y</span></th><th>PSOViewportStateMultiViewportTests, PSOViewportStateTests</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SCISSOR, the pScissors member of pViewportState must be a valid pointer to an array of pViewportState::scissorCount VkRect2D structures</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00749</th><th><span style="color:limegreen;">Y</span></th><th>PSOLineWidthInvalid</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If the wide lines feature is not enabled, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_LINE_WIDTH, the lineWidth member of pRasterizationState must be 1.0</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00754</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If the depth bias clamping feature is not enabled, no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BIAS, and the depthBiasEnable member of pRasterizationState is VK_TRUE, the depthBiasClamp member of pRasterizationState must be 0.0</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00755</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>!(VK_EXT_depth_range_unrestricted)</th><th> If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the depthBoundsTestEnable member of pDepthStencilState is VK_TRUE, the minDepthBounds and maxDepthBounds members of pDepthStencilState must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01521</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_sample_locations)</th><th> If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationGridSize.width must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01522</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_sample_locations)</th><th> If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationGridSize.height must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01523</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_sample_locations)</th><th> If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationsPerPixel must equal rasterizationSamples</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01715</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_NV_clip_space_w_scaling)</th><th> If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV, and the viewportWScalingEnable member of a VkPipelineViewportWScalingStateCreateInfoNV structure, chained to the pNext chain of pViewportState, is VK_TRUE, the pViewportWScalings member of the VkPipelineViewportWScalingStateCreateInfoNV must be a pointer to an array of VkPipelineViewportWScalingStateCreateInfoNV::viewportCount valid VkViewportWScalingNV structures</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-02510</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_depth_range_unrestricted)</th><th> If the VK_EXT_depth_range_unrestricted extension is not enabled and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the depthBoundsTestEnable member of pDepthStencilState is VK_TRUE, the minDepthBounds and maxDepthBounds members of pDepthStencilState must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineDiscardRectangleStateCreateInfoEXT, or VkPipelineRepresentativeFragmentTestStateCreateInfoNV</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> pRasterizationState must be a valid pointer to a valid VkPipelineRasterizationStateCreateInfo structure</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00729</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineTessErrors</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes a tessellation control shader stage, it must include a tessellation evaluation shader stage</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00730</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineTessErrors</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes a tessellation evaluation shader stage, it must include a tessellation control shader stage</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00731</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineTessErrors</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes a tessellation control shader stage and a tessellation evaluation shader stage, pTessellationState must be a valid pointer to a valid VkPipelineTessellationStateCreateInfo structure</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00732</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes tessellation shader stages, the shader code of at least one stage must contain an OpExecutionMode instruction that specifies the type of subdivision in the pipeline</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00733</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes tessellation shader stages, and the shader code of both stages contain an OpExecutionMode instruction that specifies the type of subdivision in the pipeline, they must both specify the same subdivision mode</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00734</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes tessellation shader stages, the shader code of at least one stage must contain an OpExecutionMode instruction that specifies the output patch size in the pipeline</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00735</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes tessellation shader stages, and the shader code of both contain an OpExecutionMode instruction that specifies the out patch size in the pipeline, they must both specify the same patch size</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00736</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineTessErrors</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes tessellation shader stages, the topology member of pInputAssembly must be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00738</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes a geometry shader stage, and does not include any tessellation shader stages, its shader code must contain an OpExecutionMode instruction that specifies an input primitive type that is compatible with the primitive topology specified in pInputAssembly</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00739</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes a geometry shader stage, and also includes tessellation shader stages, its shader code must contain an OpExecutionMode instruction that specifies an input primitive type that is compatible with the primitive topology that is output by the tessellation stages</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00740</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes a fragment shader stage and a geometry shader stage, and the fragment shader code reads from an input variable that is decorated with PrimitiveID, then the geometry shader code must write to a matching output variable, decorated with PrimitiveID, in all execution paths</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00741</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes a fragment shader stage, its shader code must not read from any input attachment that is defined as VK_ATTACHMENT_UNUSED in subpass</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-00742</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> The shader code for the entry points identified by pStages, and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-01565</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If pStages includes a fragment shader stage and an input attachment was referenced by the VkRenderPassInputAttachmentAspectCreateInfo at renderPass create time, its shader code must not read from any aspect that was not specified in the aspectMask of the corresponding VkInputAttachmentAspectReference structure.</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-02095</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderNV</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_NV_mesh_shader)</th><th> The geometric shader stages provided in pStages must be either from the mesh shading pipeline (stage is VK_SHADER_STAGE_TASK_BIT_NV or VK_SHADER_STAGE_MESH_BIT_NV) or from the primitive shading pipeline (stage is VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or VK_SHADER_STAGE_GEOMETRY_BIT).</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-02097</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderNV</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes a vertex shader stage, pVertexInputState must be a valid pointer to a valid VkPipelineVertexInputStateCreateInfo structure</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-02098</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderNV</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If pStages includes a vertex shader stage, pInputAssemblyState must be a valid pointer to a valid VkPipelineInputAssemblyStateCreateInfo structure</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-02317</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_transform_feedback)</th><th> The Xfb execution mode can be specified by only one shader stage in pStages</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-02318</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_transform_feedback)</th><th> If any shader stage in pStages specifies Xfb execution mode it must be the last vertex processing stage</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-pStages-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-rasterizationStream-02319</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_transform_feedback)</th><th> If a VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream value other than zero is specified, all variables in the output interface of the entry point being compiled decorated with Position, PointSize, ClipDistance, or CullDistance must all be decorated with identical Stream values that match the rasterizationStream</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-rasterizationStream-02320</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_transform_feedback)</th><th> If VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream is zero, or not specified, all variables in the output interface of the entry point being compiled decorated with Position, PointSize, ClipDistance, or CullDistance must all be decorated with a Stream value of zero, or must not specify the Stream decoration</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00750</th><th><span style="color:limegreen;">Y</span></th><th>PSOViewportStateTests</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, pViewportState must be a valid pointer to a valid VkPipelineViewportStateCreateInfo structure</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00751</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, pMultisampleState must be a valid pointer to a valid VkPipelineMultisampleStateCreateInfo structure</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00752</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, and subpass uses a depth/stencil attachment, pDepthStencilState must be a valid pointer to a valid VkPipelineDepthStencilStateCreateInfo structure</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00753</th><th><span style="color:limegreen;">Y</span></th><th>PipelineRenderpassCompatibility</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, and subpass uses color attachments, pColorBlendState must be a valid pointer to a valid VkPipelineColorBlendStateCreateInfo structure</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-renderPass-00760</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the renderPass has multiview enabled and subpass has more than one bit set in the view mask and multiviewTessellationShader is not enabled, then pStages must not include tessellation shaders.</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-renderPass-00761</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the renderPass has multiview enabled and subpass has more than one bit set in the view mask and multiviewGeometryShader is not enabled, then pStages must not include a geometry shader.</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-renderPass-00762</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the renderPass has multiview enabled and subpass has more than one bit set in the view mask, shaders in the pipeline must not write to the Layer built-in output</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-renderPass-00763</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the renderPass has multiview enabled, then all shaders must not include variables decorated with the Layer built-in decoration in their interfaces.</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-renderPass-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> renderPass must be a valid VkRenderPass handle</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-sampleLocationsEnable-01524</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_EXT_sample_locations)</th><th> If the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, the fragment shader code must not statically use the extended instruction InterpolateAtSample</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-stage-00726</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> The stage member of each element of pStages must be unique</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-stage-00727</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>!(VK_NV_mesh_shader)</th><th> The stage member of one element of pStages must be VK_SHADER_STAGE_VERTEX_BIT</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-stage-00728</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> The stage member of each element of pStages must not be VK_SHADER_STAGE_COMPUTE_BIT</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-stage-02096</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderNV</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_NV_mesh_shader)</th><th> The stage member of one element of pStages must be either VK_SHADER_STAGE_VERTEX_BIT or VK_SHADER_STAGE_MESH_BIT_NV.</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-stageCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> stageCount must be greater than 0</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-subpass-00743</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If rasterization is not disabled and subpass uses a depth/stencil attachment in renderPass that has a layout of VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL in the VkAttachmentReference defined by subpass, the depthWriteEnable member of pDepthStencilState must be VK_FALSE</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-subpass-00744</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If rasterization is not disabled and subpass uses a depth/stencil attachment in renderPass that has a layout of VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL in the VkAttachmentReference defined by subpass, the failOp, passOp and depthFailOp members of each of the front and back members of pDepthStencilState must be VK_STENCIL_OP_KEEP</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-subpass-00757</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferMixedSamplesNV, NumSamplesMismatch, FramebufferMixedSamples</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, and if subpass uses color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must be the same as the sample count for those subpass attachments</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-subpass-00758</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must follow the rules for a zero-attachment subpass</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-subpass-00759</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> subpass must be a valid subpass within renderPass</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-subpass-01411</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferMixedSamplesNV</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_NV_framebuffer_mixed_samples)</th><th> If the VK_NV_framebuffer_mixed_samples extension is enabled, and if subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled, then the rasterizationSamples member of pMultisampleState must be the same as the sample count of the depth/stencil attachment</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-subpass-01412</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferMixedSamplesNV</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_NV_framebuffer_mixed_samples)</th><th> If the VK_NV_framebuffer_mixed_samples extension is enabled, and if subpass has any color attachments, then the rasterizationSamples member of pMultisampleState must be greater than or equal to the sample count for those subpass attachments</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-subpass-01505</th><th><span style="color:limegreen;">Y</span></th><th>AMDMixedAttachmentSamplesValidateGraphicsPipeline</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_AMD_mixed_attachment_samples)</th><th> If the VK_AMD_mixed_attachment_samples extension is enabled, and if subpass uses color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must equal the maximum of the sample counts of those subpass attachments</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-subpass-01756</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If rasterization is not disabled and subpass uses a depth/stencil attachment in renderPass that has a layout of VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL in the VkAttachmentReference defined by subpass, the depthWriteEnable member of pDepthStencilState must be VK_FALSE</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-subpass-01757</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If rasterization is not disabled and subpass uses a depth/stencil attachment in renderPass that has a layout of VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL in the VkAttachmentReference defined by subpass, the failOp, passOp and depthFailOp members of each of the front and back members of pDepthStencilState must be VK_STENCIL_OP_KEEP</th></tr>
<tr><th>VUID-VkGraphicsPipelineCreateInfo-topology-00737</th><th><span style="color:limegreen;">Y</span></th><th>InvalidTopology, CreatePipelineTessErrors</th><th>explicit</th><th>VkGraphicsPipelineCreateInfo</th><th>core</th><th> If the topology member of pInputAssembly is VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pStages must include tessellation shader stages</th></tr>
<tr><th>VUID-VkHdrMetadataEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkHdrMetadataEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkHdrMetadataEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkHdrMetadataEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata)</th><th> sType must be VK_STRUCTURE_TYPE_HDR_METADATA_EXT</th></tr>
<tr><th>VUID-VkIOSSurfaceCreateInfoMVK-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIOSSurfaceCreateInfoMVK</th><th>(VK_KHR_surface)+(VK_MVK_ios_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkIOSSurfaceCreateInfoMVK-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIOSSurfaceCreateInfoMVK</th><th>(VK_KHR_surface)+(VK_MVK_ios_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkIOSSurfaceCreateInfoMVK-pView-01316</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIOSSurfaceCreateInfoMVK</th><th>(VK_KHR_surface)+(VK_MVK_ios_surface)</th><th> pView must be a valid UIView and must be backed by a CALayer instance of type CAMetalLayer.</th></tr>
<tr><th>VUID-VkIOSSurfaceCreateInfoMVK-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIOSSurfaceCreateInfoMVK</th><th>(VK_KHR_surface)+(VK_MVK_ios_surface)</th><th> sType must be VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK</th></tr>
<tr><th>VUID-VkImageBlit-aspectMask-00238</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> The aspectMask member of srcSubresource and dstSubresource must match</th></tr>
<tr><th>VUID-VkImageBlit-aspectMask-00241</th><th><span style="color:limegreen;">Y</span></th><th>MiscBlitImageTests</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> The aspectMask member of srcSubresource must specify aspects present in the calling command's srcImage</th></tr>
<tr><th>VUID-VkImageBlit-aspectMask-00242</th><th><span style="color:limegreen;">Y</span></th><th>MiscBlitImageTests</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> The aspectMask member of dstSubresource must specify aspects present in the calling command's dstImage</th></tr>
<tr><th>VUID-VkImageBlit-dstImage-00250</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> If the calling command's dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset[0].y must be 0 and dstOffset[1].y must be 1.</th></tr>
<tr><th>VUID-VkImageBlit-dstImage-00252</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> If the calling command's dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then dstOffset[0].z must be 0 and dstOffset[1].z must be 1.</th></tr>
<tr><th>VUID-VkImageBlit-dstOffset-00248</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets, MiscBlitImageTests</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> dstOffset[0].x and dstOffset[1].x must both be greater than or equal to 0 and less than or equal to the destination image subresource width</th></tr>
<tr><th>VUID-VkImageBlit-dstOffset-00249</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets, MiscBlitImageTests</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> dstOffset[0].y and dstOffset[1].y must both be greater than or equal to 0 and less than or equal to the destination image subresource height</th></tr>
<tr><th>VUID-VkImageBlit-dstOffset-00251</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets, MiscBlitImageTests</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> dstOffset[0].z and dstOffset[1].z must both be greater than or equal to 0 and less than or equal to the destination image subresource depth</th></tr>
<tr><th>VUID-VkImageBlit-dstSubresource-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageBlit</th><th>core</th><th> dstSubresource must be a valid VkImageSubresourceLayers structure</th></tr>
<tr><th>VUID-VkImageBlit-layerCount-00239</th><th><span style="color:limegreen;">Y</span></th><th>MiscBlitImageTests</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> The layerCount member of srcSubresource and dstSubresource must match</th></tr>
<tr><th>VUID-VkImageBlit-srcImage-00240</th><th><span style="color:limegreen;">Y</span></th><th>MiscBlitImageTests</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> If either of the calling command's srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of both srcSubresource and dstSubresource must be 0 and 1, respectively</th></tr>
<tr><th>VUID-VkImageBlit-srcImage-00245</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> If the calling command's srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset[0].y must be 0 and srcOffset[1].y must be 1.</th></tr>
<tr><th>VUID-VkImageBlit-srcImage-00247</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> If the calling command's srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then srcOffset[0].z must be 0 and srcOffset[1].z must be 1.</th></tr>
<tr><th>VUID-VkImageBlit-srcOffset-00243</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets, MiscBlitImageTests</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> srcOffset[0].x and srcOffset[1].x must both be greater than or equal to 0 and less than or equal to the source image subresource width</th></tr>
<tr><th>VUID-VkImageBlit-srcOffset-00244</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets, MiscBlitImageTests</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> srcOffset[0].y and srcOffset[1].y must both be greater than or equal to 0 and less than or equal to the source image subresource height</th></tr>
<tr><th>VUID-VkImageBlit-srcOffset-00246</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets, MiscBlitImageTests</th><th>explicit</th><th>VkImageBlit</th><th>core</th><th> srcOffset[0].z and srcOffset[1].z must both be greater than or equal to 0 and less than or equal to the source image subresource depth</th></tr>
<tr><th>VUID-VkImageBlit-srcSubresource-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageBlit</th><th>core</th><th> srcSubresource must be a valid VkImageSubresourceLayers structure</th></tr>
<tr><th>VUID-VkImageCopy-aspectMask-00137</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageAspectMismatch</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> The aspectMask member of srcSubresource and dstSubresource must match</th></tr>
<tr><th>VUID-VkImageCopy-aspectMask-00142</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageAspectMismatch</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> The aspectMask member of srcSubresource must specify aspects present in the calling command's srcImage</th></tr>
<tr><th>VUID-VkImageCopy-aspectMask-00143</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageAspectMismatch</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> The aspectMask member of dstSubresource must specify aspects present in the calling command's dstImage</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-00152</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatch</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> If the calling command's dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset.y must be 0 and extent.height must be 1.</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-01554</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageMultiplaneAspectBits</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage has a VkFormat with two planes then the dstSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-01555</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageMultiplaneAspectBits</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage has a VkFormat with three planes then the dstSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-01557</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageMultiplaneAspectBits</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage has a multi-planar image format and the srcImage does not have a multi-planar image format, the srcSubresource aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-01731</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageSinglePlane422Alignment, CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage is a compressed format image, or a single-plane, '_422' image format, all members of dstOffset must be a multiple of the corresponding dimensions of the compressed texel block</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-01732</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageSinglePlane422Alignment, CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage is a compressed format image, or a single-plane, '_422' image format, extent.width must be a multiple of the compressed texel block width or (extent.width + dstOffset.x) must equal the destination image subresource width</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-01733</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage is a compressed format image, or a single-plane, '_422' image format, extent.height must be a multiple of the compressed texel block height or (extent.height + dstOffset.y) must equal the destination image subresource height</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-01734</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage is a compressed format image, or a single-plane, '_422' image format, extent.depth must be a multiple of the compressed texel block depth or (extent.depth + dstOffset.z) must equal the destination image subresource depth</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-01786</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatch</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> If the calling command's dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset.z must be 0 and extent.depth must be 1.</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-01788</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatch</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> If the calling command's dstImage is of type VK_IMAGE_TYPE_2D, then dstOffset.z must be 0.</th></tr>
<tr><th>VUID-VkImageCopy-dstImage-01792</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If the calling command's dstImage is of type VK_IMAGE_TYPE_2D, and the srcImage is of type VK_IMAGE_TYPE_3D, then extent.depth must equal to the layerCount member of dstSubresource.</th></tr>
<tr><th>VUID-VkImageCopy-dstOffset-00150</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageDstSizeExceeded</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and less than or equal to the destination image subresource width</th></tr>
<tr><th>VUID-VkImageCopy-dstOffset-00151</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageDstSizeExceeded, CopyImageTypeExtentMismatch</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and less than or equal to the destination image subresource height</th></tr>
<tr><th>VUID-VkImageCopy-dstOffset-00153</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageDstSizeExceeded, CopyImageTypeExtentMismatch</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and less than or equal to the destination image subresource depth</th></tr>
<tr><th>VUID-VkImageCopy-dstOffset-00162</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage is a compressed format image, all members of dstOffset must be a multiple of the corresponding dimensions of the compressed texel block</th></tr>
<tr><th>VUID-VkImageCopy-dstSubresource-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageCopy</th><th>core</th><th> dstSubresource must be a valid VkImageSubresourceLayers structure</th></tr>
<tr><th>VUID-VkImageCopy-extent-00140</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageLayerCountMismatch</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> The number of slices of the extent (for 3D) or layers of the srcSubresource (for non-3D) must match the number of slices of the extent (for 3D) or layers of the dstSubresource (for non-3D)</th></tr>
<tr><th>VUID-VkImageCopy-extent-00158</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage is a compressed image, extent.width must be a multiple of the compressed texel block width or (extent.width + srcOffset.x) must equal the source image subresource width</th></tr>
<tr><th>VUID-VkImageCopy-extent-00159</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage is a compressed image, extent.height must be a multiple of the compressed texel block height or (extent.height + srcOffset.y) must equal the source image subresource height</th></tr>
<tr><th>VUID-VkImageCopy-extent-00160</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage is a compressed image, extent.depth must be a multiple of the compressed texel block depth or (extent.depth + srcOffset.z) must equal the source image subresource depth</th></tr>
<tr><th>VUID-VkImageCopy-extent-00163</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage is a compressed format image, extent.width must be a multiple of the compressed texel block width or (extent.width + dstOffset.x) must equal the destination image subresource width</th></tr>
<tr><th>VUID-VkImageCopy-extent-00164</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage is a compressed format image, extent.height must be a multiple of the compressed texel block height or (extent.height + dstOffset.y) must equal the destination image subresource height</th></tr>
<tr><th>VUID-VkImageCopy-extent-00165</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's dstImage is a compressed format image, extent.depth must be a multiple of the compressed texel block depth or (extent.depth + dstOffset.z) must equal the destination image subresource depth</th></tr>
<tr><th>VUID-VkImageCopy-layerCount-00138</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> The layerCount member of srcSubresource and dstSubresource must match</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-00139</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If either of the calling command's srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of both srcSubresource and dstSubresource must be 0 and 1, respectively</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-00141</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatch</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If either of the calling command's srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of the corresponding subresource must be 0 and 1, respectively</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-00146</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatch</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> If the calling command's srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset.y must be 0 and extent.height must be 1.</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01551</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageAspectMismatch</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If neither the calling command's srcImage nor the calling command's dstImage has a multi-planar image format then the aspectMask member of srcSubresource and dstSubresource must match</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01552</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageMultiplaneAspectBits</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage has a VkFormat with two planes then the srcSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01553</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageMultiplaneAspectBits</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage has a VkFormat with three planes then the srcSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01556</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageMultiplaneAspectBits</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage has a multi-planar image format and the dstImage does not have a multi-planar image format, the dstSubresource aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01727</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageSinglePlane422Alignment, CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage is a compressed image, or a single-plane, '_422' image format, all members of srcOffset must be a multiple of the corresponding dimensions of the compressed texel block</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01728</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageSinglePlane422Alignment, CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage is a compressed image, or a single-plane, '_422' image format, extent.width must be a multiple of the compressed texel block width or (extent.width + srcOffset.x) must equal the source image subresource width</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01729</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage is a compressed image, or a single-plane, '_422' image format, extent.height must be a multiple of the compressed texel block height or (extent.height + srcOffset.y) must equal the source image subresource height</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01730</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage is a compressed image, or a single-plane, '_422' image format, extent.depth must be a multiple of the compressed texel block depth or (extent.depth + srcOffset.z) must equal the source image subresource depth</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01785</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatch</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> If the calling command's srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset.z must be 0 and extent.depth must be 1.</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01787</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatch</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> If the calling command's srcImage is of type VK_IMAGE_TYPE_2D, then srcOffset.z must be 0.</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01789</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If the calling command's srcImage or dstImage is of type VK_IMAGE_TYPE_2D, then extent.depth must be 1.</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01790</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If both srcImage and dstImage are of type VK_IMAGE_TYPE_2D then extent.depth must be 1.</th></tr>
<tr><th>VUID-VkImageCopy-srcImage-01791</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCopy</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If the calling command's srcImage is of type VK_IMAGE_TYPE_2D, and the dstImage is of type VK_IMAGE_TYPE_3D, then extent.depth must equal to the layerCount member of srcSubresource.</th></tr>
<tr><th>VUID-VkImageCopy-srcOffset-00144</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageSrcSizeExceeded</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and less than or equal to the source image subresource width</th></tr>
<tr><th>VUID-VkImageCopy-srcOffset-00145</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatch, CopyImageSrcSizeExceeded</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and less than or equal to the source image subresource height</th></tr>
<tr><th>VUID-VkImageCopy-srcOffset-00147</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatch, CopyImageSrcSizeExceeded</th><th>explicit</th><th>VkImageCopy</th><th>core</th><th> srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and less than or equal to the source image subresource depth</th></tr>
<tr><th>VUID-VkImageCopy-srcOffset-00157</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageCompressedBlockAlignment</th><th>explicit</th><th>VkImageCopy</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the calling command's srcImage is a compressed image, all members of srcOffset must be a multiple of the corresponding dimensions of the compressed texel block</th></tr>
<tr><th>VUID-VkImageCopy-srcSubresource-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageCopy</th><th>core</th><th> srcSubresource must be a valid VkImageSubresourceLayers structure</th></tr>
<tr><th>VUID-VkImageCreateInfo-Format-02536</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_separate_stencil_usage)</th><th> If Format is a depth-stencil format and the pNext chain contains an instance of VkImageStencilUsageCreateInfoEXT with its stencilUsage member including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth</th></tr>
<tr><th>VUID-VkImageCreateInfo-None-01891</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1)</th><th> If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, VK_IMAGE_CREATE_PROTECTED_BIT must not also be set.</th></tr>
<tr><th>VUID-VkImageCreateInfo-None-01925</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT must not also be set</th></tr>
<tr><th>VUID-VkImageCreateInfo-arrayLayers-00948</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMinLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> arrayLayers must be greater than 0</th></tr>
<tr><th>VUID-VkImageCreateInfo-arrayLayers-02256</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMaxLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> arrayLayers must be less than or equal to imageCreateMaxArrayLayers (as defined in Image Creation Limits).</th></tr>
<tr><th>VUID-VkImageCreateInfo-extent-00944</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMinLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> extent::width must be greater than 0.</th></tr>
<tr><th>VUID-VkImageCreateInfo-extent-00945</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMinLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> extent::height must be greater than 0.</th></tr>
<tr><th>VUID-VkImageCreateInfo-extent-00946</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMinLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> extent::depth must be greater than 0.</th></tr>
<tr><th>VUID-VkImageCreateInfo-extent-02252</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> extent.width must be less than or equal to imageCreateMaxExtent.width (as defined in Image Creation Limits).</th></tr>
<tr><th>VUID-VkImageCreateInfo-extent-02253</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> extent.height must be less than or equal to imageCreateMaxExtent.height (as defined in Image Creation Limits).</th></tr>
<tr><th>VUID-VkImageCreateInfo-extent-02254</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> extent.depth must be less than or equal to imageCreateMaxExtent.depth (as defined in Image Creation Limits).</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-00949</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMiscErrors</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, imageType must be VK_IMAGE_TYPE_2D</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-00950</th><th><span style="color:limegreen;">Y</span></th><th>Bad2DArrayImageType</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If flags contains VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT, imageType must be VK_IMAGE_TYPE_3D</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-00969</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMiscErrors</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If the sparse bindings feature is not enabled, flags must not contain VK_IMAGE_CREATE_SPARSE_BINDING_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-00987</th><th><span style="color:limegreen;">Y</span></th><th>SparseBindingImageBufferCreate</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If flags contains VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, it must also contain VK_IMAGE_CREATE_SPARSE_BINDING_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-01533</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_sample_locations)</th><th> If flags contains VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT format must be a depth or depth/stencil format</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-01572</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then format must be a block-compressed image format, an ETC compressed image format, or an ASTC compressed image format.</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-01573</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then flags must also contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT.</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-01890</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1)</th><th> If the protected memory feature is not enabled, flags must not contain VK_IMAGE_CREATE_PROTECTED_BIT.</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-01924</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If the sparse aliased residency feature is not enabled, flags must not contain VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-02050</th><th><span style="color:limegreen;">Y</span></th><th>CornerSampledImageNV</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_NV_corner_sampled_image)</th><th> If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, imageType must be VK_IMAGE_TYPE_2D or VK_IMAGE_TYPE_3D</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-02051</th><th><span style="color:limegreen;">Y</span></th><th>CornerSampledImageNV</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_NV_corner_sampled_image)</th><th> If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, it must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT and the format must not be a depth/stencil format</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-02052</th><th><span style="color:limegreen;">Y</span></th><th>CornerSampledImageNV</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_NV_corner_sampled_image)</th><th> If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and imageType is VK_IMAGE_TYPE_2D, extent::width and extent::height must be greater than 1</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-02053</th><th><span style="color:limegreen;">Y</span></th><th>CornerSampledImageNV</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_NV_corner_sampled_image)</th><th> If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and imageType is VK_IMAGE_TYPE_3D, extent::width, extent::height, and extent::depth must be greater than 1</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-02259</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If flags contains VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT, then mipLevels must be one, arrayLayers must be one, imageType must be VK_IMAGE_TYPE_2D. and imageCreateMaybeLinear (as defined in Image Creation Limits) must be false.</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-02557</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags contains VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, imageType must be VK_IMAGE_TYPE_2D</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-02565</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, tiling must be VK_IMAGE_TILING_OPTIMAL</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-02566</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, imageType must be VK_IMAGE_TYPE_2D</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-02567</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, flags must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-02568</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, mipLevels must be 1</th></tr>
<tr><th>VUID-VkImageCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> flags must be a valid combination of VkImageCreateFlagBits values</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-00943</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMiscErrors, ImageLayerUnsupportedFormat</th><th>explicit</th><th>VkImageCreateInfo</th><th>!(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> format must not be VK_FORMAT_UNDEFINED</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-01577</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If format is not a multi-planar format, and flags does not include VK_IMAGE_CREATE_ALIAS_BIT, flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-02534</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_separate_stencil_usage)</th><th> If format is a depth-stencil format and the pNext chain contains an instance of VkImageStencilUsageCreateInfoEXT, then its stencilUsage member must only include VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT if usage also includes it</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-02535</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_separate_stencil_usage)</th><th> If format is a depth-stencil format and the pNext chain contains an instance of VkImageStencilUsageCreateInfoEXT, then its stencilUsage member must only include VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT if usage also includes it</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-02537</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_separate_stencil_usage)</th><th> If format is a depth-stencil format and the pNext chain contains an instance of VkImageStencilUsageCreateInfoEXT with its stencilUsage member including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-02538</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_separate_stencil_usage)</th><th> If the multisampled storage images feature is not enabled, format is a depth-stencil format and the pNext chain contains an instance of VkImageStencilUsageCreateInfoEXT with its stencilUsage including VK_IMAGE_USAGE_STORAGE_BIT, samples must be VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-02561</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the image format is one of those listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views, then mipLevels must be 1</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-02562</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the image format is one of those listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views, samples must be VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-02563</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the image format is one of those listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views, imageType must be VK_IMAGE_TYPE_2D</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-02564</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+!(VK_EXT_ycbcr_image_arrays)</th><th> If the image format is one of those listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views, arrayLayers must be 1</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-02653</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageYcbcrArrayLayers</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_EXT_ycbcr_image_arrays)</th><th> If the image format is one of those listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views, and the ycbcrImageArrays feature is not enabled, arrayLayers must be 1</th></tr>
<tr><th>VUID-VkImageCreateInfo-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageCreateFormatFeatures-02260</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If format is a multi-planar format, and if imageCreateFormatFeatures (as defined in Image Creation Limits) does not contain VK_FORMAT_FEATURE_DISJOINT_BIT, then flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT.</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageCreateMaxMipLevels-02251</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> Each of the following values (as described in Image Creation Limits) must not be undefined imageCreateMaxMipLevels, imageCreateMaxArrayLayers, imageCreateMaxExtent, and imageCreateSampleCounts.</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00954</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMinLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If imageType is VK_IMAGE_TYPE_2D and flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, extent.width and extent.height must be equal and arrayLayers must be greater than or equal to 6</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00956</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMinLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If imageType is VK_IMAGE_TYPE_1D, both extent.height and extent.depth must be 1</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00957</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMinLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If imageType is VK_IMAGE_TYPE_2D, extent.depth must be 1</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00961</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMinLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If imageType is VK_IMAGE_TYPE_3D, arrayLayers must be 1.</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00970</th><th><span style="color:limegreen;">Y</span></th><th>SparseResidencyImageCreateUnsupportedTypes</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If imageType is VK_IMAGE_TYPE_1D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00971</th><th><span style="color:limegreen;">Y</span></th><th>SparseResidencyImageCreateUnsupportedTypes</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If the sparse residency for 2D images feature is not enabled, and imageType is VK_IMAGE_TYPE_2D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00972</th><th><span style="color:limegreen;">Y</span></th><th>SparseResidencyImageCreateUnsupportedTypes</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If the sparse residency for 3D images feature is not enabled, and imageType is VK_IMAGE_TYPE_3D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00973</th><th><span style="color:limegreen;">Y</span></th><th>SparseResidencyImageCreateUnsupportedSamples</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If the sparse residency for images with 2 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_2_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00974</th><th><span style="color:limegreen;">Y</span></th><th>SparseResidencyImageCreateUnsupportedSamples</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If the sparse residency for images with 4 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_4_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00975</th><th><span style="color:limegreen;">Y</span></th><th>SparseResidencyImageCreateUnsupportedSamples</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If the sparse residency for images with 8 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_8_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-00976</th><th><span style="color:limegreen;">Y</span></th><th>SparseResidencyImageCreateUnsupportedSamples</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If the sparse residency for images with 16 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_16_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-02082</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_NV_shading_rate_image)</th><th> If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, imageType must be VK_IMAGE_TYPE_2D.</th></tr>
<tr><th>VUID-VkImageCreateInfo-imageType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> imageType must be a valid VkImageType value</th></tr>
<tr><th>VUID-VkImageCreateInfo-initialLayout-00993</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMiscErrors</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED.</th></tr>
<tr><th>VUID-VkImageCreateInfo-initialLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> initialLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-VkImageCreateInfo-mipLevels-00947</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMinLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> mipLevels must be greater than 0</th></tr>
<tr><th>VUID-VkImageCreateInfo-mipLevels-00958</th><th><span style="color:limegreen;">Y</span></th><th>CornerSampledImageNV, CreateImageMaxLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> mipLevels must be less than or equal to the number of levels in the complete mipmap chain based on extent.width, extent.height, and extent.depth.</th></tr>
<tr><th>VUID-VkImageCreateInfo-mipLevels-02255</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMaxLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> mipLevels must be less than or equal to imageCreateMaxMipLevels (as defined in Image Creation Limits).</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-00988</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)+(VK_NV_external_memory)</th><th> If the pNext chain contains an instance of VkExternalMemoryImageCreateInfoNV, it must not contain an instance of VkExternalMemoryImageCreateInfo.</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-00990</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If the pNext chain contains an instance of VkExternalMemoryImageCreateInfo, its handleTypes member must only contain bits that are also in VkExternalImageFormatProperties::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceImageFormatProperties2 with format, imageType, tiling, usage, and flags equal to those in this structure, and with an instance of VkPhysicalDeviceExternalImageFormatInfo in the pNext chain, with a handleType equal to any one of the handle types specified in VkExternalMemoryImageCreateInfo::handleTypes</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-00991</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_NV_external_memory+VK_NV_external_memory_capabilities)</th><th> If the pNext chain contains an instance of VkExternalMemoryImageCreateInfoNV, its handleTypes member must only contain bits that are also in VkExternalImageFormatPropertiesNV::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalImageFormatPropertiesNV with format, imageType, tiling, usage, and flags equal to those in this structure, and with externalHandleType equal to any one of the handle types specified in VkExternalMemoryImageCreateInfoNV::handleTypes</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-01443</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory,VK_NV_external_memory)</th><th>     If the pNext chain includes a ifdef::VK_VERSION_1_1,VK_KHR_external_memory[VkExternalMemoryImageCreateInfo]</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-01974</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferImageCreate</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the pNext chain contains an instance of VkExternalFormatANDROID, and its member externalFormat is non-zero the format must be VK_FORMAT_UNDEFINED.</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-01975</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferImageCreate</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the pNext chain does not contain an instance of VkExternalFormatANDROID, or does and its member externalFormat is 0 the format must not be VK_FORMAT_UNDEFINED.</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-02262</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_image_drm_format_modifier)</th><th> If the pNext chain contains VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT, then tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT.</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-02393</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferImageCreate</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the pNext chain includes a VkExternalMemoryImageCreateInfo structure whose handleTypes member includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, imageType must be VK_IMAGE_TYPE_2D.</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-02394</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferImageCreate</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the pNext chain includes a VkExternalMemoryImageCreateInfo structure whose handleTypes member includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, mipLevels must either be 1 or equal to the number of levels in the complete mipmap chain based on extent.width, extent.height, and extent.depth.</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-02396</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferImageCreate</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, flags must not include VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT.</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-02397</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferImageCreate</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, usage must not include any usages except VK_IMAGE_USAGE_SAMPLED_BIT.</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-02398</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferImageCreate</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, tiling must be VK_IMAGE_TILING_OPTIMAL.</th></tr>
<tr><th>VUID-VkImageCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDedicatedAllocationImageCreateInfoNV, VkExternalFormatANDROID, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfoKHR, VkImageStencilUsageCreateInfoEXT, or VkImageSwapchainCreateInfoKHR</th></tr>
<tr><th>VUID-VkImageCreateInfo-physicalDeviceCount-01421</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If the logical device was created with VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1, flags must not contain VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</th></tr>
<tr><th>VUID-VkImageCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkImageCreateInfo-samples-02083</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_NV_shading_rate_image)</th><th> If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, samples must be VK_SAMPLE_COUNT_1_BIT.</th></tr>
<tr><th>VUID-VkImageCreateInfo-samples-02257</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMiscErrors</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If samples is not VK_SAMPLE_COUNT_1_BIT, then imageType must be VK_IMAGE_TYPE_2D, flags must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, mipLevels must be equal to 1, and imageCreateMaybeLinear (as defined in Image Creation Limits) must be false,</th></tr>
<tr><th>VUID-VkImageCreateInfo-samples-02258</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMaxLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> samples must be a bit value that is set in imageCreateSampleCounts (as defined in Image Creation Limits).</th></tr>
<tr><th>VUID-VkImageCreateInfo-samples-02558</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If samples is not VK_SAMPLE_COUNT_1_BIT, usage must not contain VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT</th></tr>
<tr><th>VUID-VkImageCreateInfo-samples-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> samples must be a valid VkSampleCountFlagBits value</th></tr>
<tr><th>VUID-VkImageCreateInfo-sharingMode-00941</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMiscErrors</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values</th></tr>
<tr><th>VUID-VkImageCreateInfo-sharingMode-00942</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMiscErrors</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1</th></tr>
<tr><th>VUID-VkImageCreateInfo-sharingMode-01392</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>!(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the physicalDevice that was used to create device</th></tr>
<tr><th>VUID-VkImageCreateInfo-sharingMode-01420</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device</th></tr>
<tr><th>VUID-VkImageCreateInfo-sharingMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> sharingMode must be a valid VkSharingMode value</th></tr>
<tr><th>VUID-VkImageCreateInfo-tiling-02084</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_NV_shading_rate_image)</th><th> If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, tiling must be VK_IMAGE_TILING_OPTIMAL.</th></tr>
<tr><th>VUID-VkImageCreateInfo-tiling-02261</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_image_drm_format_modifier)</th><th> If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the pNext chain must contain exactly one of VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT.</th></tr>
<tr><th>VUID-VkImageCreateInfo-tiling-02353</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_image_drm_format_modifier)</th><th> If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and flags contains VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then the pNext chain must contain VkImageFormatListCreateInfoKHR with non-zero viewFormatCount.</th></tr>
<tr><th>VUID-VkImageCreateInfo-tiling-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> tiling must be a valid VkImageTiling value</th></tr>
<tr><th>VUID-VkImageCreateInfo-usage-00963</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMiscErrors</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, then bits other than VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must not be set</th></tr>
<tr><th>VUID-VkImageCreateInfo-usage-00964</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMaxLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth</th></tr>
<tr><th>VUID-VkImageCreateInfo-usage-00965</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMaxLimitsViolation</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight</th></tr>
<tr><th>VUID-VkImageCreateInfo-usage-00966</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageMiscErrors</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, usage must also contain at least one of VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT.</th></tr>
<tr><th>VUID-VkImageCreateInfo-usage-00968</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>core</th><th> If the multisampled storage images feature is not enabled, and usage contains VK_IMAGE_USAGE_STORAGE_BIT, samples must be VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-VkImageCreateInfo-usage-02559</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If usage includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.width must be less than or equal to the ceiling of maxFramebufferWidth/minFragmentDensityTexelSize.width</th></tr>
<tr><th>VUID-VkImageCreateInfo-usage-02560</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If usage includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.height must be less than or equal to the ceiling of maxFramebufferHeight/minFragmentDensityTexelSize.height</th></tr>
<tr><th>VUID-VkImageCreateInfo-usage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> usage must be a valid combination of VkImageUsageFlagBits values</th></tr>
<tr><th>VUID-VkImageCreateInfo-usage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageCreateInfo</th><th>core</th><th> usage must not be 0</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-arrayPitch-02268</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageDrmFormatModifierExplicitCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> For each element of pPlaneLayouts, arrayPitch must be 0 if VkImageCreateInfo::arrayLayers is 1.</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-depthPitch-02269</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageDrmFormatModifierExplicitCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> For each element of pPlaneLayouts, depthPitch must be 0 if VkImageCreateInfo::extent::depth is 1.</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-drmFormatModifier-02264</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageDrmFormatModifierExplicitCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> drmFormatModifier must be compatible with the parameters in VkImageCreateInfo and its pNext chain, as determined by querying VkPhysicalDeviceImageFormatInfo2KHR extended with VkPhysicalDeviceImageDrmFormatModifierInfoEXT.</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-drmFormatModifierPlaneCount-02265</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageDrmFormatModifierExplicitCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> drmFormatModifierPlaneCount must be equal to the VkDrmFormatModifierPropertiesEXT::drmFormatModifierPlaneCount associated with VkImageCreateInfo::format and drmFormatModifier, as found by querying VkDrmFormatModifierPropertiesListEXT.</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-pPlaneLayouts-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageDrmFormatModifierExplicitCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> If drmFormatModifierPlaneCount is not 0, pPlaneLayouts must be a valid pointer to an array of drmFormatModifierPlaneCount VkSubresourceLayout structures</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageDrmFormatModifierExplicitCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-size-02267</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageDrmFormatModifierExplicitCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> For each element of pPlaneLayouts, size must be 0</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierListCreateInfoEXT-drmFormatModifierCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageDrmFormatModifierListCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> drmFormatModifierCount must be greater than 0</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierListCreateInfoEXT-pDrmFormatModifiers-02263</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageDrmFormatModifierListCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> Each modifier in pDrmFormatModifiers must be compatible with the parameters in VkImageCreateInfo and its pNext chain, as determined by querying VkPhysicalDeviceImageFormatInfo2 extended with VkPhysicalDeviceImageDrmFormatModifierInfoEXT.</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierListCreateInfoEXT-pDrmFormatModifiers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageDrmFormatModifierListCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> pDrmFormatModifiers must be a valid pointer to an array of drmFormatModifierCount uint64_t values</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierListCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageDrmFormatModifierListCreateInfoEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierPropertiesEXT-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageDrmFormatModifierPropertiesEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkImageDrmFormatModifierPropertiesEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageDrmFormatModifierPropertiesEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkImageFormatListCreateInfoKHR-flags-01579</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageFormatListCreateInfoKHR</th><th>(VK_KHR_image_format_list)</th><th> If VkImageCreateInfo::flags does not contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, viewFormatCount must be 0 or 1.</th></tr>
<tr><th>VUID-VkImageFormatListCreateInfoKHR-pViewFormats-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageFormatListCreateInfoKHR</th><th>(VK_KHR_image_format_list)</th><th> If viewFormatCount is not 0, pViewFormats must be a valid pointer to an array of viewFormatCount valid VkFormat values</th></tr>
<tr><th>VUID-VkImageFormatListCreateInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageFormatListCreateInfoKHR</th><th>(VK_KHR_image_format_list)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkImageFormatListCreateInfoKHR-viewFormatCount-01578</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageFormatListCreateInfoKHR</th><th>(VK_KHR_image_format_list)</th><th> If viewFormatCount is not 0, all of the formats in the pViewFormats array must be compatible with the format specified in the format field of VkImageCreateInfo, as described in the compatibility table.</th></tr>
<tr><th>VUID-VkImageFormatListCreateInfoKHR-viewFormatCount-01580</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageFormatListCreateInfoKHR</th><th>(VK_KHR_image_format_list)</th><th> If viewFormatCount is not 0, VkImageCreateInfo::format must be in pViewFormats.</th></tr>
<tr><th>VUID-VkImageFormatProperties2-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAndroidHardwareBufferUsageANDROID, VkExternalImageFormatProperties, VkFilterCubicImageViewImageFormatPropertiesEXT, VkSamplerYcbcrConversionImageFormatProperties, or VkTextureLODGatherFormatPropertiesAMD</th></tr>
<tr><th>VUID-VkImageFormatProperties2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2</th></tr>
<tr><th>VUID-VkImageFormatProperties2-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-dstAccessMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> dstAccessMask must be a valid combination of VkAccessFlagBits values</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01199</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamily</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>!(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, srcQueueFamilyIndex and dstQueueFamilyIndex must both be VK_QUEUE_FAMILY_IGNORED</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01200</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamily</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>!(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, srcQueueFamilyIndex and dstQueueFamilyIndex must either both be VK_QUEUE_FAMILY_IGNORED, or both be a valid queue family (see Queue Family Properties).</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01201</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamilyWithMemExt</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, dstQueueFamilyIndex must also be VK_QUEUE_FAMILY_IGNORED.</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01205</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamily</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not VK_QUEUE_FAMILY_IGNORED, at least one of them must be the same as the family of the queue that will execute this barrier</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01207</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If image has a depth/stencil format with both depth and stencil components, then the aspectMask member of subresourceRange must include both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01381</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamilyWithMemExt</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, at least one of srcQueueFamilyIndex and dstQueueFamilyIndex must be VK_QUEUE_FAMILY_IGNORED</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01671</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image has a single-plane color format or is not disjoint, then the aspectMask member of subresourceRange must be VK_IMAGE_ASPECT_COLOR_BIT</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01672</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image has a multi-planar format and the image is disjoint, then the aspectMask member of subresourceRange must include either at least one of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, and VK_IMAGE_ASPECT_PLANE_2_BIT; or must include VK_IMAGE_ASPECT_COLOR_BIT</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01673</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image has a multi-planar format with only two planes, then the aspectMask member of subresourceRange must not include VK_IMAGE_ASPECT_PLANE_2_BIT</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01766</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamilyWithMemExt</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, and one of srcQueueFamilyIndex and dstQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, the other must be VK_QUEUE_FAMILY_IGNORED or a special queue family reserved for external memory transfers, as described in Queue Family Ownership Transfer.</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01767</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamilyWithMemExt</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in Queue Family Ownership Transfer.</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01768</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarrierQueueFamilyWithMemExt</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_external_memory)</th><th> If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and dstQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in Queue Family Ownership Transfer.</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-01932</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-newLayout-01198</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> newLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-newLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> newLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-01197</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageLayout, InvalidBarriers</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> oldLayout must be VK_IMAGE_LAYOUT_UNDEFINED or the current layout of the image subresources affected by the barrier</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-01208</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If either oldLayout or newLayout is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-01209</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-01210</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageLayout, InvalidBarriers</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-01211</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If either oldLayout or newLayout is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-01212</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If either oldLayout or newLayout is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then image must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT set</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-01213</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If either oldLayout or newLayout is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT set</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-01658</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-01659</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-02088</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>(VK_NV_shading_rate_image)</th><th> If either oldLayout or newLayout is VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV then image must have been created with VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV set</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-oldLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> oldLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkSampleLocationsInfoEXT</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-srcAccessMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> srcAccessMask must be a valid combination of VkAccessFlagBits values</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-subresourceRange-01486</th><th><span style="color:limegreen;">Y</span></th><th>ImageBarrierWithBadRange</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> subresourceRange.baseMipLevel must be less than the mipLevels specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-subresourceRange-01488</th><th><span style="color:limegreen;">Y</span></th><th>ImageBarrierWithBadRange</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> subresourceRange.baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-subresourceRange-01724</th><th><span style="color:limegreen;">Y</span></th><th>ImageBarrierWithBadRange</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If subresourceRange.levelCount is not VK_REMAINING_MIP_LEVELS, subresourceRange.baseMipLevel + subresourceRange.levelCount must be less than or equal to the mipLevels specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-subresourceRange-01725</th><th><span style="color:limegreen;">Y</span></th><th>ImageBarrierWithBadRange</th><th>explicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageMemoryBarrier-subresourceRange-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageMemoryBarrier</th><th>core</th><th> subresourceRange must be a valid VkImageSubresourceRange structure</th></tr>
<tr><th>VUID-VkImageMemoryRequirementsInfo2-image-01589</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image was created with a multi-planar format and the VK_IMAGE_CREATE_DISJOINT_BIT flag, there must be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure</th></tr>
<tr><th>VUID-VkImageMemoryRequirementsInfo2-image-01590</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image was not created with the VK_IMAGE_CREATE_DISJOINT_BIT flag, there must not be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure</th></tr>
<tr><th>VUID-VkImageMemoryRequirementsInfo2-image-01591</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+!(VK_EXT_image_drm_format_modifier)</th><th> If image was created with a single-plane format, there must not be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure</th></tr>
<tr><th>VUID-VkImageMemoryRequirementsInfo2-image-01897</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferFetchUnboundImageInfo</th><th>explicit</th><th>VkImageMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If image was created with the VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then image must be bound to memory.</th></tr>
<tr><th>VUID-VkImageMemoryRequirementsInfo2-image-02279</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_EXT_image_drm_format_modifier)</th><th> If image was created with VK_IMAGE_CREATE_DISJOINT_BIT and with VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then there must be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure</th></tr>
<tr><th>VUID-VkImageMemoryRequirementsInfo2-image-02280</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_EXT_image_drm_format_modifier)</th><th> If image was created with a single-plane format and with any tiling other than VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then there must not be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure</th></tr>
<tr><th>VUID-VkImageMemoryRequirementsInfo2-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-VkImageMemoryRequirementsInfo2-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pNext must be NULL or a pointer to a valid instance of VkImagePlaneMemoryRequirementsInfo</th></tr>
<tr><th>VUID-VkImageMemoryRequirementsInfo2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2</th></tr>
<tr><th>VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImagePipeSurfaceCreateInfoFUCHSIA</th><th>(VK_KHR_surface)+(VK_FUCHSIA_imagepipe_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-imagePipeHandle-00000</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImagePipeSurfaceCreateInfoFUCHSIA</th><th>(VK_KHR_surface)+(VK_FUCHSIA_imagepipe_surface)</th><th> imagePipeHandle must be a valid zx_handle_t</th></tr>
<tr><th>VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImagePipeSurfaceCreateInfoFUCHSIA</th><th>(VK_KHR_surface)+(VK_FUCHSIA_imagepipe_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImagePipeSurfaceCreateInfoFUCHSIA</th><th>(VK_KHR_surface)+(VK_FUCHSIA_imagepipe_surface)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA</th></tr>
<tr><th>VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-02281</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImagePlaneMemoryRequirementsInfo</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the image's tiling is VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, then planeAspect must be a single valid format plane for the image. (That is, for a two-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT, and for a three-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT).</th></tr>
<tr><th>VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-02282</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImagePlaneMemoryRequirementsInfo</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_EXT_image_drm_format_modifier)</th><th>  If the image's tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,  then planeAspect must be a single valid memory plane for the  image.  (That is, aspectMask must specify a plane index that is less than  the  drmFormatModifierPlaneCount  associated with the image's format and drmFormatModifier.)</th></tr>
<tr><th>VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImagePlaneMemoryRequirementsInfo</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> planeAspect must be a valid VkImageAspectFlagBits value</th></tr>
<tr><th>VUID-VkImagePlaneMemoryRequirementsInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImagePlaneMemoryRequirementsInfo</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO</th></tr>
<tr><th>VUID-VkImageResolve-aspectMask-00266</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> The aspectMask member of srcSubresource and dstSubresource must only contain VK_IMAGE_ASPECT_COLOR_BIT</th></tr>
<tr><th>VUID-VkImageResolve-dstImage-00276</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> If the calling command's dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset.y must be 0 and extent.height must be 1.</th></tr>
<tr><th>VUID-VkImageResolve-dstImage-00278</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> If the calling command's dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then dstOffset.z must be 0 and extent.depth must be 1.</th></tr>
<tr><th>VUID-VkImageResolve-dstOffset-00274</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and less than or equal to the destination image subresource width</th></tr>
<tr><th>VUID-VkImageResolve-dstOffset-00275</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and less than or equal to the destination image subresource height</th></tr>
<tr><th>VUID-VkImageResolve-dstOffset-00277</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and less than or equal to the destination image subresource depth</th></tr>
<tr><th>VUID-VkImageResolve-dstSubresource-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageResolve</th><th>core</th><th> dstSubresource must be a valid VkImageSubresourceLayers structure</th></tr>
<tr><th>VUID-VkImageResolve-layerCount-00267</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> The layerCount member of srcSubresource and dstSubresource must match</th></tr>
<tr><th>VUID-VkImageResolve-srcImage-00268</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> If either of the calling command's srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of both srcSubresource and dstSubresource must be 0 and 1, respectively</th></tr>
<tr><th>VUID-VkImageResolve-srcImage-00271</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> If the calling command's srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset.y must be 0 and extent.height must be 1.</th></tr>
<tr><th>VUID-VkImageResolve-srcImage-00273</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> If the calling command's srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then srcOffset.z must be 0 and extent.depth must be 1.</th></tr>
<tr><th>VUID-VkImageResolve-srcOffset-00269</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and less than or equal to the source image subresource width</th></tr>
<tr><th>VUID-VkImageResolve-srcOffset-00270</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and less than or equal to the source image subresource height</th></tr>
<tr><th>VUID-VkImageResolve-srcOffset-00272</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageResolve</th><th>core</th><th> srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and less than or equal to the source image subresource depth</th></tr>
<tr><th>VUID-VkImageResolve-srcSubresource-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageResolve</th><th>core</th><th> srcSubresource must be a valid VkImageSubresourceLayers structure</th></tr>
<tr><th>VUID-VkImageSparseMemoryRequirementsInfo2-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageSparseMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-VkImageSparseMemoryRequirementsInfo2-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageSparseMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkImageSparseMemoryRequirementsInfo2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageSparseMemoryRequirementsInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2</th></tr>
<tr><th>VUID-VkImageStencilUsageCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageStencilUsageCreateInfoEXT</th><th>(VK_EXT_separate_stencil_usage)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkImageStencilUsageCreateInfoEXT-stencilUsage-02539</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageStencilUsageCreateInfoEXT</th><th>(VK_EXT_separate_stencil_usage)</th><th> If stencilUsage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, then bits other than VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must not be set</th></tr>
<tr><th>VUID-VkImageStencilUsageCreateInfoEXT-stencilUsage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageStencilUsageCreateInfoEXT</th><th>(VK_EXT_separate_stencil_usage)</th><th> stencilUsage must be a valid combination of VkImageUsageFlagBits values</th></tr>
<tr><th>VUID-VkImageStencilUsageCreateInfoEXT-stencilUsage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageStencilUsageCreateInfoEXT</th><th>(VK_EXT_separate_stencil_usage)</th><th> stencilUsage must not be 0</th></tr>
<tr><th>VUID-VkImageSubresource-aspectMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageViewAspect, ExerciseGetImageSubresourceLayout, InvalidBarriers</th><th>implicit</th><th>VkImageSubresource</th><th>core</th><th> aspectMask must be a valid combination of VkImageAspectFlagBits values</th></tr>
<tr><th>VUID-VkImageSubresource-aspectMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageSubresource</th><th>core</th><th> aspectMask must not be 0</th></tr>
<tr><th>VUID-VkImageSubresourceLayers-aspectMask-00167</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageAspectMismatch</th><th>explicit</th><th>VkImageSubresourceLayers</th><th>core</th><th> If aspectMask contains VK_IMAGE_ASPECT_COLOR_BIT, it must not contain either of VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT</th></tr>
<tr><th>VUID-VkImageSubresourceLayers-aspectMask-00168</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageAspectMismatch</th><th>explicit</th><th>VkImageSubresourceLayers</th><th>core</th><th> aspectMask must not contain VK_IMAGE_ASPECT_METADATA_BIT</th></tr>
<tr><th>VUID-VkImageSubresourceLayers-aspectMask-02247</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageSubresourceLayers</th><th>(VK_EXT_image_drm_format_modifier)</th><th> aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.</th></tr>
<tr><th>VUID-VkImageSubresourceLayers-aspectMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageSubresourceLayers</th><th>core</th><th> aspectMask must be a valid combination of VkImageAspectFlagBits values</th></tr>
<tr><th>VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageSubresourceLayers</th><th>core</th><th> aspectMask must not be 0</th></tr>
<tr><th>VUID-VkImageSubresourceLayers-layerCount-01700</th><th><span style="color:limegreen;">Y</span></th><th>MiscBlitImageTests</th><th>explicit</th><th>VkImageSubresourceLayers</th><th>core</th><th> layerCount must be greater than 0</th></tr>
<tr><th>VUID-VkImageSubresourceRange-aspectMask-01670</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageSubresourceRange</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, then it must not include any of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT</th></tr>
<tr><th>VUID-VkImageSubresourceRange-aspectMask-02278</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageSubresourceRange</th><th>(VK_EXT_image_drm_format_modifier)</th><th> aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.</th></tr>
<tr><th>VUID-VkImageSubresourceRange-aspectMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageSubresourceRange</th><th>core</th><th> aspectMask must be a valid combination of VkImageAspectFlagBits values</th></tr>
<tr><th>VUID-VkImageSubresourceRange-aspectMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageSubresourceRange</th><th>core</th><th> aspectMask must not be 0</th></tr>
<tr><th>VUID-VkImageSubresourceRange-layerCount-01721</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageSubresourceRange</th><th>core</th><th> If layerCount is not VK_REMAINING_ARRAY_LAYERS, it must be greater than 0</th></tr>
<tr><th>VUID-VkImageSubresourceRange-levelCount-01720</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageSubresourceRange</th><th>core</th><th> If levelCount is not VK_REMAINING_MIP_LEVELS, it must be greater than 0</th></tr>
<tr><th>VUID-VkImageSwapchainCreateInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageSwapchainCreateInfoKHR</th><th>(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkImageSwapchainCreateInfoKHR-swapchain-00995</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageSwapchainCreateInfoKHR</th><th>(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)</th><th> If swapchain is not VK_NULL_HANDLE, the fields of VkImageCreateInfo must match the implied image creation parameters of the swapchain</th></tr>
<tr><th>VUID-VkImageSwapchainCreateInfoKHR-swapchain-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageSwapchainCreateInfoKHR</th><th>(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)</th><th> If swapchain is not VK_NULL_HANDLE, swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02230</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewASTCDecodeModeEXT</th><th>(VK_EXT_astc_decode_mode)</th><th> decodeMode must be one of VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, or VK_FORMAT_E5B9G9R9_UFLOAT_PACK32</th></tr>
<tr><th>VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02231</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewASTCDecodeModeEXT</th><th>(VK_EXT_astc_decode_mode)</th><th> If the decodeModeSharedExponent feature is not enabled, decodeMode must not be VK_FORMAT_E5B9G9R9_UFLOAT_PACK32</th></tr>
<tr><th>VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02232</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewASTCDecodeModeEXT</th><th>(VK_EXT_astc_decode_mode)</th><th> If decodeMode is VK_FORMAT_R8G8B8A8_UNORM the image view must not include blocks using any of the ASTC HDR modes</th></tr>
<tr><th>VUID-VkImageViewASTCDecodeModeEXT-decodeMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewASTCDecodeModeEXT</th><th>(VK_EXT_astc_decode_mode)</th><th> decodeMode must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkImageViewASTCDecodeModeEXT-format-02233</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewASTCDecodeModeEXT</th><th>(VK_EXT_astc_decode_mode)</th><th> format of the image view must be one of VK_FORMAT_ASTC_4x4_UNORM_BLOCK, VK_FORMAT_ASTC_4x4_SRGB_BLOCK, VK_FORMAT_ASTC_5x4_UNORM_BLOCK, VK_FORMAT_ASTC_5x4_SRGB_BLOCK, VK_FORMAT_ASTC_5x5_UNORM_BLOCK, VK_FORMAT_ASTC_5x5_SRGB_BLOCK, VK_FORMAT_ASTC_6x5_UNORM_BLOCK, VK_FORMAT_ASTC_6x5_SRGB_BLOCK, VK_FORMAT_ASTC_6x6_UNORM_BLOCK, VK_FORMAT_ASTC_6x6_SRGB_BLOCK, VK_FORMAT_ASTC_8x5_UNORM_BLOCK, VK_FORMAT_ASTC_8x5_SRGB_BLOCK, VK_FORMAT_ASTC_8x6_UNORM_BLOCK, VK_FORMAT_ASTC_8x6_SRGB_BLOCK, VK_FORMAT_ASTC_8x8_UNORM_BLOCK, VK_FORMAT_ASTC_8x8_SRGB_BLOCK, VK_FORMAT_ASTC_10x5_UNORM_BLOCK, VK_FORMAT_ASTC_10x5_SRGB_BLOCK, VK_FORMAT_ASTC_10x6_UNORM_BLOCK, VK_FORMAT_ASTC_10x6_SRGB_BLOCK, VK_FORMAT_ASTC_10x8_UNORM_BLOCK, VK_FORMAT_ASTC_10x8_SRGB_BLOCK, VK_FORMAT_ASTC_10x10_UNORM_BLOCK, VK_FORMAT_ASTC_10x10_SRGB_BLOCK, VK_FORMAT_ASTC_12x10_UNORM_BLOCK, VK_FORMAT_ASTC_12x10_SRGB_BLOCK, VK_FORMAT_ASTC_12x12_UNORM_BLOCK, or VK_FORMAT_ASTC_12x12_SRGB_BLOCK</th></tr>
<tr><th>VUID-VkImageViewASTCDecodeModeEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageViewASTCDecodeModeEXT</th><th>(VK_EXT_astc_decode_mode)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-None-02273</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferCreateImageView</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> The format features of the resultant image view must contain at least one bit.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-components-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> components must be a valid VkComponentMapping structure</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-flags-02572</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If dynamic fragment density map feature is not enabled, flags must not contain VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> flags must be a valid combination of VkImageViewCreateFlagBits values</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01003</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV, CreateImageViewBreaksParameterCompatibilityRequirements</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> If image was not created with VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT then viewType must not be VK_IMAGE_VIEW_TYPE_CUBE or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01005</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewBreaksParameterCompatibilityRequirements</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If image was created with VK_IMAGE_TYPE_3D but without VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set then viewType must not be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01007</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>!(VK_EXT_fragment_density_map)+!(VK_NV_shading_rate_image)</th><th> image must have been created with a usage value containing at least one of VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_USAGE_STORAGE_BIT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01018</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewDifferentClass</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, format must be compatible with the format used to create image, as defined in Format Compatibility Classes</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01019</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferCreateImageView, CreateImageViewNoMutableFormatBit</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image was not created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, format must be identical to the format used to create image</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01020</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01482</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If image is not a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or viewType is not VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01484</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If image is a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::baseArrayLayer must be less than the extent.depth specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01583</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with, or must be an uncompressed format that is size-compatible with, the format used to create image.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01584</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, the levelCount and layerCount members of subresourceRange must both be 1.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01586</th><th><span style="color:limegreen;">Y</span></th><th>MultiplaneIncompatibleViewFormat</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, if the format of the image is a multi-planar format, and if subresourceRange.aspectMask is one of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT, then format must be compatible with the VkFormat for the plane of the image format indicated by subresourceRange.aspectMask, as defined in Compatible formats of planes of multi-planar formats</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01759</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)+!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, but without the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with the format used to create image, as defined in Format Compatibility Classes</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01760</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, and if the format of the image is not a multi-planar format, format must be compatible with the format used to create image, as defined in Format Compatibility Classes</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01761</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, but without the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, and if the format of the image is not a multi-planar format, format must be compatible with the format used to create image, as defined in Format Compatibility Classes</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-01762</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If image was not created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, or if the format of the image is a multi-planar format and if subresourceRange.aspectMask is VK_IMAGE_ASPECT_COLOR_BIT, format must be identical to the format used to create image</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-02085</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>!(VK_EXT_fragment_density_map)+(VK_NV_shading_rate_image)</th><th> image must have been created with a usage value containing at least one of VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_USAGE_STORAGE_BIT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-02086</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_NV_shading_rate_image)</th><th> If image was created with usage containing VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, viewType must be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-02087</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_NV_shading_rate_image)</th><th> If image was created with usage containing VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, format must be VK_FORMAT_R8_UINT</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-02399</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferCreateImageView</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If image has an external format, format must be VK_FORMAT_UNDEFINED.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-02400</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferCreateImageView</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If image has an external format, the pNext chain must contain an instance of VkSamplerYcbcrConversionInfo with a conversion object created with the same external format as image.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-02401</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferCreateImageView</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If image has an external format, all members of components must be VK_COMPONENT_SWIZZLE_IDENTITY.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-02569</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_EXT_fragment_density_map)+!(VK_NV_shading_rate_image)</th><th> image must have been created with a usage value containing at least one of VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_USAGE_STORAGE_BIT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-02570</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_EXT_fragment_density_map)+(VK_NV_shading_rate_image)</th><th> image must have been created with a usage value containing at least one of VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_USAGE_STORAGE_BIT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, or VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-02571</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If image was created with usage containing VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, subresourceRange.levelCount must be 1</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-02573</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If dynamic fragment density map feature is not enabled and image was created with usage containing VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, flags must not contain any of VK_IMAGE_CREATE_PROTECTED_BIT, VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-pNext-01585</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_KHR_image_format_list)</th><th> If a VkImageFormatListCreateInfoKHR structure was included in the pNext chain of the VkImageCreateInfo struct used when creating image and the viewFormatCount field of VkImageFormatListCreateInfoKHR is not zero then format must be one of the formats in VkImageFormatListCreateInfoKHR::pViewFormats.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-pNext-01970</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the pNext chain contains an instance of VkSamplerYcbcrConversionInfo with a conversion value other than VK_NULL_HANDLE, all members of components must have the value VK_COMPONENT_SWIZZLE_IDENTITY.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-pNext-02661</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>!(VK_EXT_separate_stencil_usage)</th><th> If the pNext chain includes an instance of VkImageViewUsageCreateInfo, its usage member must not include any bits that were not set in the usage member of the VkImageCreateInfo structure used to create image.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-pNext-02662</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_EXT_separate_stencil_usage)</th><th> If the pNext chain includes an instance of VkImageViewUsageCreateInfo, and image was not created with an instance of VkImageStencilUsageCreateInfoEXT in the pNext chain of VkImageCreateInfo, its usage member must not include any bits that were not set in the usage member of the VkImageCreateInfo structure used to create image</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-pNext-02663</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_EXT_separate_stencil_usage)</th><th> If the pNext chain includes an instance of VkImageViewUsageCreateInfo, image was created with an instance of VkImageStencilUsageCreateInfoEXT in the pNext chain of VkImageCreateInfo, and subResourceRange.aspectMask includes VK_IMAGE_ASPECT_STENCIL_BIT, the usage member of the VkImageViewUsageCreateInfo instance must not include any bits that were not set in the usage member of the VkImageStencilUsageCreateInfoEXT structure used to create image</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-pNext-02664</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_EXT_separate_stencil_usage)</th><th> If the pNext chain includes an instance of VkImageViewUsageCreateInfo, image was created with an instance of VkImageStencilUsageCreateInfoEXT in the pNext chain of VkImageCreateInfo, and subResourceRange.aspectMask includes bits other than VK_IMAGE_ASPECT_STENCIL_BIT, the usage member of the VkImageViewUsageCreateInfo instance must not include any bits that were not set in the usage member of the VkImageCreateInfo structure used to create image</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkImageViewASTCDecodeModeEXT, VkImageViewUsageCreateInfo, or VkSamplerYcbcrConversionInfo</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-subResourceRange-01021</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewBreaksParameterCompatibilityRequirements</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> subresourceRange and viewType must be compatible with the image, as described in the compatibility table</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-subresourceRange-01478</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewInvalidSubresourceRange</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> subresourceRange.baseMipLevel must be less than the mipLevels specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-subresourceRange-01480</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewInvalidSubresourceRange</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> subresourceRange.baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-subresourceRange-01483</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If subresourceRange::layerCount is not VK_REMAINING_ARRAY_LAYERS, image is not a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or viewType is not VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::layerCount must be non-zero and subresourceRange::baseArrayLayer + subresourceRange::layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-subresourceRange-01485</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If subresourceRange::layerCount is not VK_REMAINING_ARRAY_LAYERS, image is a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::layerCount must be non-zero and subresourceRange::baseArrayLayer + subresourceRange::layerCount must be less than or equal to the extent.depth specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-subresourceRange-01718</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewInvalidSubresourceRange</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> If subresourceRange.levelCount is not VK_REMAINING_MIP_LEVELS, subresourceRange.baseMipLevel + subresourceRange.levelCount must be less than or equal to the mipLevels specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-subresourceRange-01719</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewInvalidSubresourceRange</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-subresourceRange-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> subresourceRange must be a valid VkImageSubresourceRange structure</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-usage-02274</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewFormatFeatureMismatch</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> If usage contains VK_IMAGE_USAGE_SAMPLED_BIT, then the format features of the resultant image view must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-usage-02275</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewFormatFeatureMismatch, InvalidImageViewUsageCreateInfo</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> If usage contains VK_IMAGE_USAGE_STORAGE_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-usage-02276</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewFormatFeatureMismatch</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> If usage contains VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-usage-02277</th><th><span style="color:limegreen;">Y</span></th><th>CreateImageViewFormatFeatureMismatch</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> If usage contains VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-usage-02652</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> If usage contains VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, then the image view's format features must contain at least one of VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-viewType-01004</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> If the image cubemap arrays feature is not enabled, viewType must not be VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-VkImageViewCreateInfo-viewType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewCreateInfo</th><th>core</th><th> viewType must be a valid VkImageViewType value</th></tr>
<tr><th>VUID-VkImageViewHandleInfoNVX-commonparent</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageViewHandleInfoNVX</th><th>(VK_NVX_image_view_handle)</th><th> Both of imageView, and sampler that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkImageViewHandleInfoNVX-descriptorType-02654</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewHandleInfoNVX</th><th>(VK_NVX_image_view_handle)</th><th> descriptorType must be VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</th></tr>
<tr><th>VUID-VkImageViewHandleInfoNVX-descriptorType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewHandleInfoNVX</th><th>(VK_NVX_image_view_handle)</th><th> descriptorType must be a valid VkDescriptorType value</th></tr>
<tr><th>VUID-VkImageViewHandleInfoNVX-imageView-02656</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewHandleInfoNVX</th><th>(VK_NVX_image_view_handle)</th><th>    If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the image that    imageView was created from must have been created with the    VK_IMAGE_USAGE_SAMPLED_BIT usage bit set</th></tr>
<tr><th>VUID-VkImageViewHandleInfoNVX-imageView-02657</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewHandleInfoNVX</th><th>(VK_NVX_image_view_handle)</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, the image that imageView was created from must have been created with the VK_IMAGE_USAGE_STORAGE_BIT usage bit set</th></tr>
<tr><th>VUID-VkImageViewHandleInfoNVX-imageView-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageViewHandleInfoNVX</th><th>(VK_NVX_image_view_handle)</th><th> imageView must be a valid VkImageView handle</th></tr>
<tr><th>VUID-VkImageViewHandleInfoNVX-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewHandleInfoNVX</th><th>(VK_NVX_image_view_handle)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkImageViewHandleInfoNVX-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewHandleInfoNVX</th><th>(VK_NVX_image_view_handle)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX</th></tr>
<tr><th>VUID-VkImageViewHandleInfoNVX-sampler-02655</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImageViewHandleInfoNVX</th><th>(VK_NVX_image_view_handle)</th><th> sampler must be a valid VkSampler if descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</th></tr>
<tr><th>VUID-VkImageViewHandleInfoNVX-sampler-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageViewHandleInfoNVX</th><th>(VK_NVX_image_view_handle)</th><th> If sampler is not VK_NULL_HANDLE, sampler must be a valid VkSampler handle</th></tr>
<tr><th>VUID-VkImageViewUsageCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImageViewUsageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO</th></tr>
<tr><th>VUID-VkImageViewUsageCreateInfo-usage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageViewUsageCreateInfo</th><th>implicit</th><th>VkImageViewUsageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> usage must be a valid combination of VkImageUsageFlagBits values</th></tr>
<tr><th>VUID-VkImageViewUsageCreateInfo-usage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImageViewUsageCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> usage must not be 0</th></tr>
<tr><th>VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-01880</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkImportAndroidHardwareBufferInfoANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If buffer is not NULL, Android hardware buffers must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties.</th></tr>
<tr><th>VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-01881</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferImportBuffer</th><th>explicit</th><th>VkImportAndroidHardwareBufferInfoANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If buffer is not NULL, it must be a valid Android hardware buffer object with AHardwareBuffer_Desc::format and AHardwareBuffer_Desc::usage compatible with Vulkan as described in Android Hardware Buffers.</th></tr>
<tr><th>VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportAndroidHardwareBufferInfoANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> buffer must be a valid pointer to a AHardwareBuffer value</th></tr>
<tr><th>VUID-VkImportAndroidHardwareBufferInfoANDROID-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImportAndroidHardwareBufferInfoANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> sType must be VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID</th></tr>
<tr><th>VUID-VkImportFenceFdInfoKHR-fd-01541</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportFenceFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> fd must obey any requirements listed for handleType in external fence handle types compatibility.</th></tr>
<tr><th>VUID-VkImportFenceFdInfoKHR-fence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportFenceFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> fence must be a valid VkFence handle</th></tr>
<tr><th>VUID-VkImportFenceFdInfoKHR-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportFenceFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> flags must be a valid combination of VkFenceImportFlagBits values</th></tr>
<tr><th>VUID-VkImportFenceFdInfoKHR-handleType-01464</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportFenceFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> handleType must be a value included in the Handle Types Supported by VkImportFenceFdInfoKHR table.</th></tr>
<tr><th>VUID-VkImportFenceFdInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportFenceFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> handleType must be a valid VkExternalFenceHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkImportFenceFdInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportFenceFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkImportFenceFdInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportFenceFdInfoKHR</th><th>(VK_KHR_external_fence_fd)</th><th> sType must be VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-fence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> fence must be a valid VkFence handle</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> flags must be a valid combination of VkFenceImportFlagBits values</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-handle-01462</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If handle is not NULL, name must be NULL.</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-handle-01539</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If handle is not NULL, it must obey any requirements listed for handleType in external fence handle types compatibility.</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-handleType-01457</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> handleType must be a value included in the Handle Types Supported by VkImportFenceWin32HandleInfoKHR table.</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-handleType-01459</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If handleType is not VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, name must be NULL.</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-handleType-01460</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If handleType is not 0 and handle is NULL, name must name a valid synchronization primitive of the type specified by handleType.</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-handleType-01461</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType.</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If handleType is not 0, handleType must be a valid VkExternalFenceHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-name-01540</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> If name is not NULL, it must obey any requirements listed for handleType in external fence handle types compatibility.</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkImportFenceWin32HandleInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportFenceWin32HandleInfoKHR</th><th>(VK_KHR_external_fence_win32)</th><th> sType must be VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR</th></tr>
<tr><th>VUID-VkImportMemoryFdInfoKHR-fd-00668</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> The memory from which fd was exported must have been created on the same underlying physical device as device.</th></tr>
<tr><th>VUID-VkImportMemoryFdInfoKHR-fd-01520</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> fd must obey any requirements listed for handleType in external memory handle types compatibility.</th></tr>
<tr><th>VUID-VkImportMemoryFdInfoKHR-fd-01746</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> The memory represented by fd must have been created from a physical device and driver that is compatible with device and handleType, as described in External memory handle types compatibility.</th></tr>
<tr><th>VUID-VkImportMemoryFdInfoKHR-handleType-00667</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties.</th></tr>
<tr><th>VUID-VkImportMemoryFdInfoKHR-handleType-00669</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> If handleType is not 0, it must be defined as a POSIX file descriptor handle.</th></tr>
<tr><th>VUID-VkImportMemoryFdInfoKHR-handleType-00670</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> If handleType is not 0, fd must be a valid handle of the type specified by handleType.</th></tr>
<tr><th>VUID-VkImportMemoryFdInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportMemoryFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkImportMemoryFdInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImportMemoryFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR</th></tr>
<tr><th>VUID-VkImportMemoryHostPointerInfoEXT-handleType-01747</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryHostPointerInfoEXT</th><th>(VK_EXT_external_memory_host)</th><th> If handleType is not 0, it must be supported for import, as reported in VkExternalMemoryPropertiesKHR</th></tr>
<tr><th>VUID-VkImportMemoryHostPointerInfoEXT-handleType-01748</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryHostPointerInfoEXT</th><th>(VK_EXT_external_memory_host)</th><th> If handleType is not 0, it must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT</th></tr>
<tr><th>VUID-VkImportMemoryHostPointerInfoEXT-handleType-01750</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryHostPointerInfoEXT</th><th>(VK_EXT_external_memory_host)</th><th> If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, pHostPointer must be a pointer to allocationSize number of bytes of host memory, where allocationSize is the member of the VkMemoryAllocateInfo structure this structure is chained to</th></tr>
<tr><th>VUID-VkImportMemoryHostPointerInfoEXT-handleType-01751</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryHostPointerInfoEXT</th><th>(VK_EXT_external_memory_host)</th><th> If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT, pHostPointer must be a pointer to allocationSize number of bytes of host mapped foreign memory, where allocationSize is the member of the VkMemoryAllocateInfo structure this structure is chained to</th></tr>
<tr><th>VUID-VkImportMemoryHostPointerInfoEXT-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportMemoryHostPointerInfoEXT</th><th>(VK_EXT_external_memory_host)</th><th> handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkImportMemoryHostPointerInfoEXT-pHostPointer-01749</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryHostPointerInfoEXT</th><th>(VK_EXT_external_memory_host)</th><th> pHostPointer must be a pointer aligned to an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment</th></tr>
<tr><th>VUID-VkImportMemoryHostPointerInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImportMemoryHostPointerInfoEXT</th><th>(VK_EXT_external_memory_host)</th><th> sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-handle-00659</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> The memory from which handle was exported, or the memory named by name must have been created on the same underlying physical device as device.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-handle-01441</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> if handle is not NULL, name must be NULL.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-handle-01518</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If handle is not NULL, it must obey any requirements listed for handleType in external memory handle types compatibility.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00658</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00660</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If handleType is not 0, it must be defined as an NT handle or a global share handle.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00661</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-handleType-01439</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If handleType is not VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, name must be NULL.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-handleType-01440</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If handleType is not 0 and handle is NULL, name must name a valid memory resource of the type specified by handleType.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-name-01519</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If name is not NULL, it must obey any requirements listed for handleType in external memory handle types compatibility.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImportMemoryWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoNV-handle-01328</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoNV</th><th>(VK_NV_external_memory_win32)</th><th> handle must be a valid handle to memory, obtained as specified by handleType.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoNV-handleType-01327</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportMemoryWin32HandleInfoNV</th><th>(VK_NV_external_memory_win32)</th><th> handleType must not have more than one bit set.</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoNV-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportMemoryWin32HandleInfoNV</th><th>(VK_NV_external_memory_win32)</th><th> handleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values</th></tr>
<tr><th>VUID-VkImportMemoryWin32HandleInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkImportMemoryWin32HandleInfoNV</th><th>(VK_NV_external_memory_win32)</th><th> sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV</th></tr>
<tr><th>VUID-VkImportSemaphoreFdInfoKHR-fd-01544</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportSemaphoreFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> fd must obey any requirements listed for handleType in external semaphore handle types compatibility.</th></tr>
<tr><th>VUID-VkImportSemaphoreFdInfoKHR-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportSemaphoreFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> flags must be a valid combination of VkSemaphoreImportFlagBits values</th></tr>
<tr><th>VUID-VkImportSemaphoreFdInfoKHR-handleType-01143</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportSemaphoreFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> handleType must be a value included in the Handle Types Supported by VkImportSemaphoreFdInfoKHR table.</th></tr>
<tr><th>VUID-VkImportSemaphoreFdInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportSemaphoreFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkImportSemaphoreFdInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportSemaphoreFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkImportSemaphoreFdInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportSemaphoreFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR</th></tr>
<tr><th>VUID-VkImportSemaphoreFdInfoKHR-semaphore-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportSemaphoreFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> semaphore must be a valid VkSemaphore handle</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> flags must be a valid combination of VkSemaphoreImportFlagBits values</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-handle-01469</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If handle is not NULL, name must be NULL.</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-handle-01542</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If handle is not NULL, it must obey any requirements listed for handleType in external semaphore handle types compatibility.</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01140</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> handleType must be a value included in the Handle Types Supported by VkImportSemaphoreWin32HandleInfoKHR table.</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01466</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If handleType is not VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, name must be NULL.</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01467</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If handleType is not 0 and handle is NULL, name must name a valid synchronization primitive of the type specified by handleType.</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01468</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType.</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If handleType is not 0, handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-name-01543</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If name is not NULL, it must obey any requirements listed for handleType in external semaphore handle types compatibility.</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR</th></tr>
<tr><th>VUID-VkImportSemaphoreWin32HandleInfoKHR-semaphore-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkImportSemaphoreWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> semaphore must be a valid VkSemaphore handle</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-computeBindingPointSupport-01348</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If the VkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupport feature is not enabled, then pipelineBindPoint must not be VK_PIPELINE_BIND_POINT_COMPUTE</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-flags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must be a valid combination of VkIndirectCommandsLayoutUsageFlagBitsNVX values</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-flags-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must not be 0</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-pTokens-01349</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If pTokens contains an entry of VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX it must be the first element of the array and there must be only a single element of such token type.</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-pTokens-01350</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> All state binding tokens in pTokens must occur prior work provoking tokens (VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX).</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-pTokens-01351</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The content of pTokens must include one single work provoking token that is compatible with the pipelineBindPoint.</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-pTokens-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pTokens must be a valid pointer to an array of tokenCount valid VkIndirectCommandsLayoutTokenNVX structures</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-pipelineBindPoint-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pipelineBindPoint must be a valid VkPipelineBindPoint value</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> sType must be VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-tokenCount-01347</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> tokenCount must be greater than 0 and below VkDeviceGeneratedCommandsLimitsNVX::maxIndirectCommandsLayoutTokenCount</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutCreateInfoNVX-tokenCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIndirectCommandsLayoutCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> tokenCount must be greater than 0</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutTokenNVX-bindingUnit-01342</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIndirectCommandsLayoutTokenNVX</th><th>(VK_NVX_device_generated_commands)</th><th> bindingUnit must stay within device supported limits for the appropriate commands.</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutTokenNVX-divisor-01344</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIndirectCommandsLayoutTokenNVX</th><th>(VK_NVX_device_generated_commands)</th><th> divisor must be greater than 0 and a power of two.</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutTokenNVX-dynamicCount-01343</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIndirectCommandsLayoutTokenNVX</th><th>(VK_NVX_device_generated_commands)</th><th> dynamicCount must stay within device supported limits for the appropriate commands.</th></tr>
<tr><th>VUID-VkIndirectCommandsLayoutTokenNVX-tokenType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIndirectCommandsLayoutTokenNVX</th><th>(VK_NVX_device_generated_commands)</th><th> tokenType must be a valid VkIndirectCommandsTokenTypeNVX value</th></tr>
<tr><th>VUID-VkIndirectCommandsTokenNVX-buffer-01345</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIndirectCommandsTokenNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The buffer's usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set.</th></tr>
<tr><th>VUID-VkIndirectCommandsTokenNVX-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIndirectCommandsTokenNVX</th><th>(VK_NVX_device_generated_commands)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkIndirectCommandsTokenNVX-offset-01346</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkIndirectCommandsTokenNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The offset must be aligned to VkDeviceGeneratedCommandsLimitsNVX::minCommandsTokenBufferOffsetAlignment.</th></tr>
<tr><th>VUID-VkIndirectCommandsTokenNVX-tokenType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkIndirectCommandsTokenNVX</th><th>(VK_NVX_device_generated_commands)</th><th> tokenType must be a valid VkIndirectCommandsTokenTypeNVX value</th></tr>
<tr><th>VUID-VkInputAttachmentAspectReference-aspectMask-01964</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidInputAttachmentReferences</th><th>explicit</th><th>VkInputAttachmentAspectReference</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT</th></tr>
<tr><th>VUID-VkInputAttachmentAspectReference-aspectMask-02250</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkInputAttachmentAspectReference</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)+(VK_EXT_image_drm_format_modifier)</th><th> aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.</th></tr>
<tr><th>VUID-VkInputAttachmentAspectReference-aspectMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkInputAttachmentAspectReference</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> aspectMask must be a valid combination of VkImageAspectFlagBits values</th></tr>
<tr><th>VUID-VkInputAttachmentAspectReference-aspectMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkInputAttachmentAspectReference</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> aspectMask must not be 0</th></tr>
<tr><th>VUID-VkInstanceCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkInstanceCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkInstanceCreateInfo-pApplicationInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkInstanceCreateInfo</th><th>core</th><th> If pApplicationInfo is not NULL, pApplicationInfo must be a valid pointer to a valid VkApplicationInfo structure</th></tr>
<tr><th>VUID-VkInstanceCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkInstanceCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDebugReportCallbackCreateInfoEXT, VkDebugUtilsMessengerCreateInfoEXT, VkValidationFeaturesEXT, or VkValidationFlagsEXT</th></tr>
<tr><th>VUID-VkInstanceCreateInfo-ppEnabledExtensionNames-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkInstanceCreateInfo</th><th>core</th><th> If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings</th></tr>
<tr><th>VUID-VkInstanceCreateInfo-ppEnabledLayerNames-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkInstanceCreateInfo</th><th>core</th><th> If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings</th></tr>
<tr><th>VUID-VkInstanceCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkInstanceCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</th></tr>
<tr><th>VUID-VkInstanceCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkInstanceCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkMacOSSurfaceCreateInfoMVK-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMacOSSurfaceCreateInfoMVK</th><th>(VK_KHR_surface)+(VK_MVK_macos_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkMacOSSurfaceCreateInfoMVK-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMacOSSurfaceCreateInfoMVK</th><th>(VK_KHR_surface)+(VK_MVK_macos_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMacOSSurfaceCreateInfoMVK-pView-01317</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMacOSSurfaceCreateInfoMVK</th><th>(VK_KHR_surface)+(VK_MVK_macos_surface)</th><th> pView must be a valid NSView and must be backed by a CALayer instance of type CAMetalLayer.</th></tr>
<tr><th>VUID-VkMacOSSurfaceCreateInfoMVK-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMacOSSurfaceCreateInfoMVK</th><th>(VK_KHR_surface)+(VK_MVK_macos_surface)</th><th> sType must be VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK</th></tr>
<tr><th>VUID-VkMappedMemoryRange-memory-00684</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMappedMemoryRange</th><th>core</th><th> memory must be currently host mapped</th></tr>
<tr><th>VUID-VkMappedMemoryRange-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMappedMemoryRange</th><th>core</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-VkMappedMemoryRange-offset-00687</th><th><span style="color:limegreen;">Y</span></th><th>InvalidMemoryMapping</th><th>explicit</th><th>VkMappedMemoryRange</th><th>core</th><th> offset must be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize</th></tr>
<tr><th>VUID-VkMappedMemoryRange-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMappedMemoryRange</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMappedMemoryRange-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMappedMemoryRange</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE</th></tr>
<tr><th>VUID-VkMappedMemoryRange-size-00685</th><th><span style="color:limegreen;">Y</span></th><th>InvalidMemoryMapping</th><th>explicit</th><th>VkMappedMemoryRange</th><th>core</th><th> If size is not equal to VK_WHOLE_SIZE, offset and size must specify a range contained within the currently mapped range of memory</th></tr>
<tr><th>VUID-VkMappedMemoryRange-size-00686</th><th><span style="color:limegreen;">Y</span></th><th>InvalidMemoryMapping</th><th>explicit</th><th>VkMappedMemoryRange</th><th>core</th><th> If size is equal to VK_WHOLE_SIZE, offset must be within the currently mapped range of memory</th></tr>
<tr><th>VUID-VkMappedMemoryRange-size-01389</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMappedMemoryRange</th><th>core</th><th> If size is equal to VK_WHOLE_SIZE, the end of the current mapping of memory must be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize bytes from the beginning of the memory object.</th></tr>
<tr><th>VUID-VkMappedMemoryRange-size-01390</th><th><span style="color:limegreen;">Y</span></th><th>InvalidMemoryMapping</th><th>explicit</th><th>VkMappedMemoryRange</th><th>core</th><th> If size is not equal to VK_WHOLE_SIZE, size must either be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize, or offset plus size must equal the size of memory.</th></tr>
<tr><th>VUID-VkMemoryAllocateFlagsInfo-deviceMask-00675</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkMemoryAllocateFlagsInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set, deviceMask must be a valid device mask.</th></tr>
<tr><th>VUID-VkMemoryAllocateFlagsInfo-deviceMask-00676</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>VkMemoryAllocateFlagsInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set, deviceMask must not be zero</th></tr>
<tr><th>VUID-VkMemoryAllocateFlagsInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryAllocateFlagsInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> flags must be a valid combination of VkMemoryAllocateFlagBits values</th></tr>
<tr><th>VUID-VkMemoryAllocateFlagsInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryAllocateFlagsInfo</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-None-00643</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory+VK_KHR_device_group)</th><th> If the parameters define an import operation and the external handle specified was created by the Vulkan API, the device mask specified by VkMemoryAllocateFlagsInfo must match that specified when the memory object being imported was allocated.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-None-00644</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory+VK_KHR_device_group)</th><th> If the parameters define an import operation and the external handle specified was created by the Vulkan API, the list of physical devices that comprise the logical device passed to vkAllocateMemory must match the list of physical devices that comprise the logical device on which the memory was originally allocated.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-allocationSize-00638</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>!(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> allocationSize must be greater than 0</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-allocationSize-00646</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory_win32)</th><th> If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, allocationSize must match the size reported in the memory requirements of the image or buffer member of the instance of VkDedicatedAllocationMemoryAllocateInfoNV included in the pNext chain.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-allocationSize-00647</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory_win32)</th><th> If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, allocationSize must match the size specified when creating the Direct3D 12 heap from which the external handle was extracted.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-allocationSize-01742</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory_fd)</th><th> If the parameters define an import operation, the external handle specified was created by the Vulkan API, and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR, then the values of allocationSize and memoryTypeIndex must match those specified when the memory object being imported was created.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-allocationSize-01743</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory_win32)</th><th> If the parameters define an import operation, the external handle was created by the Vulkan API, and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR or VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR, then the values of allocationSize and memoryTypeIndex must match those specified when the memory object being imported was created.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-allocationSize-01745</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_EXT_external_memory_host)</th><th> If the parameters define an import operation and the external handle is a host pointer, allocationSize must be an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-allocationSize-02383</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferMemoryAllocation</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, allocationSize must be the size returned by vkGetAndroidHardwareBufferPropertiesANDROID for the Android hardware buffer.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-memoryTypeIndex-00645</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory_win32)</th><th> If the parameters define an import operation and the external handle is an NT handle or a global share handle created outside of the Vulkan API, the value of memoryTypeIndex must be one of those returned by vkGetMemoryWin32HandlePropertiesKHR.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-memoryTypeIndex-00648</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory_fd)</th><th> If the parameters define an import operation and the external handle is a POSIX file descriptor created outside of the Vulkan API, the value of memoryTypeIndex must be one of those returned by vkGetMemoryFdPropertiesKHR.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-memoryTypeIndex-01744</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_EXT_external_memory_host)</th><th> If the parameters define an import operation and the external handle is a host pointer, the value of memoryTypeIndex must be one of those returned by vkGetMemoryHostPointerPropertiesEXT</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-memoryTypeIndex-01872</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_VERSION_1_1)</th><th> If the protected memory feature is not enabled, the VkMemoryAllocateInfo::memoryTypeIndex must not indicate a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-memoryTypeIndex-02385</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferMemoryAllocation</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, memoryTypeIndex must be one of those returned by vkGetAndroidHardwareBufferPropertiesANDROID for the Android hardware buffer.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-00639</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory)+(VK_KHR_dedicated_allocation,VK_NV_dedicated_allocation)</th><th>     If the pNext chain contains an instance of     VkExportMemoryAllocateInfo, and any of the handle types specified     in VkExportMemoryAllocateInfo::handleTypes require a     dedicated allocation, as reported by     vkGetPhysicalDeviceImageFormatProperties2 in     VkExternalImageFormatProperties::externalMemoryProperties::externalMemoryFeatures     or     VkExternalBufferProperties::externalMemoryProperties::externalMemoryFeatures,     the pNext chain must contain an instance of ifdef::VK_KHR_dedicated_allocation[VkMemoryDedicatedAllocateInfo]</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-00640</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory)+(VK_NV_external_memory)</th><th> If the pNext chain contains an instance of VkExportMemoryAllocateInfo, it must not contain an instance of VkExportMemoryAllocateInfoNV or VkExportMemoryWin32HandleInfoNV.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-00641</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_KHR_external_memory_win32+VK_NV_external_memory_win32)</th><th> If the pNext chain contains an instance of VkImportMemoryWin32HandleInfoKHR, it must not contain an instance of VkImportMemoryWin32HandleInfoNV.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-01874</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferMemoryAllocation</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the parameters do not define an import operation, and the pNext chain contains an instance of VkExportMemoryAllocateInfo with VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID included in its handleTypes member, and the pNext contains an instance of VkMemoryDedicatedAllocateInfo with image not equal to VK_NULL_HANDLE, then allocationSize must be 0, otherwise allocationSize must be greater than 0.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-02384</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferImportBuffer, AndroidHardwareBufferMemoryAllocation</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, and the pNext chain does not contain an instance of VkMemoryDedicatedAllocateInfo or VkMemoryDedicatedAllocateInfo::image is VK_NULL_HANDLE, the Android hardware buffer must have a AHardwareBuffer_Desc::format of AHARDWAREBUFFER_FORMAT_BLOB and a AHardwareBuffer_Desc::usage that includes AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-02386</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferMemoryAllocation</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, the Android hardware buffer's AHardwareBuffer::usage must include at least one of AHARDWAREBUFFER_USAGE_GPU_COLOR_OUTPUT or AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-02387</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferMemoryAllocation</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, the format of image must be VK_FORMAT_UNDEFINED or the format returned by vkGetAndroidHardwareBufferPropertiesANDROID in VkAndroidHardwareBufferFormatPropertiesANDROID::format for the Android hardware buffer.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-02388</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferMemoryAllocation</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, the width, height, and array layer dimensions of image and the Android hardware buffer's AHardwareBuffer_Desc must be identical.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-02389</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferMemoryAllocation</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, and the Android hardware buffer's AHardwareBuffer::usage includes AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE, the image must have a complete mipmap chain.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-02390</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferMemoryAllocation</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, each bit set in the usage of image must be listed in AHardwareBuffer Usage Equivalence, and if there is a corresponding AHARDWAREBUFFER_USAGE bit listed that bit must be included in the Android hardware buffer's AHardwareBuffer_Desc::usage.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-02586</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryAllocateInfo</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, and the Android hardware buffer's AHardwareBuffer::usage does not include AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE, the image must have exactly one mipmap level.</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryAllocateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDedicatedAllocationMemoryAllocateInfoNV, VkExportMemoryAllocateInfo, VkExportMemoryAllocateInfoNV, VkExportMemoryWin32HandleInfoKHR, VkExportMemoryWin32HandleInfoNV, VkImportAndroidHardwareBufferInfoANDROID, VkImportMemoryFdInfoKHR, VkImportMemoryHostPointerInfoEXT, VkImportMemoryWin32HandleInfoKHR, VkImportMemoryWin32HandleInfoNV, VkMemoryAllocateFlagsInfo, VkMemoryDedicatedAllocateInfo, or VkMemoryPriorityAllocateInfoEXT</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryAllocateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</th></tr>
<tr><th>VUID-VkMemoryAllocateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryAllocateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkMemoryBarrier-dstAccessMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryBarrier</th><th>core</th><th> dstAccessMask must be a valid combination of VkAccessFlagBits values</th></tr>
<tr><th>VUID-VkMemoryBarrier-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryBarrier</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMemoryBarrier-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryBarrier</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_BARRIER</th></tr>
<tr><th>VUID-VkMemoryBarrier-srcAccessMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryBarrier</th><th>core</th><th> srcAccessMask must be a valid combination of VkAccessFlagBits values</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-buffer-01435</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If buffer is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the buffer</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-buffer-01436</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If buffer is not VK_NULL_HANDLE, buffer must have been created without VK_BUFFER_CREATE_SPARSE_BINDING_BIT set in VkBufferCreateInfo::flags</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-buffer-01877</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_KHR_external_memory_win32)</th><th> If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and the external handle was created by the Vulkan API, then the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory.</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-buffer-01879</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_KHR_external_memory_fd)</th><th> If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory.</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-buffer-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-commonparent</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> Both of buffer, and image that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-image-01432</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> At least one of image and buffer must be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-image-01433</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If image is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the image</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-image-01434</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If image is not VK_NULL_HANDLE, image must have been created without VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in VkImageCreateInfo::flags</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-image-01797</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_KHR_sampler_ycbcr_conversion)</th><th> If image is not VK_NULL_HANDLE, image must not have been created with VK_IMAGE_CREATE_DISJOINT_BIT set in VkImageCreateInfo::flags</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-image-01876</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_KHR_external_memory_win32)</th><th> If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and the external handle was created by the Vulkan API, then the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory.</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-image-01878</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_KHR_external_memory_fd)</th><th> If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory.</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-image-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If image is not VK_NULL_HANDLE, image must be a valid VkImage handle</th></tr>
<tr><th>VUID-VkMemoryDedicatedAllocateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryDedicatedAllocateInfo</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO</th></tr>
<tr><th>VUID-VkMemoryDedicatedRequirements-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryDedicatedRequirements</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS</th></tr>
<tr><th>VUID-VkMemoryFdPropertiesKHR-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryFdPropertiesKHR</th><th>(VK_KHR_external_memory_fd)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMemoryFdPropertiesKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryFdPropertiesKHR</th><th>(VK_KHR_external_memory_fd)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR</th></tr>
<tr><th>VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-handleTypes-01882</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferExporttBuffer</th><th>explicit</th><th>VkMemoryGetAndroidHardwareBufferInfoANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID must have been included in VkExportMemoryAllocateInfoKHR::handleTypes when memory was created.</th></tr>
<tr><th>VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetAndroidHardwareBufferInfoANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-pNext-01883</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferExporttBuffer</th><th>explicit</th><th>VkMemoryGetAndroidHardwareBufferInfoANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the pNext chain of the VkMemoryAllocateInfo used to allocate memory included a VkMemoryDedicatedAllocateInfo with non-NULL image member, then that image must already be bound to memory.</th></tr>
<tr><th>VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetAndroidHardwareBufferInfoANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetAndroidHardwareBufferInfoANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID</th></tr>
<tr><th>VUID-VkMemoryGetFdInfoKHR-handleType-00671</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryGetFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created.</th></tr>
<tr><th>VUID-VkMemoryGetFdInfoKHR-handleType-00672</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryGetFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> handleType must be defined as a POSIX file descriptor handle.</th></tr>
<tr><th>VUID-VkMemoryGetFdInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkMemoryGetFdInfoKHR-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-VkMemoryGetFdInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMemoryGetFdInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetFdInfoKHR</th><th>(VK_KHR_external_memory_fd)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR</th></tr>
<tr><th>VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00662</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryGetWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created.</th></tr>
<tr><th>VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00663</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryGetWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> If handleType is defined as an NT handle, vkGetMemoryWin32HandleKHR must be called no more than once for each valid unique combination of memory and handleType.</th></tr>
<tr><th>VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00664</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkMemoryGetWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> handleType must be defined as an NT handle or a global share handle.</th></tr>
<tr><th>VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkMemoryGetWin32HandleInfoKHR-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-VkMemoryGetWin32HandleInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMemoryGetWin32HandleInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryGetWin32HandleInfoKHR</th><th>(VK_KHR_external_memory_win32)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR</th></tr>
<tr><th>VUID-VkMemoryHostPointerPropertiesEXT-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryHostPointerPropertiesEXT</th><th>(VK_EXT_external_memory_host)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMemoryHostPointerPropertiesEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryHostPointerPropertiesEXT</th><th>(VK_EXT_external_memory_host)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkMemoryPriorityAllocateInfoEXT-priority-02602</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkMemoryPriorityAllocateInfoEXT</th><th>(VK_EXT_memory_priority)</th><th> priority must be between 0 and 1, inclusive</th></tr>
<tr><th>VUID-VkMemoryPriorityAllocateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryPriorityAllocateInfoEXT</th><th>(VK_EXT_memory_priority)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT</th></tr>
<tr><th>VUID-VkMemoryRequirements2-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pNext must be NULL or a pointer to a valid instance of VkMemoryDedicatedRequirements</th></tr>
<tr><th>VUID-VkMemoryRequirements2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2</th></tr>
<tr><th>VUID-VkMemoryWin32HandlePropertiesKHR-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMemoryWin32HandlePropertiesKHR</th><th>(VK_KHR_external_memory_win32)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMemoryWin32HandlePropertiesKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMemoryWin32HandlePropertiesKHR</th><th>(VK_KHR_external_memory_win32)</th><th> sType must be VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR</th></tr>
<tr><th>VUID-VkMetalSurfaceCreateInfoEXT-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMetalSurfaceCreateInfoEXT</th><th>(VK_KHR_surface)+(VK_EXT_metal_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkMetalSurfaceCreateInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMetalSurfaceCreateInfoEXT</th><th>(VK_KHR_surface)+(VK_EXT_metal_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMetalSurfaceCreateInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMetalSurfaceCreateInfoEXT</th><th>(VK_KHR_surface)+(VK_EXT_metal_surface)</th><th> sType must be VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkMultisamplePropertiesEXT-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkMultisamplePropertiesEXT</th><th>(VK_EXT_sample_locations)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkMultisamplePropertiesEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkMultisamplePropertiesEXT</th><th>(VK_EXT_sample_locations)</th><th> sType must be VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-computeBindingPointSupport-01355</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If the VkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupport feature is not enabled, pObjectEntryUsageFlags must not contain VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-maxSampledImagesPerDescriptor-01360</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> maxSampledImagesPerDescriptor must be within the limits supported by the device.</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-maxStorageBuffersPerDescriptor-01358</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> maxStorageBuffersPerDescriptor must be within the limits supported by the device.</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-maxStorageImagesPerDescriptor-01359</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> maxStorageImagesPerDescriptor must be within the limits supported by the device.</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-maxUniformBuffersPerDescriptor-01357</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> maxUniformBuffersPerDescriptor must be within the limits supported by the device.</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-objectCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectCount must be greater than 0</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-pObjectEntryCounts-01356</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> Any value within pObjectEntryCounts must not exceed VkDeviceGeneratedCommandsLimitsNVX::maxObjectEntryCounts</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-pObjectEntryCounts-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pObjectEntryCounts must be a valid pointer to an array of objectCount uint32_t values</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-pObjectEntryTypes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pObjectEntryTypes must be a valid pointer to an array of objectCount valid VkObjectEntryTypeNVX values</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-pObjectEntryUsageFlags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pObjectEntryUsageFlags must be a valid pointer to an array of objectCount valid combinations of VkObjectEntryUsageFlagBitsNVX values</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-pObjectEntryUsageFlags-requiredbitmask</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> Each element of pObjectEntryUsageFlags must not be 0</th></tr>
<tr><th>VUID-VkObjectTableCreateInfoNVX-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkObjectTableCreateInfoNVX</th><th>(VK_NVX_device_generated_commands)</th><th> sType must be VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX</th></tr>
<tr><th>VUID-VkObjectTableDescriptorSetEntryNVX-commonparent</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableDescriptorSetEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> Both of descriptorSet, and pipelineLayout must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkObjectTableDescriptorSetEntryNVX-descriptorSet-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableDescriptorSetEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> descriptorSet must be a valid VkDescriptorSet handle</th></tr>
<tr><th>VUID-VkObjectTableDescriptorSetEntryNVX-flags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableDescriptorSetEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</th></tr>
<tr><th>VUID-VkObjectTableDescriptorSetEntryNVX-flags-requiredbitmask</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableDescriptorSetEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must not be 0</th></tr>
<tr><th>VUID-VkObjectTableDescriptorSetEntryNVX-pipelineLayout-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableDescriptorSetEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pipelineLayout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-VkObjectTableDescriptorSetEntryNVX-type-01369</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTableDescriptorSetEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX</th></tr>
<tr><th>VUID-VkObjectTableDescriptorSetEntryNVX-type-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableDescriptorSetEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be a valid VkObjectEntryTypeNVX value</th></tr>
<tr><th>VUID-VkObjectTableEntryNVX-computeBindingPointSupport-01367</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTableEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If the VkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupport feature is not enabled, flags must not contain VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX</th></tr>
<tr><th>VUID-VkObjectTableEntryNVX-flags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</th></tr>
<tr><th>VUID-VkObjectTableEntryNVX-flags-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkObjectTableEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must not be 0</th></tr>
<tr><th>VUID-VkObjectTableEntryNVX-type-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkObjectTableEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be a valid VkObjectEntryTypeNVX value</th></tr>
<tr><th>VUID-VkObjectTableIndexBufferEntryNVX-buffer-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableIndexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkObjectTableIndexBufferEntryNVX-flags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableIndexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</th></tr>
<tr><th>VUID-VkObjectTableIndexBufferEntryNVX-flags-requiredbitmask</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableIndexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must not be 0</th></tr>
<tr><th>VUID-VkObjectTableIndexBufferEntryNVX-indexType-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableIndexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> indexType must be a valid VkIndexType value</th></tr>
<tr><th>VUID-VkObjectTableIndexBufferEntryNVX-type-01371</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTableIndexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX</th></tr>
<tr><th>VUID-VkObjectTableIndexBufferEntryNVX-type-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableIndexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be a valid VkObjectEntryTypeNVX value</th></tr>
<tr><th>VUID-VkObjectTablePipelineEntryNVX-flags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTablePipelineEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</th></tr>
<tr><th>VUID-VkObjectTablePipelineEntryNVX-flags-requiredbitmask</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTablePipelineEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must not be 0</th></tr>
<tr><th>VUID-VkObjectTablePipelineEntryNVX-pipeline-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTablePipelineEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pipeline must be a valid VkPipeline handle</th></tr>
<tr><th>VUID-VkObjectTablePipelineEntryNVX-type-01368</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTablePipelineEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX</th></tr>
<tr><th>VUID-VkObjectTablePipelineEntryNVX-type-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTablePipelineEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be a valid VkObjectEntryTypeNVX value</th></tr>
<tr><th>VUID-VkObjectTablePushConstantEntryNVX-flags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTablePushConstantEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</th></tr>
<tr><th>VUID-VkObjectTablePushConstantEntryNVX-flags-requiredbitmask</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTablePushConstantEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must not be 0</th></tr>
<tr><th>VUID-VkObjectTablePushConstantEntryNVX-pipelineLayout-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTablePushConstantEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pipelineLayout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-VkObjectTablePushConstantEntryNVX-stageFlags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTablePushConstantEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> stageFlags must be a valid combination of VkShaderStageFlagBits values</th></tr>
<tr><th>VUID-VkObjectTablePushConstantEntryNVX-stageFlags-requiredbitmask</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTablePushConstantEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> stageFlags must not be 0</th></tr>
<tr><th>VUID-VkObjectTablePushConstantEntryNVX-type-01372</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTablePushConstantEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX</th></tr>
<tr><th>VUID-VkObjectTablePushConstantEntryNVX-type-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTablePushConstantEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be a valid VkObjectEntryTypeNVX value</th></tr>
<tr><th>VUID-VkObjectTableVertexBufferEntryNVX-buffer-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableVertexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkObjectTableVertexBufferEntryNVX-flags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableVertexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</th></tr>
<tr><th>VUID-VkObjectTableVertexBufferEntryNVX-flags-requiredbitmask</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableVertexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> flags must not be 0</th></tr>
<tr><th>VUID-VkObjectTableVertexBufferEntryNVX-type-01370</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkObjectTableVertexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX</th></tr>
<tr><th>VUID-VkObjectTableVertexBufferEntryNVX-type-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkObjectTableVertexBufferEntryNVX</th><th>(VK_NVX_device_generated_commands)</th><th> type must be a valid VkObjectEntryTypeNVX value</th></tr>
<tr><th>VUID-VkPhysicalDevice16BitStorageFeatures-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDevice16BitStorageFeatures</th><th>(VK_VERSION_1_1,VK_KHR_16bit_storage)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES</th></tr>
<tr><th>VUID-VkPhysicalDevice8BitStorageFeaturesKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDevice8BitStorageFeaturesKHR</th><th>(VK_KHR_8bit_storage)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR</th></tr>
<tr><th>VUID-VkPhysicalDeviceASTCDecodeFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceASTCDecodeFeaturesEXT</th><th>(VK_EXT_astc_decode_mode)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT</th><th>(VK_EXT_blend_operation_advanced)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT</th><th>(VK_EXT_blend_operation_advanced)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceBufferDeviceAddressFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceBufferDeviceAddressFeaturesEXT</th><th>(VK_EXT_buffer_device_address)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceComputeShaderDerivativesFeaturesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceComputeShaderDerivativesFeaturesNV</th><th>(VK_NV_compute_shader_derivatives)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceConditionalRenderingFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceConditionalRenderingFeaturesEXT</th><th>(VK_EXT_conditional_rendering)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceConservativeRasterizationPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceConservativeRasterizationPropertiesEXT</th><th>(VK_EXT_conservative_rasterization)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceCooperativeMatrixFeaturesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceCooperativeMatrixFeaturesNV</th><th>(VK_NV_cooperative_matrix)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceCooperativeMatrixPropertiesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceCornerSampledImageFeaturesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceCornerSampledImageFeaturesNV</th><th>(VK_NV_corner_sampled_image)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV</th><th>(VK_NV_dedicated_allocation_image_aliasing)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceDepthClipEnableFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceDepthClipEnableFeaturesEXT</th><th>(VK_EXT_depth_clip_enable)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceDepthStencilResolvePropertiesKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceDepthStencilResolvePropertiesKHR</th><th>(VK_KHR_depth_stencil_resolve)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR</th></tr>
<tr><th>VUID-VkPhysicalDeviceDescriptorIndexingFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceDescriptorIndexingFeaturesEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceDescriptorIndexingPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceDescriptorIndexingPropertiesEXT</th><th>(VK_EXT_descriptor_indexing)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceDiscardRectanglePropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceDiscardRectanglePropertiesEXT</th><th>(VK_EXT_discard_rectangles)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceDriverPropertiesKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceDriverPropertiesKHR</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_KHR_driver_properties)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR</th></tr>
<tr><th>VUID-VkPhysicalDeviceExclusiveScissorFeaturesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExclusiveScissorFeaturesNV</th><th>(VK_NV_scissor_exclusive)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalBufferInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalBufferInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> flags must be a valid combination of VkBufferCreateFlagBits values</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalBufferInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalBufferInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalBufferInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalBufferInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalBufferInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalBufferInfo-usage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalBufferInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> usage must be a valid combination of VkBufferUsageFlagBits values</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalBufferInfo-usage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalBufferInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> usage must not be 0</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalFenceInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)</th><th> handleType must be a valid VkExternalFenceHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalFenceInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalFenceInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalFenceInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalFenceInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalImageFormatInfo-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalImageFormatInfo</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalImageFormatInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalImageFormatInfo</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalMemoryHostPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalMemoryHostPropertiesEXT</th><th>(VK_EXT_external_memory_host)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalSemaphoreInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)</th><th> handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalSemaphoreInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalSemaphoreInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceExternalSemaphoreInfo</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO</th></tr>
<tr><th>VUID-VkPhysicalDeviceFeatures2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceFeatures2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2</th></tr>
<tr><th>VUID-VkPhysicalDeviceFloat16Int8FeaturesKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceFloat16Int8FeaturesKHR</th><th>(VK_KHR_shader_float16_int8)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR</th></tr>
<tr><th>VUID-VkPhysicalDeviceFloatControlsPropertiesKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceFloatControlsPropertiesKHR</th><th>(VK_KHR_shader_float_controls)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR</th></tr>
<tr><th>VUID-VkPhysicalDeviceFragmentDensityMapFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceFragmentDensityMapFeaturesEXT</th><th>(VK_EXT_fragment_density_map)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceFragmentDensityMapPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceFragmentDensityMapPropertiesEXT</th><th>(VK_EXT_fragment_density_map)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV</th><th>(VK_NV_fragment_shader_barycentric)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceGroupProperties-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceGroupProperties</th><th>(VK_VERSION_1_1,VK_KHR_device_group_creation)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPhysicalDeviceGroupProperties-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceGroupProperties</th><th>(VK_VERSION_1_1,VK_KHR_device_group_creation)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES</th></tr>
<tr><th>VUID-VkPhysicalDeviceHostQueryResetFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceHostQueryResetFeaturesEXT</th><th>(VK_EXT_host_query_reset)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceIDProperties-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceIDProperties</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_VERSION_1_1,VK_KHR_external_memory_capabilities,VK_KHR_external_semaphore_capabilities,VK_KHR_external_fence_capabilities)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageDrmFormatModifierInfoEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_image_drm_format_modifier)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-02314</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPhysicalDeviceImageDrmFormatModifierInfoEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_image_drm_format_modifier)</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, then pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values.</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-02315</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPhysicalDeviceImageDrmFormatModifierInfoEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_image_drm_format_modifier)</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, then queueFamilyIndexCount must be greater than 1.</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-02316</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPhysicalDeviceImageDrmFormatModifierInfoEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_image_drm_format_modifier)</th><th> If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than the pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device.</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageDrmFormatModifierInfoEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_image_drm_format_modifier)</th><th> sharingMode must be a valid VkSharingMode value</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> flags must be a valid combination of VkImageCreateFlagBits values</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkImageFormatListCreateInfoKHR, VkImageStencilUsageCreateInfoEXT, VkPhysicalDeviceExternalImageFormatInfo, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, or VkPhysicalDeviceImageViewImageFormatInfoEXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-tiling-02249</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_image_drm_format_modifier)</th><th> tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT if and only if the pNext chain contains VkPhysicalDeviceImageDrmFormatModifierInfoEXT.</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-tiling-02313</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_image_drm_format_modifier)</th><th> If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and flags contains VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then the pNext chain must contain VkImageFormatListCreateInfoKHR with non-zero viewFormatCount.</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-tiling-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> tiling must be a valid VkImageTiling value</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-type-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> type must be a valid VkImageType value</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-usage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> usage must be a valid combination of VkImageUsageFlagBits values</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageFormatInfo2-usage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> usage must not be 0</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageViewImageFormatInfoEXT-imageViewType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageViewImageFormatInfoEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_filter_cubic)</th><th> imageViewType must be a valid VkImageViewType value</th></tr>
<tr><th>VUID-VkPhysicalDeviceImageViewImageFormatInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceImageViewImageFormatInfoEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_filter_cubic)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceInlineUniformBlockFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceInlineUniformBlockFeaturesEXT</th><th>(VK_EXT_inline_uniform_block)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceInlineUniformBlockPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceInlineUniformBlockPropertiesEXT</th><th>(VK_EXT_inline_uniform_block)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceMaintenance3Properties-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceMaintenance3Properties</th><th>(VK_VERSION_1_1,VK_KHR_maintenance3)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES</th></tr>
<tr><th>VUID-VkPhysicalDeviceMemoryBudgetPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceMemoryBudgetPropertiesEXT</th><th>(VK_EXT_memory_budget)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceMemoryPriorityFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceMemoryPriorityFeaturesEXT</th><th>(VK_EXT_memory_priority)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceMemoryProperties2-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceMemoryProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pNext must be NULL or a pointer to a valid instance of VkPhysicalDeviceMemoryBudgetPropertiesEXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceMemoryProperties2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceMemoryProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2</th></tr>
<tr><th>VUID-VkPhysicalDeviceMeshShaderFeaturesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceMeshShaderFeaturesNV</th><th>(VK_NV_mesh_shader)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceMeshShaderPropertiesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceMeshShaderPropertiesNV</th><th>(VK_NV_mesh_shader)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceMultiviewFeatures-multiviewGeometryShader-00580</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPhysicalDeviceMultiviewFeatures</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If multiviewGeometryShader is enabled then multiview must also be enabled.</th></tr>
<tr><th>VUID-VkPhysicalDeviceMultiviewFeatures-multiviewTessellationShader-00581</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPhysicalDeviceMultiviewFeatures</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If multiviewTessellationShader is enabled then multiview must also be enabled.</th></tr>
<tr><th>VUID-VkPhysicalDeviceMultiviewFeatures-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceMultiviewFeatures</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES</th></tr>
<tr><th>VUID-VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX</th><th>(VK_NVX_multiview_per_view_attributes)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX</th></tr>
<tr><th>VUID-VkPhysicalDeviceMultiviewProperties-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceMultiviewProperties</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES</th></tr>
<tr><th>VUID-VkPhysicalDevicePCIBusInfoPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDevicePCIBusInfoPropertiesEXT</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_EXT_pci_bus_info)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDevicePointClippingProperties-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDevicePointClippingProperties</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES</th></tr>
<tr><th>VUID-VkPhysicalDeviceProperties2-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceDepthStencilResolvePropertiesKHR, VkPhysicalDeviceDescriptorIndexingPropertiesEXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDriverPropertiesKHR, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceFloatControlsPropertiesKHR, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceIDProperties, VkPhysicalDeviceInlineUniformBlockPropertiesEXT, VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewProperties, VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePointClippingProperties, VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDevicePushDescriptorPropertiesKHR, VkPhysicalDeviceRayTracingPropertiesNV, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShadingRateImagePropertiesNV, VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceTransformFeedbackPropertiesEXT, or VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceProperties2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2</th></tr>
<tr><th>VUID-VkPhysicalDeviceProperties2-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkPhysicalDeviceProtectedMemoryFeatures-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceProtectedMemoryFeatures</th><th>(VK_VERSION_1_1)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES</th></tr>
<tr><th>VUID-VkPhysicalDeviceProtectedMemoryProperties-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceProtectedMemoryProperties</th><th>(VK_VERSION_1_1)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES</th></tr>
<tr><th>VUID-VkPhysicalDevicePushDescriptorPropertiesKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDevicePushDescriptorPropertiesKHR</th><th>(VK_KHR_push_descriptor)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR</th></tr>
<tr><th>VUID-VkPhysicalDeviceRayTracingPropertiesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceRayTracingPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV</th><th>(VK_NV_representative_fragment_test)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceSampleLocationsPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSampleLocationsPropertiesEXT</th><th>(VK_EXT_sample_locations)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT</th><th>(VK_EXT_sampler_filter_minmax)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceSamplerYcbcrConversionFeatures-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSamplerYcbcrConversionFeatures</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES</th></tr>
<tr><th>VUID-VkPhysicalDeviceScalarBlockLayoutFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceScalarBlockLayoutFeaturesEXT</th><th>(VK_EXT_scalar_block_layout)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceShaderAtomicInt64FeaturesKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceShaderAtomicInt64FeaturesKHR</th><th>(VK_KHR_shader_atomic_int64)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR</th></tr>
<tr><th>VUID-VkPhysicalDeviceShaderCorePropertiesAMD-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceShaderCorePropertiesAMD</th><th>(VK_AMD_shader_core_properties)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD</th></tr>
<tr><th>VUID-VkPhysicalDeviceShaderDrawParametersFeatures-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceShaderDrawParametersFeatures</th><th>(VK_VERSION_1_1)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES</th></tr>
<tr><th>VUID-VkPhysicalDeviceShaderImageFootprintFeaturesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceShaderImageFootprintFeaturesNV</th><th>(VK_NV_shader_image_footprint)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceShadingRateImageFeaturesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceShadingRateImageFeaturesNV</th><th>(VK_NV_shading_rate_image)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceShadingRateImagePropertiesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceShadingRateImagePropertiesNV</th><th>(VK_NV_shading_rate_image)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV</th></tr>
<tr><th>VUID-VkPhysicalDeviceSparseImageFormatInfo2-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSparseImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkPhysicalDeviceSparseImageFormatInfo2-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSparseImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPhysicalDeviceSparseImageFormatInfo2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSparseImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2</th></tr>
<tr><th>VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-01095</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPhysicalDeviceSparseImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> samples must be a bit value that is set in VkImageFormatProperties::sampleCounts returned by vkGetPhysicalDeviceImageFormatProperties with format, type, tiling, and usage equal to those in this command and flags equal to the value that is set in VkImageCreateInfo::flags when the image is created</th></tr>
<tr><th>VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSparseImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> samples must be a valid VkSampleCountFlagBits value</th></tr>
<tr><th>VUID-VkPhysicalDeviceSparseImageFormatInfo2-tiling-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSparseImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> tiling must be a valid VkImageTiling value</th></tr>
<tr><th>VUID-VkPhysicalDeviceSparseImageFormatInfo2-type-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSparseImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> type must be a valid VkImageType value</th></tr>
<tr><th>VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSparseImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> usage must be a valid combination of VkImageUsageFlagBits values</th></tr>
<tr><th>VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSparseImageFormatInfo2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> usage must not be 0</th></tr>
<tr><th>VUID-VkPhysicalDeviceSubgroupProperties-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSubgroupProperties</th><th>(VK_VERSION_1_1)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES</th></tr>
<tr><th>VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-02672</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPhysicalDeviceSurfaceInfo2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_KHR_win32_surface,VK_EXT_full_screen_exclusive)</th><th> If the pNext chain includes an instance of VkSurfaceFullScreenExclusiveInfoEXT with its fullScreenExclusive member set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and surface was created using vkCreateWin32SurfaceKHR, an instance of VkSurfaceFullScreenExclusiveWin32InfoEXT must be present in the pNext chain</th></tr>
<tr><th>VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSurfaceInfo2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkSurfaceFullScreenExclusiveInfoEXT or VkSurfaceFullScreenExclusiveWin32InfoEXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSurfaceInfo2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR</th></tr>
<tr><th>VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSurfaceInfo2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkPhysicalDeviceSurfaceInfo2KHR-surface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceSurfaceInfo2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> surface must be a valid VkSurfaceKHR handle</th></tr>
<tr><th>VUID-VkPhysicalDeviceTransformFeedbackFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceTransformFeedbackFeaturesEXT</th><th>(VK_EXT_transform_feedback)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceTransformFeedbackPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceTransformFeedbackPropertiesEXT</th><th>(VK_EXT_transform_feedback)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceVariablePointersFeatures-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceVariablePointersFeatures</th><th>(VK_VERSION_1_1,VK_KHR_variable_pointers)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES</th></tr>
<tr><th>VUID-VkPhysicalDeviceVariablePointersFeatures-variablePointers-01431</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPhysicalDeviceVariablePointersFeatures</th><th>(VK_VERSION_1_1,VK_KHR_variable_pointers)</th><th> If variablePointers is enabled then variablePointersStorageBuffer must also be enabled.</th></tr>
<tr><th>VUID-VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT</th><th>(VK_EXT_vertex_attribute_divisor)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT</th><th>(VK_EXT_vertex_attribute_divisor)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT</th></tr>
<tr><th>VUID-VkPhysicalDeviceVulkanMemoryModelFeaturesKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceVulkanMemoryModelFeaturesKHR</th><th>(VK_KHR_vulkan_memory_model)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR</th></tr>
<tr><th>VUID-VkPhysicalDeviceYcbcrImageArraysFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPhysicalDeviceYcbcrImageArraysFeaturesEXT</th><th>(VK_EXT_ycbcr_image_arrays)</th><th> sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT</th></tr>
<tr><th>VUID-VkPipelineCacheCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineCacheCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineCacheCreateInfo-initialDataSize-00768</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineCacheCreateInfo</th><th>core</th><th> If initialDataSize is not 0, it must be equal to the size of pInitialData, as returned by vkGetPipelineCacheData when pInitialData was originally retrieved</th></tr>
<tr><th>VUID-VkPipelineCacheCreateInfo-initialDataSize-00769</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineCacheCreateInfo</th><th>core</th><th> If initialDataSize is not 0, pInitialData must have been retrieved from a previous call to vkGetPipelineCacheData</th></tr>
<tr><th>VUID-VkPipelineCacheCreateInfo-pInitialData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineCacheCreateInfo</th><th>core</th><th> If initialDataSize is not 0, pInitialData must be a valid pointer to an array of initialDataSize bytes</th></tr>
<tr><th>VUID-VkPipelineCacheCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineCacheCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPipelineCacheCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineCacheCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-01426</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineColorBlendAdvancedStateCreateInfoEXT</th><th>(VK_EXT_blend_operation_advanced)</th><th> If the correlated overlap property is not supported, blendOverlap must be VK_BLEND_OVERLAP_UNCORRELATED_EXT</th></tr>
<tr><th>VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendAdvancedStateCreateInfoEXT</th><th>(VK_EXT_blend_operation_advanced)</th><th> blendOverlap must be a valid VkBlendOverlapEXT value</th></tr>
<tr><th>VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-dstPremultiplied-01425</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineColorBlendAdvancedStateCreateInfoEXT</th><th>(VK_EXT_blend_operation_advanced)</th><th> If the non-premultiplied destination color property is not supported, dstPremultiplied must be VK_TRUE</th></tr>
<tr><th>VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendAdvancedStateCreateInfoEXT</th><th>(VK_EXT_blend_operation_advanced)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-srcPremultiplied-01424</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineColorBlendAdvancedStateCreateInfoEXT</th><th>(VK_EXT_blend_operation_advanced)</th><th> If the non-premultiplied source color property is not supported, srcPremultiplied must be VK_TRUE</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-advancedBlendAllOperations-01409</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineColorBlendAttachmentState</th><th>(VK_EXT_blend_operation_advanced)</th><th> If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendAllOperations is VK_FALSE, then colorBlendOp must not be VK_BLEND_OP_ZERO_EXT, VK_BLEND_OP_SRC_EXT, VK_BLEND_OP_DST_EXT, VK_BLEND_OP_SRC_OVER_EXT, VK_BLEND_OP_DST_OVER_EXT, VK_BLEND_OP_SRC_IN_EXT, VK_BLEND_OP_DST_IN_EXT, VK_BLEND_OP_SRC_OUT_EXT, VK_BLEND_OP_DST_OUT_EXT, VK_BLEND_OP_SRC_ATOP_EXT, VK_BLEND_OP_DST_ATOP_EXT, VK_BLEND_OP_XOR_EXT, VK_BLEND_OP_INVERT_EXT, VK_BLEND_OP_INVERT_RGB_EXT, VK_BLEND_OP_LINEARDODGE_EXT, VK_BLEND_OP_LINEARBURN_EXT, VK_BLEND_OP_VIVIDLIGHT_EXT, VK_BLEND_OP_LINEARLIGHT_EXT, VK_BLEND_OP_PINLIGHT_EXT, VK_BLEND_OP_HARDMIX_EXT, VK_BLEND_OP_PLUS_EXT, VK_BLEND_OP_PLUS_CLAMPED_EXT, VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT, VK_BLEND_OP_PLUS_DARKER_EXT, VK_BLEND_OP_MINUS_EXT, VK_BLEND_OP_MINUS_CLAMPED_EXT, VK_BLEND_OP_CONTRAST_EXT, VK_BLEND_OP_INVERT_OVG_EXT, VK_BLEND_OP_RED_EXT, VK_BLEND_OP_GREEN_EXT, or VK_BLEND_OP_BLUE_EXT</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-advancedBlendIndependentBlend-01407</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineColorBlendAttachmentState</th><th>(VK_EXT_blend_operation_advanced)</th><th> If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlend is VK_FALSE and colorBlendOp is an advanced blend operation, then colorBlendOp must be the same for all attachments.</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-advancedBlendIndependentBlend-01408</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineColorBlendAttachmentState</th><th>(VK_EXT_blend_operation_advanced)</th><th> If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlend is VK_FALSE and alphaBlendOp is an advanced blend operation, then alphaBlendOp must be the same for all attachments.</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-alphaBlendOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> alphaBlendOp must be a valid VkBlendOp value</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-01406</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineColorBlendAttachmentState</th><th>(VK_EXT_blend_operation_advanced)</th><th> If either of colorBlendOp or alphaBlendOp is an advanced blend operation, then colorBlendOp must equal alphaBlendOp</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-01410</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineColorBlendAttachmentState</th><th>(VK_EXT_blend_operation_advanced)</th><th> If colorBlendOp or alphaBlendOp is an advanced blend operation, then VkSubpassDescription::colorAttachmentCount of the subpass this pipeline is compiled against must be less than or equal to VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendMaxColorAttachments</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> colorBlendOp must be a valid VkBlendOp value</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-colorWriteMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> colorWriteMask must be a valid combination of VkColorComponentFlagBits values</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-00611</th><th><span style="color:limegreen;">Y</span></th><th>ColorBlendUnsupportedDualSourceBlend</th><th>explicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> If the dual source blending feature is not enabled, dstAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> dstAlphaBlendFactor must be a valid VkBlendFactor value</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-00609</th><th><span style="color:limegreen;">Y</span></th><th>ColorBlendUnsupportedDualSourceBlend</th><th>explicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> If the dual source blending feature is not enabled, dstColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> dstColorBlendFactor must be a valid VkBlendFactor value</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-00610</th><th><span style="color:limegreen;">Y</span></th><th>ColorBlendUnsupportedDualSourceBlend</th><th>explicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> If the dual source blending feature is not enabled, srcAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> srcAlphaBlendFactor must be a valid VkBlendFactor value</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-00608</th><th><span style="color:limegreen;">Y</span></th><th>ColorBlendUnsupportedDualSourceBlend</th><th>explicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> If the dual source blending feature is not enabled, srcColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</th></tr>
<tr><th>VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendAttachmentState</th><th>core</th><th> srcColorBlendFactor must be a valid VkBlendFactor value</th></tr>
<tr><th>VUID-VkPipelineColorBlendStateCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendStateCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00606</th><th><span style="color:limegreen;">Y</span></th><th>ColorBlendUnsupportedLogicOp</th><th>explicit</th><th>VkPipelineColorBlendStateCreateInfo</th><th>core</th><th> If the logic operations feature is not enabled, logicOpEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00607</th><th><span style="color:limegreen;">Y</span></th><th>ColorBlendInvalidLogicOp</th><th>explicit</th><th>VkPipelineColorBlendStateCreateInfo</th><th>core</th><th> If logicOpEnable is VK_TRUE, logicOp must be a valid VkLogicOp value</th></tr>
<tr><th>VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-00605</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineColorBlendStateCreateInfo</th><th>core</th><th> If the independent blending feature is not enabled, all elements of pAttachments must be identical</th></tr>
<tr><th>VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendStateCreateInfo</th><th>core</th><th> If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkPipelineColorBlendAttachmentState structures</th></tr>
<tr><th>VUID-VkPipelineColorBlendStateCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendStateCreateInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkPipelineColorBlendAdvancedStateCreateInfoEXT</th></tr>
<tr><th>VUID-VkPipelineColorBlendStateCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineColorBlendStateCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineCoverageModulationStateCreateInfoNV-coverageModulationMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineCoverageModulationStateCreateInfoNV</th><th>(VK_NV_framebuffer_mixed_samples)</th><th> coverageModulationMode must be a valid VkCoverageModulationModeNV value</th></tr>
<tr><th>VUID-VkPipelineCoverageModulationStateCreateInfoNV-coverageModulationTableEnable-01405</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferMixedSamplesNV</th><th>explicit</th><th>VkPipelineCoverageModulationStateCreateInfoNV</th><th>(VK_NV_framebuffer_mixed_samples)</th><th> If coverageModulationTableEnable is VK_TRUE, coverageModulationTableCount must be equal to the number of rasterization samples divided by the number of color samples in the subpass.</th></tr>
<tr><th>VUID-VkPipelineCoverageModulationStateCreateInfoNV-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineCoverageModulationStateCreateInfoNV</th><th>(VK_NV_framebuffer_mixed_samples)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineCoverageModulationStateCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineCoverageModulationStateCreateInfoNV</th><th>(VK_NV_framebuffer_mixed_samples)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkPipelineCoverageToColorStateCreateInfoNV-coverageToColorEnable-01404</th><th><span style="color:limegreen;">Y</span></th><th>FragmentCoverageToColorNV</th><th>explicit</th><th>VkPipelineCoverageToColorStateCreateInfoNV</th><th>(VK_NV_fragment_coverage_to_color)</th><th> If coverageToColorEnable is VK_TRUE, then the render pass subpass indicated by VkGraphicsPipelineCreateInfo::renderPass and VkGraphicsPipelineCreateInfo::subpass must have a color attachment at the location selected by coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT</th></tr>
<tr><th>VUID-VkPipelineCoverageToColorStateCreateInfoNV-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineCoverageToColorStateCreateInfoNV</th><th>(VK_NV_fragment_coverage_to_color)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineCoverageToColorStateCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineCoverageToColorStateCreateInfoNV</th><th>(VK_NV_fragment_coverage_to_color)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkPipelineCreationFeedbackCreateInfoEXT-pPipelineCreationFeedback-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineCreationFeedbackCreateInfoEXT</th><th>(VK_EXT_pipeline_creation_feedback)</th><th> pPipelineCreationFeedback must be a valid pointer to a VkPipelineCreationFeedbackEXT structure</th></tr>
<tr><th>VUID-VkPipelineCreationFeedbackCreateInfoEXT-pPipelineStageCreationFeedbacks-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineCreationFeedbackCreateInfoEXT</th><th>(VK_EXT_pipeline_creation_feedback)</th><th> pPipelineStageCreationFeedbacks must be a valid pointer to an array of pipelineStageCreationFeedbackCount VkPipelineCreationFeedbackEXT structures</th></tr>
<tr><th>VUID-VkPipelineCreationFeedbackCreateInfoEXT-pipelineStageCreationFeedbackCount-02668</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineCreationFeedbackCreateInfoEXT</th><th>(VK_EXT_pipeline_creation_feedback)</th><th> When chained to VkGraphicsPipelineCreateInfo, VkPipelineCreationFeedbackEXT::pipelineStageCreationFeedbackCount must equal VkGraphicsPipelineCreateInfo::stageCount</th></tr>
<tr><th>VUID-VkPipelineCreationFeedbackCreateInfoEXT-pipelineStageCreationFeedbackCount-02669</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineCreationFeedbackCreateInfoEXT</th><th>(VK_EXT_pipeline_creation_feedback)</th><th> When chained to VkComputePipelineCreateInfo, VkPipelineCreationFeedbackEXT::pipelineStageCreationFeedbackCount must equal 1</th></tr>
<tr><th>VUID-VkPipelineCreationFeedbackCreateInfoEXT-pipelineStageCreationFeedbackCount-02670</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineCreationFeedbackCreateInfoEXT</th><th>(VK_EXT_pipeline_creation_feedback)+(VK_NV_ray_tracing)</th><th> When chained to VkRayTracingPipelineCreateInfoNV, VkPipelineCreationFeedbackEXT::pipelineStageCreationFeedbackCount must equal VkRayTracingPipelineCreateInfoNV::stageCount</th></tr>
<tr><th>VUID-VkPipelineCreationFeedbackCreateInfoEXT-pipelineStageCreationFeedbackCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineCreationFeedbackCreateInfoEXT</th><th>(VK_EXT_pipeline_creation_feedback)</th><th> pipelineStageCreationFeedbackCount must be greater than 0</th></tr>
<tr><th>VUID-VkPipelineCreationFeedbackCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineCreationFeedbackCreateInfoEXT</th><th>(VK_EXT_pipeline_creation_feedback)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkPipelineDepthStencilStateCreateInfo-back-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineDepthStencilStateCreateInfo</th><th>core</th><th> back must be a valid VkStencilOpState structure</th></tr>
<tr><th>VUID-VkPipelineDepthStencilStateCreateInfo-depthBoundsTestEnable-00598</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineDepthStencilStateCreateInfo</th><th>core</th><th> If the depth bounds testing feature is not enabled, depthBoundsTestEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkPipelineDepthStencilStateCreateInfo-depthCompareOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineDepthStencilStateCreateInfo</th><th>core</th><th> depthCompareOp must be a valid VkCompareOp value</th></tr>
<tr><th>VUID-VkPipelineDepthStencilStateCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineDepthStencilStateCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineDepthStencilStateCreateInfo-front-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineDepthStencilStateCreateInfo</th><th>core</th><th> front must be a valid VkStencilOpState structure</th></tr>
<tr><th>VUID-VkPipelineDepthStencilStateCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineDepthStencilStateCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPipelineDepthStencilStateCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineDepthStencilStateCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleCount-00582</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineDiscardRectangleStateCreateInfoEXT</th><th>(VK_EXT_discard_rectangles)</th><th> discardRectangleCount must be between 0 and VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles, inclusive</th></tr>
<tr><th>VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineDiscardRectangleStateCreateInfoEXT</th><th>(VK_EXT_discard_rectangles)</th><th> discardRectangleMode must be a valid VkDiscardRectangleModeEXT value</th></tr>
<tr><th>VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineDiscardRectangleStateCreateInfoEXT</th><th>(VK_EXT_discard_rectangles)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineDiscardRectangleStateCreateInfoEXT</th><th>(VK_EXT_discard_rectangles)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineDynamicStateCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-01442</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineDynamicStateCreateInfo</th><th>core</th><th> Each element of pDynamicStates must be unique</th></tr>
<tr><th>VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineDynamicStateCreateInfo</th><th>core</th><th> If dynamicStateCount is not 0, pDynamicStates must be a valid pointer to an array of dynamicStateCount valid VkDynamicState values</th></tr>
<tr><th>VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineDynamicStateCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPipelineDynamicStateCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineDynamicStateCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineInputAssemblyStateCreateInfo-flags-zerobitmask</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineInputAssemblyStateCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineInputAssemblyStateCreateInfo-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineInputAssemblyStateCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPipelineInputAssemblyStateCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineInputAssemblyStateCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00428</th><th><span style="color:limegreen;">Y</span></th><th>InvalidTopology</th><th>explicit</th><th>VkPipelineInputAssemblyStateCreateInfo</th><th>core</th><th> If topology is VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, primitiveRestartEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00429</th><th><span style="color:limegreen;">Y</span></th><th>InvalidTopology</th><th>explicit</th><th>VkPipelineInputAssemblyStateCreateInfo</th><th>core</th><th> If the geometry shaders feature is not enabled, topology must not be any of VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY</th></tr>
<tr><th>VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00430</th><th><span style="color:limegreen;">Y</span></th><th>InvalidTopology</th><th>explicit</th><th>VkPipelineInputAssemblyStateCreateInfo</th><th>core</th><th> If the tessellation shaders feature is not enabled, topology must not be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</th></tr>
<tr><th>VUID-VkPipelineInputAssemblyStateCreateInfo-topology-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineInputAssemblyStateCreateInfo</th><th>core</th><th> topology must be a valid VkPrimitiveTopology value</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-02212</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block)</th><th> The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxPerStageDescriptorInlineUniformBlocks</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-02213</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block)</th><th> The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxDescriptorSetInlineUniformBlocks</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-02214</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block)</th><th> The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxPerStageDescriptorInlineUniformBlocks</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-02215</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block)</th><th> The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-02216</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block)</th><th> The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxDescriptorSetInlineUniformBlocks</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-02217</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block)</th><th> The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxDescriptorSetUpdateAfterBindInlineUniformBlocks</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-02381</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_NV_ray_tracing)</th><th> The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxDescriptorSetAccelerationStructures</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03016</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSamplers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03017</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorUniformBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03018</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03019</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSampledImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03020</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03021</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorInputAttachments</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03022</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindSamplers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03023</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindUniformBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03024</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindStorageBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03025</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindSampledImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03026</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindStorageImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03027</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindInputAttachments</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03028</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSamplers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03029</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03030</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffersDynamic</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03031</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03032</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffersDynamic</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03033</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSampledImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03034</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-descriptorType-03035</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetInputAttachments</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineLayoutCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineLayoutCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>core</th><th> Any two elements of pPushConstantRanges must not include the same stage in stageFlags</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineLayoutCreateInfo</th><th>core</th><th> If pushConstantRangeCount is not 0, pPushConstantRanges must be a valid pointer to an array of pushConstantRangeCount valid VkPushConstantRange structures</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00287</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSamplers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00288</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorUniformBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00289</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00290</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSampledImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00291</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00293</th><th><span style="color:limegreen;">Y</span></th><th>MultiplePushDescriptorSets</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_KHR_push_descriptor)</th><th> pSetLayouts must not contain more than one descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01676</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorInputAttachments</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01677</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSamplers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01678</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01679</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffersDynamic</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01680</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01681</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffersDynamic</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01682</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSampledImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01683</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01684</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>!(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetInputAttachments</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03036</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindSamplers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03037</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindUniformBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03038</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindUniformBuffersDynamic</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03039</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageBuffers</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03040</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageBuffersDynamic</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03041</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindSampledImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03042</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageImages</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03043</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>(VK_EXT_descriptor_indexing)</th><th> The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindInputAttachments</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-pSetLayouts-parameter</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDescriptorSetLayout</th><th>implicit</th><th>VkPipelineLayoutCreateInfo</th><th>core</th><th> If setLayoutCount is not 0, pSetLayouts must be a valid pointer to an array of setLayoutCount valid VkDescriptorSetLayout handles</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineLayoutCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineLayoutExceedsSetLimit</th><th>explicit</th><th>VkPipelineLayoutCreateInfo</th><th>core</th><th> setLayoutCount must be less than or equal to VkPhysicalDeviceLimits::maxBoundDescriptorSets</th></tr>
<tr><th>VUID-VkPipelineMultisampleStateCreateInfo-alphaToOneEnable-00785</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineMultisampleStateCreateInfo</th><th>core</th><th> If the alpha to one feature is not enabled, alphaToOneEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkPipelineMultisampleStateCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineMultisampleStateCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineMultisampleStateCreateInfo-minSampleShading-00786</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipelineSampleRateFeatureEnable</th><th>explicit</th><th>VkPipelineMultisampleStateCreateInfo</th><th>core</th><th> minSampleShading must be in the range [0,1]</th></tr>
<tr><th>VUID-VkPipelineMultisampleStateCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipelineSamplePNext</th><th>implicit</th><th>VkPipelineMultisampleStateCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCoverageModulationStateCreateInfoNV, VkPipelineCoverageToColorStateCreateInfoNV, or VkPipelineSampleLocationsStateCreateInfoEXT</th></tr>
<tr><th>VUID-VkPipelineMultisampleStateCreateInfo-pSampleMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineMultisampleStateCreateInfo</th><th>core</th><th> If pSampleMask is not NULL, pSampleMask must be a valid pointer to an array of (rasterizationSamples/32) VkSampleMask values</th></tr>
<tr><th>VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-01415</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferMixedSamplesNV</th><th>explicit</th><th>VkPipelineMultisampleStateCreateInfo</th><th>(VK_NV_framebuffer_mixed_samples)</th><th> If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the subpass has any color attachments and rasterizationSamples is greater than the number of color samples, then sampleShadingEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineMultisampleStateCreateInfo</th><th>core</th><th> rasterizationSamples must be a valid VkSampleCountFlagBits value</th></tr>
<tr><th>VUID-VkPipelineMultisampleStateCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineMultisampleStateCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineMultisampleStateCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineMultisampleStateCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkPipelineMultisampleStateCreateInfo-sampleShadingEnable-00784</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipelineSampleRateFeatureDisable</th><th>explicit</th><th>VkPipelineMultisampleStateCreateInfo</th><th>core</th><th> If the sample rate shading feature is not enabled, sampleShadingEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-conservativeRasterizationMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationConservativeStateCreateInfoEXT</th><th>(VK_EXT_conservative_rasterization)</th><th> conservativeRasterizationMode must be a valid VkConservativeRasterizationModeEXT value</th></tr>
<tr><th>VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-extraPrimitiveOverestimationSize-01769</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineRasterizationConservativeStateCreateInfoEXT</th><th>(VK_EXT_conservative_rasterization)</th><th> extraPrimitiveOverestimationSize must be in the range of 0.0 to VkPhysicalDeviceConservativeRasterizationPropertiesEXT::maxExtraPrimitiveOverestimationSize inclusive</th></tr>
<tr><th>VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationConservativeStateCreateInfoEXT</th><th>(VK_EXT_conservative_rasterization)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationConservativeStateCreateInfoEXT</th><th>(VK_EXT_conservative_rasterization)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkPipelineRasterizationDepthClipStateCreateInfoEXT-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationDepthClipStateCreateInfoEXT</th><th>(VK_EXT_depth_clip_enable)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineRasterizationDepthClipStateCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationDepthClipStateCreateInfoEXT</th><th>(VK_EXT_depth_clip_enable)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-cullMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>core</th><th> cullMode must be a valid combination of VkCullModeFlagBits values</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-depthClampEnable-00782</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>core</th><th> If the depth clamping feature is not enabled, depthClampEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-frontFace-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>core</th><th> frontFace must be a valid VkFrontFace value</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineRasterizationConservativeStateCreateInfoEXT, VkPipelineRasterizationDepthClipStateCreateInfoEXT, VkPipelineRasterizationStateRasterizationOrderAMD, or VkPipelineRasterizationStateStreamCreateInfoEXT</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01413</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>!(VK_NV_fill_rectangle)</th><th> If the non-solid fill modes feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01414</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>(VK_NV_fill_rectangle)</th><th> If the VK_NV_fill_rectangle extension is not enabled, polygonMode must not be VK_POLYGON_MODE_FILL_RECTANGLE_NV</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01507</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>(VK_NV_fill_rectangle)</th><th> If the non-solid fill modes feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL or VK_POLYGON_MODE_FILL_RECTANGLE_NV</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>core</th><th> polygonMode must be a valid VkPolygonMode value</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateRasterizationOrderAMD-rasterizationOrder-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateRasterizationOrderAMD</th><th>(VK_AMD_rasterization_order)</th><th> rasterizationOrder must be a valid VkRasterizationOrderAMD value</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateRasterizationOrderAMD-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateRasterizationOrderAMD</th><th>(VK_AMD_rasterization_order)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateStreamCreateInfoEXT</th><th>(VK_EXT_transform_feedback)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-geometryStreams-02324</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineRasterizationStateStreamCreateInfoEXT</th><th>(VK_EXT_transform_feedback)</th><th> VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams must be enabled</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-rasterizationStream-02325</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineRasterizationStateStreamCreateInfoEXT</th><th>(VK_EXT_transform_feedback)</th><th> rasterizationStream must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-rasterizationStream-02326</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineRasterizationStateStreamCreateInfoEXT</th><th>(VK_EXT_transform_feedback)</th><th> rasterizationStream must be zero if VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackRasterizationStreamSelect is VK_FALSE</th></tr>
<tr><th>VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineRasterizationStateStreamCreateInfoEXT</th><th>(VK_EXT_transform_feedback)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkPipelineRepresentativeFragmentTestStateCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineRepresentativeFragmentTestStateCreateInfoNV</th><th>(VK_NV_representative_fragment_test)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkPipelineSampleLocationsStateCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineSampleLocationsStateCreateInfoEXT</th><th>(VK_EXT_sample_locations)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkPipelineSampleLocationsStateCreateInfoEXT-sampleLocationsInfo-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineSampleLocationsStateCreateInfoEXT</th><th>(VK_EXT_sample_locations)</th><th> sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-maxClipDistances-00708</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If the identified entry point includes any variable in its interface that is declared with the ClipDistance BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxClipDistances</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-maxCombinedClipAndCullDistances-00710</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If the identified entry point includes any variables in its interface that are declared with the ClipDistance or CullDistance BuiltIn decoration, those variables must not have array sizes which sum to more than VkPhysicalDeviceLimits::maxCombinedClipAndCullDistances</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-maxCullDistances-00709</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If the identified entry point includes any variable in its interface that is declared with the CullDistance BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxCullDistances</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-maxSampleMaskWords-00711</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If the identified entry point includes any variable in its interface that is declared with the SampleMask BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxSampleMaskWords</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-module-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> module must be a valid VkShaderModule handle</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-pName-00707</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> pName must be the name of an OpEntryPoint in module with an execution model that matches stage</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-pName-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> pName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If pSpecializationInfo is not NULL, pSpecializationInfo must be a valid pointer to a valid VkSpecializationInfo structure</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-00704</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If the geometry shaders feature is not enabled, stage must not be VK_SHADER_STAGE_GEOMETRY_BIT</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-00705</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If the tessellation shaders feature is not enabled, stage must not be VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-00706</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> stage must not be VK_SHADER_STAGE_ALL_GRAPHICS, or VK_SHADER_STAGE_ALL</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-00712</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If stage is VK_SHADER_STAGE_VERTEX_BIT, the identified entry point must not include any input variable in its interface that is decorated with CullDistance</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-00713</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If stage is VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identified entry point has an OpExecutionMode instruction that specifies a patch size with OutputVertices, the patch size must be greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-00714</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If stage is VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must have an OpExecutionMode instruction that specifies a maximum output vertex count that is greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxGeometryOutputVertices</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-00715</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If stage is VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must have an OpExecutionMode instruction that specifies an invocation count that is greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxGeometryShaderInvocations</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-00718</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If stage is VK_SHADER_STAGE_FRAGMENT_BIT, the identified entry point must not include any output variables in its interface decorated with CullDistance</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-00719</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If stage is VK_SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to FragDepth in any execution path, it must write to FragDepth in all execution paths</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-01511</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>(VK_EXT_shader_stencil_export)</th><th> If stage is VK_SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to FragStencilRefEXT in any execution path, it must write to FragStencilRefEXT in all execution paths</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-02091</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>(VK_NV_mesh_shader)</th><th> If the mesh shader feature is not enabled, stage must not be VK_SHADER_STAGE_MESH_BIT_NV</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-02092</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>(VK_NV_mesh_shader)</th><th> If the task shader feature is not enabled, stage must not be VK_SHADER_STAGE_TASK_BIT_NV</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-02093</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>(VK_NV_mesh_shader)</th><th> If stage is VK_SHADER_STAGE_MESH_BIT_NV, the identified entry point must have an OpExecutionMode instruction that specifies a maximum output vertex count, OutputVertices, that is greater than 0 and less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputVertices.</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-02094</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>(VK_NV_mesh_shader)</th><th> If stage is VK_SHADER_STAGE_MESH_BIT_NV, the identified entry point must have an OpExecutionMode instruction that specifies a maximum output primitive count, OutputPrimitivesNV, that is greater than 0 and less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputPrimitives.</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-02596</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If stage is a vertex processing stage, and the identified entry point writes to Layer for any primitive, it must write the same value to Layer for all vertices of a given primitive</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-02597</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> If stage is a vertex processing stage, and the identified entry point writes to ViewportIndex for any primitive, it must write the same value to ViewportIndex for all vertices of a given primitive</th></tr>
<tr><th>VUID-VkPipelineShaderStageCreateInfo-stage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineShaderStageCreateInfo</th><th>core</th><th> stage must be a valid VkShaderStageFlagBits value</th></tr>
<tr><th>VUID-VkPipelineTessellationDomainOriginStateCreateInfo-domainOrigin-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineTessellationDomainOriginStateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> domainOrigin must be a valid VkTessellationDomainOrigin value</th></tr>
<tr><th>VUID-VkPipelineTessellationDomainOriginStateCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineTessellationDomainOriginStateCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineTessellationStateCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineTessellationStateCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineTessellationStateCreateInfo-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineTessellationStateCreateInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkPipelineTessellationDomainOriginStateCreateInfo</th></tr>
<tr><th>VUID-VkPipelineTessellationStateCreateInfo-patchControlPoints-01214</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineTessErrors</th><th>explicit</th><th>VkPipelineTessellationStateCreateInfo</th><th>core</th><th> patchControlPoints must be greater than zero and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize</th></tr>
<tr><th>VUID-VkPipelineTessellationStateCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineTessErrors</th><th>implicit</th><th>VkPipelineTessellationStateCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-pVertexBindingDivisors-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineVertexInputDivisorStateCreateInfoEXT</th><th>(VK_EXT_vertex_attribute_divisor)</th><th> pVertexBindingDivisors must be a valid pointer to an array of vertexBindingDivisorCount VkVertexInputBindingDivisorDescriptionEXT structures</th></tr>
<tr><th>VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineVertexInputDivisorStateCreateInfoEXT</th><th>(VK_EXT_vertex_attribute_divisor)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-vertexBindingDivisorCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineVertexInputDivisorStateCreateInfoEXT</th><th>(VK_EXT_vertex_attribute_divisor)</th><th> vertexBindingDivisorCount must be greater than 0</th></tr>
<tr><th>VUID-VkPipelineVertexInputStateCreateInfo-binding-00615</th><th><span style="color:limegreen;">Y</span></th><th>VUID_VkVertexInputAttributeDescription_binding_00621, VUID_VkVertexInputAttributeDescription_location_00620, InvalidVertexAttributeDescriptions</th><th>explicit</th><th>VkPipelineVertexInputStateCreateInfo</th><th>core</th><th> For every binding specified by each element of pVertexAttributeDescriptions, a VkVertexInputBindingDescription must exist in pVertexBindingDescriptions with the same value of binding</th></tr>
<tr><th>VUID-VkPipelineVertexInputStateCreateInfo-flags-zerobitmask</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineVertexInputStateCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineVertexInputStateCreateInfo-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineVertexInputStateCreateInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkPipelineVertexInputDivisorStateCreateInfoEXT</th></tr>
<tr><th>VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-00617</th><th><span style="color:limegreen;">Y</span></th><th>InvalidVertexAttributeDescriptions</th><th>explicit</th><th>VkPipelineVertexInputStateCreateInfo</th><th>core</th><th> All elements of pVertexAttributeDescriptions must describe distinct attribute locations</th></tr>
<tr><th>VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineVertexInputStateCreateInfo</th><th>core</th><th> If vertexAttributeDescriptionCount is not 0, pVertexAttributeDescriptions must be a valid pointer to an array of vertexAttributeDescriptionCount valid VkVertexInputAttributeDescription structures</th></tr>
<tr><th>VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-00616</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineAttribBindingConflict, InvalidVertexBindingDescriptions</th><th>explicit</th><th>VkPipelineVertexInputStateCreateInfo</th><th>core</th><th> All elements of pVertexBindingDescriptions must describe distinct binding numbers</th></tr>
<tr><th>VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineVertexInputStateCreateInfo</th><th>core</th><th> If vertexBindingDescriptionCount is not 0, pVertexBindingDescriptions must be a valid pointer to an array of vertexBindingDescriptionCount valid VkVertexInputBindingDescription structures</th></tr>
<tr><th>VUID-VkPipelineVertexInputStateCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineVertexInputStateCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineVertexInputStateCreateInfo-vertexAttributeDescriptionCount-00614</th><th><span style="color:limegreen;">Y</span></th><th>InvalidVertexAttributeDescriptions</th><th>explicit</th><th>VkPipelineVertexInputStateCreateInfo</th><th>core</th><th> vertexAttributeDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributes</th></tr>
<tr><th>VUID-VkPipelineVertexInputStateCreateInfo-vertexBindingDescriptionCount-00613</th><th><span style="color:limegreen;">Y</span></th><th>InvalidVertexBindingDescriptions</th><th>explicit</th><th>VkPipelineVertexInputStateCreateInfo</th><th>core</th><th> vertexBindingDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings</th></tr>
<tr><th>VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-pCustomSampleOrders-02234</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineViewportCoarseSampleOrderStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> The array pCustomSampleOrders must not contain two structures with matching values for both the shadingRate and sampleCount members.</th></tr>
<tr><th>VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-pCustomSampleOrders-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportCoarseSampleOrderStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> If customSampleOrderCount is not 0, pCustomSampleOrders must be a valid pointer to an array of customSampleOrderCount valid VkCoarseSampleOrderCustomNV structures</th></tr>
<tr><th>VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportCoarseSampleOrderStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-02072</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineViewportCoarseSampleOrderStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, customSamplerOrderCount must be 0</th></tr>
<tr><th>VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportCoarseSampleOrderStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> sampleOrderType must be a valid VkCoarseSampleOrderTypeNV value</th></tr>
<tr><th>VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02027</th><th><span style="color:limegreen;">Y</span></th><th>ExclusiveScissorNV</th><th>explicit</th><th>VkPipelineViewportExclusiveScissorStateCreateInfoNV</th><th>(VK_NV_scissor_exclusive)</th><th> If the multiple viewports feature is not enabled, exclusiveScissorCount must be 0 or 1</th></tr>
<tr><th>VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02028</th><th><span style="color:limegreen;">Y</span></th><th>ExclusiveScissorNV</th><th>explicit</th><th>VkPipelineViewportExclusiveScissorStateCreateInfoNV</th><th>(VK_NV_scissor_exclusive)</th><th> exclusiveScissorCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports</th></tr>
<tr><th>VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02029</th><th><span style="color:limegreen;">Y</span></th><th>ExclusiveScissorNV</th><th>explicit</th><th>VkPipelineViewportExclusiveScissorStateCreateInfoNV</th><th>(VK_NV_scissor_exclusive)</th><th> exclusiveScissorCount must be 0 or identical to the viewportCount member of VkPipelineViewportStateCreateInfo</th></tr>
<tr><th>VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-pDynamicStates-02030</th><th><span style="color:limegreen;">Y</span></th><th>ExclusiveScissorNV</th><th>explicit</th><th>VkPipelineViewportExclusiveScissorStateCreateInfoNV</th><th>(VK_NV_scissor_exclusive)</th><th> If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV and exclusiveScissorCount is not 0, pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures</th></tr>
<tr><th>VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-pExclusiveScissors-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportExclusiveScissorStateCreateInfoNV</th><th>(VK_NV_scissor_exclusive)</th><th> If exclusiveScissorCount is not 0, and pExclusiveScissors is not NULL, pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures</th></tr>
<tr><th>VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportExclusiveScissorStateCreateInfoNV</th><th>(VK_NV_scissor_exclusive)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-pDynamicStates-02057</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkPipelineViewportShadingRateImageStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV, pShadingRatePalettes must be a valid pointer to an array of viewportCount VkShadingRatePaletteNV structures</th></tr>
<tr><th>VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-pShadingRatePalettes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportShadingRateImageStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> If viewportCount is not 0, and pShadingRatePalettes is not NULL, pShadingRatePalettes must be a valid pointer to an array of viewportCount valid VkShadingRatePaletteNV structures</th></tr>
<tr><th>VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportShadingRateImageStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-shadingRateImageEnable-02056</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkPipelineViewportShadingRateImageStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> If shadingRateImageEnable is VK_TRUE, viewportCount must be equal to the viewportCount member of VkPipelineViewportStateCreateInfo</th></tr>
<tr><th>VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-viewportCount-02054</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkPipelineViewportShadingRateImageStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> If the multiple viewports feature is not enabled, viewportCount must be 0 or 1</th></tr>
<tr><th>VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-viewportCount-02055</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPipelineViewportShadingRateImageStateCreateInfoNV</th><th>(VK_NV_shading_rate_image)</th><th> viewportCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportShadingRateImageStateCreateInfoNV, VkPipelineViewportSwizzleStateCreateInfoNV, or VkPipelineViewportWScalingStateCreateInfoNV</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-scissorCount-01217</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV, PSOViewportStateTests</th><th>explicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> If the multiple viewports feature is not enabled, scissorCount must be 1</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-scissorCount-01219</th><th><span style="color:limegreen;">Y</span></th><th>PSOViewportStateMultiViewportTests</th><th>explicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-scissorCount-01220</th><th><span style="color:limegreen;">Y</span></th><th>PSOViewportStateMultiViewportTests, PSOViewportStateTests</th><th>explicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> scissorCount and viewportCount must be identical</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-scissorCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>PSOViewportStateMultiViewportTests</th><th>implicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> scissorCount must be greater than 0</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-viewportCount-01216</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV, PSOViewportStateTests</th><th>explicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> If the multiple viewports feature is not enabled, viewportCount must be 1</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-viewportCount-01218</th><th><span style="color:limegreen;">Y</span></th><th>PSOViewportStateMultiViewportTests</th><th>explicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-viewportCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>PSOViewportStateMultiViewportTests</th><th>implicit</th><th>VkPipelineViewportStateCreateInfo</th><th>core</th><th> viewportCount must be greater than 0</th></tr>
<tr><th>VUID-VkPipelineViewportStateCreateInfo-viewportWScalingEnable-01726</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPipelineViewportStateCreateInfo</th><th>(VK_NV_clip_space_w_scaling)</th><th> If the viewportWScalingEnable member of a VkPipelineViewportWScalingStateCreateInfoNV structure chained to the pNext chain is VK_TRUE, the viewportCount member of the VkPipelineViewportWScalingStateCreateInfoNV structure must be equal to viewportCount</th></tr>
<tr><th>VUID-VkPipelineViewportSwizzleStateCreateInfoNV-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportSwizzleStateCreateInfoNV</th><th>(VK_NV_viewport_swizzle)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkPipelineViewportSwizzleStateCreateInfoNV-pViewportSwizzles-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportSwizzleStateCreateInfoNV</th><th>(VK_NV_viewport_swizzle)</th><th> pViewportSwizzles must be a valid pointer to an array of viewportCount valid VkViewportSwizzleNV structures</th></tr>
<tr><th>VUID-VkPipelineViewportSwizzleStateCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportSwizzleStateCreateInfoNV</th><th>(VK_NV_viewport_swizzle)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkPipelineViewportSwizzleStateCreateInfoNV-viewportCount-01215</th><th><span style="color:limegreen;">Y</span></th><th>ViewportSwizzleNV</th><th>explicit</th><th>VkPipelineViewportSwizzleStateCreateInfoNV</th><th>(VK_NV_viewport_swizzle)</th><th> viewportCount must match the viewportCount set in VkPipelineViewportStateCreateInfo</th></tr>
<tr><th>VUID-VkPipelineViewportSwizzleStateCreateInfoNV-viewportCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportSwizzleStateCreateInfoNV</th><th>(VK_NV_viewport_swizzle)</th><th> viewportCount must be greater than 0</th></tr>
<tr><th>VUID-VkPipelineViewportWScalingStateCreateInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportWScalingStateCreateInfoNV</th><th>(VK_NV_clip_space_w_scaling)</th><th> sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkPipelineViewportWScalingStateCreateInfoNV-viewportCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPipelineViewportWScalingStateCreateInfoNV</th><th>(VK_NV_clip_space_w_scaling)</th><th> viewportCount must be greater than 0</th></tr>
<tr><th>VUID-VkPresentFrameTokenGGP-frameToken-02680</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPresentFrameTokenGGP</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GGP_frame_token)</th><th> frameToken must be a valid GgpFrameToken</th></tr>
<tr><th>VUID-VkPresentFrameTokenGGP-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPresentFrameTokenGGP</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GGP_frame_token)</th><th> sType must be VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP</th></tr>
<tr><th>VUID-VkPresentInfoKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> Both of the elements of pSwapchains, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-VkPresentInfoKHR-pImageIndices-01296</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+!(VK_KHR_shared_presentable_image)</th><th> Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR layout at the time the operation is executed on a VkDevice</th></tr>
<tr><th>VUID-VkPresentInfoKHR-pImageIndices-01430</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)</th><th> Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout at the time the operation is executed on a VkDevice</th></tr>
<tr><th>VUID-VkPresentInfoKHR-pImageIndices-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> pImageIndices must be a valid pointer to an array of swapchainCount uint32_t values</th></tr>
<tr><th>VUID-VkPresentInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupPresentInfoKHR, VkDisplayPresentInfoKHR, VkPresentFrameTokenGGP, VkPresentRegionsKHR, or VkPresentTimesInfoGOOGLE</th></tr>
<tr><th>VUID-VkPresentInfoKHR-pResults-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If pResults is not NULL, pResults must be a valid pointer to an array of swapchainCount VkResult values</th></tr>
<tr><th>VUID-VkPresentInfoKHR-pSwapchains-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> pSwapchains must be a valid pointer to an array of swapchainCount valid VkSwapchainKHR handles</th></tr>
<tr><th>VUID-VkPresentInfoKHR-pWaitSemaphores-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles</th></tr>
<tr><th>VUID-VkPresentInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> sType must be VK_STRUCTURE_TYPE_PRESENT_INFO_KHR</th></tr>
<tr><th>VUID-VkPresentInfoKHR-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkPresentInfoKHR-swapchainCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> swapchainCount must be greater than 0</th></tr>
<tr><th>VUID-VkPresentRegionKHR-pRectangles-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPresentRegionKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present)</th><th> If rectangleCount is not 0, and pRectangles is not NULL, pRectangles must be a valid pointer to an array of rectangleCount valid VkRectLayerKHR structures</th></tr>
<tr><th>VUID-VkPresentRegionsKHR-pRegions-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentRegionsKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present)</th><th> If pRegions is not NULL, pRegions must be a valid pointer to an array of swapchainCount valid VkPresentRegionKHR structures</th></tr>
<tr><th>VUID-VkPresentRegionsKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPresentRegionsKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present)</th><th> sType must be VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR</th></tr>
<tr><th>VUID-VkPresentRegionsKHR-swapchainCount-01260</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkPresentRegionsKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present)</th><th> swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where VkPresentInfoKHR is in the pNext chain of this VkPresentRegionsKHR structure</th></tr>
<tr><th>VUID-VkPresentRegionsKHR-swapchainCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentRegionsKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present)</th><th> swapchainCount must be greater than 0</th></tr>
<tr><th>VUID-VkPresentTimesInfoGOOGLE-pTimes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentTimesInfoGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> If pTimes is not NULL, pTimes must be a valid pointer to an array of swapchainCount VkPresentTimeGOOGLE structures</th></tr>
<tr><th>VUID-VkPresentTimesInfoGOOGLE-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPresentTimesInfoGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> sType must be VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE</th></tr>
<tr><th>VUID-VkPresentTimesInfoGOOGLE-swapchainCount-01247</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPresentTimesInfoGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where VkPresentInfoKHR is in the pNext chain of this VkPresentTimesInfoGOOGLE structure.</th></tr>
<tr><th>VUID-VkPresentTimesInfoGOOGLE-swapchainCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPresentTimesInfoGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> swapchainCount must be greater than 0</th></tr>
<tr><th>VUID-VkProtectedSubmitInfo-pNext-01819</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkProtectedSubmitInfo</th><th>(VK_VERSION_1_1)</th><th> If the VkSubmitInfo::pNext chain does not include a VkProtectedSubmitInfo structure, then each element of the command buffer of the pCommandBuffers array must be an unprotected command buffer.</th></tr>
<tr><th>VUID-VkProtectedSubmitInfo-protectedSubmit-01816</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkProtectedSubmitInfo</th><th>(VK_VERSION_1_1)</th><th> If the protected memory feature is not enabled, protectedSubmit must not be VK_TRUE.</th></tr>
<tr><th>VUID-VkProtectedSubmitInfo-protectedSubmit-01817</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkProtectedSubmitInfo</th><th>(VK_VERSION_1_1)</th><th> If protectedSubmit is VK_TRUE, then each element of the pCommandBuffers array must be a protected command buffer.</th></tr>
<tr><th>VUID-VkProtectedSubmitInfo-protectedSubmit-01818</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkProtectedSubmitInfo</th><th>(VK_VERSION_1_1)</th><th> If protectedSubmit is VK_FALSE, then each element of the pCommandBuffers array must be an unprotected command buffer.</th></tr>
<tr><th>VUID-VkProtectedSubmitInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkProtectedSubmitInfo</th><th>(VK_VERSION_1_1)</th><th> sType must be VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO</th></tr>
<tr><th>VUID-VkPushConstantRange-offset-00294</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPushConstantRange</th><th>core</th><th> offset must be less than VkPhysicalDeviceLimits::maxPushConstantsSize</th></tr>
<tr><th>VUID-VkPushConstantRange-offset-00295</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPushConstantRange</th><th>core</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-VkPushConstantRange-size-00296</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPushConstantRange</th><th>core</th><th> size must be greater than 0</th></tr>
<tr><th>VUID-VkPushConstantRange-size-00297</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPushConstantRange</th><th>core</th><th> size must be a multiple of 4</th></tr>
<tr><th>VUID-VkPushConstantRange-size-00298</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkPushConstantRange</th><th>core</th><th> size must be less than or equal to VkPhysicalDeviceLimits::maxPushConstantsSize minus offset</th></tr>
<tr><th>VUID-VkPushConstantRange-stageFlags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkPushConstantRange</th><th>core</th><th> stageFlags must be a valid combination of VkShaderStageFlagBits values</th></tr>
<tr><th>VUID-VkPushConstantRange-stageFlags-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkPushConstantRange</th><th>core</th><th> stageFlags must not be 0</th></tr>
<tr><th>VUID-VkQueryPoolCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkQueryPoolCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkQueryPoolCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkQueryPoolCreateInfo</th><th>core</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkQueryPoolCreateInfo-queryType-00791</th><th><span style="color:limegreen;">Y</span></th><th>InvalidQueryPoolCreate</th><th>explicit</th><th>VkQueryPoolCreateInfo</th><th>core</th><th> If the pipeline statistics queries feature is not enabled, queryType must not be VK_QUERY_TYPE_PIPELINE_STATISTICS</th></tr>
<tr><th>VUID-VkQueryPoolCreateInfo-queryType-00792</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkQueryPoolCreateInfo</th><th>core</th><th> If queryType is VK_QUERY_TYPE_PIPELINE_STATISTICS, pipelineStatistics must be a valid combination of VkQueryPipelineStatisticFlagBits values</th></tr>
<tr><th>VUID-VkQueryPoolCreateInfo-queryType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkQueryPoolCreateInfo</th><th>core</th><th> queryType must be a valid VkQueryType value</th></tr>
<tr><th>VUID-VkQueryPoolCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkQueryPoolCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO</th></tr>
<tr><th>VUID-VkQueueFamilyCheckpointPropertiesNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkQueueFamilyCheckpointPropertiesNV</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_NV_device_diagnostic_checkpoints)</th><th> sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV</th></tr>
<tr><th>VUID-VkQueueFamilyProperties2-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkQueueFamilyProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pNext must be NULL or a pointer to a valid instance of VkQueueFamilyCheckpointPropertiesNV</th></tr>
<tr><th>VUID-VkQueueFamilyProperties2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkQueueFamilyProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> Both of basePipelineHandle, and layout that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-flags-02404</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a ray tracing VkPipeline</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-flags-02405</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-flags-02406</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-flags-02407</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> flags must be a valid combination of VkPipelineCreateFlagBits values</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-groupCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> groupCount must be greater than 0</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-layout-02410</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> layout must be consistent with all shaders specified in pStages</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-layout-02411</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> The number of resources in layout accessible to each shader stage that is used by the pipeline must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-layout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> layout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-maxRecursionDepth-02412</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> maxRecursionDepth must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxRecursionDepth</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-pGroups-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> pGroups must be a valid pointer to an array of groupCount valid VkRayTracingShaderGroupCreateInfoNV structures</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> pNext must be NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfoEXT</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-pStages-02409</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> The shader code for the entry points identified by pStages, and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-pStages-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-stage-02408</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> The stage member of one element of pStages must be VK_SHADER_STAGE_RAYGEN_BIT_NV</th></tr>
<tr><th>VUID-VkRayTracingPipelineCreateInfoNV-stageCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingPipelineCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> stageCount must be greater than 0</th></tr>
<tr><th>VUID-VkRayTracingShaderGroupCreateInfoNV-anyHitShader-02418</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingShaderGroupCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> anyHitShader must be either VK_SHADER_UNUSED_NV or a valid index into pStages referring to a shader of VK_SHADER_STAGE_ANY_HIT_BIT_NV</th></tr>
<tr><th>VUID-VkRayTracingShaderGroupCreateInfoNV-closestHitShader-02417</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingShaderGroupCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> closestHitShader must be either VK_SHADER_UNUSED_NV or a valid index into pStages referring to a shader of VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV</th></tr>
<tr><th>VUID-VkRayTracingShaderGroupCreateInfoNV-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingShaderGroupCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkRayTracingShaderGroupCreateInfoNV-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingShaderGroupCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV</th></tr>
<tr><th>VUID-VkRayTracingShaderGroupCreateInfoNV-type-02413</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingShaderGroupCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then generalShader must be a valid index into pStages referring to a shader of VK_SHADER_STAGE_RAYGEN_BIT_NV, VK_SHADER_STAGE_MISS_BIT_NV, or VK_SHADER_STAGE_CALLABLE_BIT_NV</th></tr>
<tr><th>VUID-VkRayTracingShaderGroupCreateInfoNV-type-02414</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingShaderGroupCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then closestHitShader, anyHitShader, and intersectionShader must be VK_SHADER_UNUSED_NV</th></tr>
<tr><th>VUID-VkRayTracingShaderGroupCreateInfoNV-type-02415</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingShaderGroupCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV then intersectionShader must be a valid index into pStages referring to a shader of VK_SHADER_STAGE_INTERSECTION_BIT_NV</th></tr>
<tr><th>VUID-VkRayTracingShaderGroupCreateInfoNV-type-02416</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRayTracingShaderGroupCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV then intersectionShader must be VK_SHADER_UNUSED_NV</th></tr>
<tr><th>VUID-VkRayTracingShaderGroupCreateInfoNV-type-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRayTracingShaderGroupCreateInfoNV</th><th>(VK_NV_ray_tracing)</th><th> type must be a valid VkRayTracingShaderGroupTypeNV value</th></tr>
<tr><th>VUID-VkRectLayerKHR-layer-01262</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkRectLayerKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present)</th><th> layer must be less than imageArrayLayers member of the VkSwapchainCreateInfoKHR structure given to vkCreateSwapchainKHR.</th></tr>
<tr><th>VUID-VkRectLayerKHR-offset-01261</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkRectLayerKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present)</th><th> The sum of offset and extent must be no greater than the imageExtent member of the VkSwapchainCreateInfoKHR structure given to vkCreateSwapchainKHR.</th></tr>
<tr><th>VUID-VkRenderPassBeginInfo-clearValueCount-00902</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginClearOpMismatch</th><th>explicit</th><th>VkRenderPassBeginInfo</th><th>core</th><th> clearValueCount must be greater than the largest attachment index in renderPass that specifies a loadOp (or stencilLoadOp, if the attachment has a depth/stencil format) of VK_ATTACHMENT_LOAD_OP_CLEAR</th></tr>
<tr><th>VUID-VkRenderPassBeginInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassBeginInfo</th><th>core</th><th> Both of framebuffer, and renderPass must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkRenderPassBeginInfo-framebuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassMissingAttachment</th><th>implicit</th><th>VkRenderPassBeginInfo</th><th>core</th><th> framebuffer must be a valid VkFramebuffer handle</th></tr>
<tr><th>VUID-VkRenderPassBeginInfo-pClearValues-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassBeginInfo</th><th>core</th><th> If clearValueCount is not 0, pClearValues must be a valid pointer to an array of clearValueCount VkClearValue unions</th></tr>
<tr><th>VUID-VkRenderPassBeginInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassBeginInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupRenderPassBeginInfo or VkRenderPassSampleLocationsBeginInfoEXT</th></tr>
<tr><th>VUID-VkRenderPassBeginInfo-renderPass-00904</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginIncompatibleFramebufferRenderPass</th><th>explicit</th><th>VkRenderPassBeginInfo</th><th>core</th><th> renderPass must be compatible with the renderPass member of the VkFramebufferCreateInfo structure specified when creating framebuffer.</th></tr>
<tr><th>VUID-VkRenderPassBeginInfo-renderPass-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassBeginInfo</th><th>core</th><th> renderPass must be a valid VkRenderPass handle</th></tr>
<tr><th>VUID-VkRenderPassBeginInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassBeginInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO</th></tr>
<tr><th>VUID-VkRenderPassBeginInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkRenderPassBeginInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-attachment-00834</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentIndexOutOfRange</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or any element of pPreserveAttachments in any element of pSubpasses is not VK_ATTACHMENT_UNUSED, it must be less than attachmentCount</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-dstSubpass-02518</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> The dstSubpass member of each element of pDependencies must be less than subpassCount</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pAttachments-00836</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentReadOnlyButCleared</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL.</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pAttachments-01566</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentReadOnlyButCleared</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL.</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pAttachments-01567</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentReadOnlyButCleared</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL.</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pAttachments-02511</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL.</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkAttachmentDescription structures</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pDependencies-00837</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> For any element of pDependencies, if the srcSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the srcStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pDependencies-00838</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> For any element of pDependencies, if the dstSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the dstStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pDependencies-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> If dependencyCount is not 0, pDependencies must be a valid pointer to an array of dependencyCount valid VkSubpassDependency structures</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-01926</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidInputAttachmentReferences</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If the pNext chain includes an instance of VkRenderPassInputAttachmentAspectCreateInfo, the subpass member of each element of its pAspectReferences member must be less than subpassCount</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-01927</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidInputAttachmentReferences</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If the pNext chain includes an instance of VkRenderPassInputAttachmentAspectCreateInfo, the inputAttachmentIndex member of each element of its pAspectReferences member must be less than the value of inputAttachmentCount in the member of pSubpasses identified by its subpass member</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-01928</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidViewMasks</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, and its subpassCount member is not zero, that member must be equal to the value of subpassCount</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-01929</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, if its dependencyCount member is not zero, it must be equal to dependencyCount</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-01930</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, for each non-zero element of pViewOffsets, the srcSubpass and dstSubpass members of pDependencies at the same index must not be equal</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-01963</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidInputAttachmentReferences</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If the pNext chain includes an instance of VkRenderPassInputAttachmentAspectCreateInfo, for any element of the pInputAttachments member of any element of pSubpasses where the attachment member is not VK_ATTACHMENT_UNUSED, the aspectMask member of the corresponding element of VkRenderPassInputAttachmentAspectCreateInfo::pAspectReferences must only include aspects that are present in images of the format specified by the element of pAttachments at attachment</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-02512</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, for any element of pDependencies with a dependencyFlags member that does not include VK_DEPENDENCY_VIEW_LOCAL_BIT, the corresponding element of the pViewOffsets member of that VkRenderPassMultiviewCreateInfo instance must be 0</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-02513</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, elements of its pViewMasks member must either all be 0, or all not be 0</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-02514</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, and each element of its pViewMasks member is 0, the dependencyFlags member of each element of pDependencies must not include VK_DEPENDENCY_VIEW_LOCAL_BIT</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-02515</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, and each element of its pViewMasks member is 0, correlatedViewMaskCount must be 0</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-02516</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, each element of its pViewMask member must not include a bit at a position greater than the value of VkPhysicalDeviceLimits::maxFramebufferLayers</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkRenderPassFragmentDensityMapCreateInfoEXT, VkRenderPassInputAttachmentAspectCreateInfo, or VkRenderPassMultiviewCreateInfo</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-pSubpasses-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> pSubpasses must be a valid pointer to an array of subpassCount valid VkSubpassDescription structures</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-srcSubpass-02517</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> The srcSubpass member of each element of pDependencies must be less than subpassCount</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo-subpassCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo</th><th>core</th><th> subpassCount must be greater than 0</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-None-03049</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If any two subpasses operate on attachments with overlapping ranges of the same VkDeviceMemory object, and at least one subpass writes to that area of VkDeviceMemory, a subpass dependency must be included (either directly or via some intermediate subpasses) between them</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-attachment-02525</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If the attachment member of any element of the pInputAttachments member of any element of pSubpasses is not VK_ATTACHMENT_UNUSED, the aspectMask member of that element of pInputAttachments must only include aspects that are present in images of the format specified by the element of pAttachments specified by attachment</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-attachment-03050</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or the attachment indexed by any element of pPreserveAttachments in any given element of pSubpasses is bound to a range of a VkDeviceMemory object that overlaps with any other attachment in any subpass (including the same subpass), the VkAttachmentDescription2KHR structures describing them must include VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT in flags</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-attachment-03051</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentIndexOutOfRange</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or any element of pPreserveAttachments in any given element of pSubpasses is not VK_ATTACHMENT_UNUSED, it must be less than attachmentCount</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-dstSubpass-02527</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The dstSubpass member of each element of pDependencies must be less than subpassCount</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pAttachments-02522</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentReadOnlyButCleared</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pAttachments-02523</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL.</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkAttachmentDescription2KHR structures</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pCorrelatedViewMasks-03056</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateOverlappingCorrelationMasks</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The set of bits included in any element of pCorrelatedViewMasks must not overlap with the set of bits included in any other element of pCorrelatedViewMasks</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pCorrelatedViewMasks-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If correlatedViewMaskCount is not 0, pCorrelatedViewMasks must be a valid pointer to an array of correlatedViewMaskCount uint32_t values</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pDependencies-03054</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> For any element of pDependencies, if the srcSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the srcStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass.</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pDependencies-03055</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> For any element of pDependencies, if the dstSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the dstStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass.</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pDependencies-03060</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> For any element of pDependencies where its srcSubpass member equals its dstSubpass member, if the viewMask member of the corresponding element of pSubpasses includes more than one bit, its dependencyFlags member must include VK_DEPENDENCY_VIEW_LOCAL_BIT</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pDependencies-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If dependencyCount is not 0, pDependencies must be a valid pointer to an array of dependencyCount valid VkSubpassDependency2KHR structures</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-pSubpasses-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pSubpasses must be a valid pointer to an array of subpassCount valid VkSubpassDescription2KHR structures</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-srcSubpass-02526</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The srcSubpass member of each element of pDependencies must be less than subpassCount</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-subpassCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> subpassCount must be greater than 0</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-viewMask-02524</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The viewMask member must not include a bit at a position greater than the value of VkPhysicalDeviceLimits::maxFramebufferLayers</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-viewMask-03057</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateOverlappingCorrelationMasks</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If the VkSubpassDescription2KHR::viewMask member of all elements of pSubpasses is 0, correlatedViewMaskCount must be 0</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-viewMask-03058</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidViewMasks</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The VkSubpassDescription2KHR::viewMask member of all elements of pSubpasses must either all be 0, or all not be 0</th></tr>
<tr><th>VUID-VkRenderPassCreateInfo2KHR-viewMask-03059</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkRenderPassCreateInfo2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If the VkSubpassDescription2KHR::viewMask member of all elements of pSubpasses is 0, the dependencyFlags member of any element of pDependencies must not include VK_DEPENDENCY_VIEW_LOCAL_BIT</th></tr>
<tr><th>VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02547</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassFragmentDensityMapCreateInfoEXT</th><th>(VK_EXT_fragment_density_map)</th><th> If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must be less than VkRenderPassCreateInfo::attachmentCount</th></tr>
<tr><th>VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassFragmentDensityMapCreateInfoEXT</th><th>(VK_EXT_fragment_density_map)</th><th> If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must not be an element of VkSubpassDescription::pInputAttachments, VkSubpassDescription::pColorAttachments, VkSubpassDescription::pResolveAttachments, VkSubpassDescription::pDepthStencilAttachment, or VkSubpassDescription::pPreserveAttachments for any subpass</th></tr>
<tr><th>VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02549</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassFragmentDensityMapCreateInfoEXT</th><th>(VK_EXT_fragment_density_map)</th><th> If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, layout must be equal to VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT, or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02550</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassFragmentDensityMapCreateInfoEXT</th><th>(VK_EXT_fragment_density_map)</th><th> If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must reference an attachment with a loadOp equal to VK_ATTACHMENT_LOAD_OP_LOAD or VK_ATTACHMENT_LOAD_OP_DONT_CARE.</th></tr>
<tr><th>VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02551</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkRenderPassFragmentDensityMapCreateInfoEXT</th><th>(VK_EXT_fragment_density_map)</th><th> If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must reference an attachment with a storeOp equal to VK_ATTACHMENT_STORE_OP_DONT_CARE.</th></tr>
<tr><th>VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkRenderPassFragmentDensityMapCreateInfoEXT</th><th>(VK_EXT_fragment_density_map)</th><th> fragmentDensityMapAttachment must be a valid VkAttachmentReference structure</th></tr>
<tr><th>VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkRenderPassFragmentDensityMapCreateInfoEXT</th><th>(VK_EXT_fragment_density_map)</th><th> sType must be VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkRenderPassInputAttachmentAspectCreateInfo-aspectReferenceCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassInputAttachmentAspectCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> aspectReferenceCount must be greater than 0</th></tr>
<tr><th>VUID-VkRenderPassInputAttachmentAspectCreateInfo-pAspectReferences-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassInputAttachmentAspectCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> pAspectReferences must be a valid pointer to an array of aspectReferenceCount valid VkInputAttachmentAspectReference structures</th></tr>
<tr><th>VUID-VkRenderPassInputAttachmentAspectCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkRenderPassInputAttachmentAspectCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> sType must be VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO</th></tr>
<tr><th>VUID-VkRenderPassMultiviewCreateInfo-pCorrelationMasks-00841</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateOverlappingCorrelationMasks</th><th>explicit</th><th>VkRenderPassMultiviewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> Each view index must not be set in more than one element of pCorrelationMasks</th></tr>
<tr><th>VUID-VkRenderPassMultiviewCreateInfo-pCorrelationMasks-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassMultiviewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If correlationMaskCount is not 0, pCorrelationMasks must be a valid pointer to an array of correlationMaskCount uint32_t values</th></tr>
<tr><th>VUID-VkRenderPassMultiviewCreateInfo-pViewMasks-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassMultiviewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If subpassCount is not 0, pViewMasks must be a valid pointer to an array of subpassCount uint32_t values</th></tr>
<tr><th>VUID-VkRenderPassMultiviewCreateInfo-pViewOffsets-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassMultiviewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If dependencyCount is not 0, pViewOffsets must be a valid pointer to an array of dependencyCount int32_t values</th></tr>
<tr><th>VUID-VkRenderPassMultiviewCreateInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkRenderPassMultiviewCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> sType must be VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO</th></tr>
<tr><th>VUID-VkRenderPassSampleLocationsBeginInfoEXT-pAttachmentInitialSampleLocations-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassSampleLocationsBeginInfoEXT</th><th>(VK_EXT_sample_locations)</th><th> If attachmentInitialSampleLocationsCount is not 0, pAttachmentInitialSampleLocations must be a valid pointer to an array of attachmentInitialSampleLocationsCount valid VkAttachmentSampleLocationsEXT structures</th></tr>
<tr><th>VUID-VkRenderPassSampleLocationsBeginInfoEXT-pPostSubpassSampleLocations-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkRenderPassSampleLocationsBeginInfoEXT</th><th>(VK_EXT_sample_locations)</th><th> If postSubpassSampleLocationsCount is not 0, pPostSubpassSampleLocations must be a valid pointer to an array of postSubpassSampleLocationsCount valid VkSubpassSampleLocationsEXT structures</th></tr>
<tr><th>VUID-VkRenderPassSampleLocationsBeginInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkRenderPassSampleLocationsBeginInfoEXT</th><th>(VK_EXT_sample_locations)</th><th> sType must be VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT</th></tr>
<tr><th>VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSampleLocationsInfoEXT</th><th>(VK_EXT_sample_locations)</th><th> If sampleLocationsCount is not 0, pSampleLocations must be a valid pointer to an array of sampleLocationsCount VkSampleLocationEXT structures</th></tr>
<tr><th>VUID-VkSampleLocationsInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSampleLocationsInfoEXT</th><th>(VK_EXT_sample_locations)</th><th> sType must be VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT</th></tr>
<tr><th>VUID-VkSampleLocationsInfoEXT-sampleLocationsCount-01527</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSampleLocationsInfoEXT</th><th>(VK_EXT_sample_locations)</th><th> sampleLocationsCount must equal sampleLocationsPerPixel {times} sampleLocationGridSize.width {times} sampleLocationGridSize.height</th></tr>
<tr><th>VUID-VkSampleLocationsInfoEXT-sampleLocationsPerPixel-01526</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSampleLocationsInfoEXT</th><th>(VK_EXT_sample_locations)</th><th> sampleLocationsPerPixel must be a bit value that is set in VkPhysicalDeviceSampleLocationsPropertiesEXT::sampleLocationSampleCounts</th></tr>
<tr><th>VUID-VkSampleLocationsInfoEXT-sampleLocationsPerPixel-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSampleLocationsInfoEXT</th><th>(VK_EXT_sample_locations)</th><th> If sampleLocationsPerPixel is not 0, sampleLocationsPerPixel must be a valid VkSampleCountFlagBits value</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-None-01647</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_EXT_sampler_filter_minmax)</th><th> The sampler reduction mode must be set to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT if sampler Y'CBCR conversion is enabled</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-addressModeU-01078</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If any of addressModeU, addressModeV or addressModeW are VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, borderColor must be a valid VkBorderColor value</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-addressModeU-01079</th><th><span style="color:limegreen;">Y</span></th><th>MirrorClampToEdgeNotEnabled</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If the VK_KHR_sampler_mirror_clamp_to_edge extension is not enabled, addressModeU, addressModeV and addressModeW must not be VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-addressModeU-01646</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If sampler Y'CBCR conversion is enabled, addressModeU, addressModeV, and addressModeW must be VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, anisotropyEnable must be VK_FALSE, and unnormalizedCoordinates must be VK_FALSE</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-addressModeU-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> addressModeU must be a valid VkSamplerAddressMode value</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-addressModeV-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> addressModeV must be a valid VkSamplerAddressMode value</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-addressModeW-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> addressModeW must be a valid VkSamplerAddressMode value</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-anisotropyEnable-01070</th><th><span style="color:limegreen;">Y</span></th><th>AnisotropyFeatureDisabled</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If the anisotropic sampling feature is not enabled, anisotropyEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-anisotropyEnable-01071</th><th><span style="color:limegreen;">Y</span></th><th>AnisotropyFeatureEnabled</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If anisotropyEnable is VK_TRUE, maxAnisotropy must be between 1.0 and VkPhysicalDeviceLimits::maxSamplerAnisotropy, inclusive</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-compareEnable-01080</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If compareEnable is VK_TRUE, compareOp must be a valid VkCompareOp value</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-compareEnable-01423</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_EXT_sampler_filter_minmax)</th><th> If compareEnable is VK_TRUE, the reductionMode member of VkSamplerReductionModeCreateInfoEXT must be VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-flags-02574</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then minFilter and magFilter must be equal.</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-flags-02575</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST.</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-flags-02576</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then minLod and maxLod must be zero.</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-flags-02577</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then addressModeU and addressModeV must each be either VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER.</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-flags-02578</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then anisotropyEnable must be VK_FALSE.</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-flags-02579</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then compareEnable must be VK_FALSE.</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-flags-02580</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_EXT_fragment_density_map)</th><th> If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then unnormalizedCoordinates must be VK_FALSE.</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> flags must be a valid combination of VkSamplerCreateFlagBits values</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-magFilter-01081</th><th><span style="color:limegreen;">Y</span></th><th>AnisotropyFeatureEnabled</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If either magFilter or minFilter is VK_FILTER_CUBIC_EXT, anisotropyEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-magFilter-01422</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_IMG_filter_cubic+VK_EXT_sampler_filter_minmax)+!(VK_EXT_filter_cubic)</th><th> If either magFilter or minFilter is VK_FILTER_CUBIC_EXT, the reductionMode member of VkSamplerReductionModeCreateInfoEXT must be VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-magFilter-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> magFilter must be a valid VkFilter value</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-maxLod-01973</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> maxLod must be greater than or equal to minLod</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-minFilter-01645</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If sampler Y'CBCR conversion is enabled and VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT is not set for the format, minFilter and magFilter must be equal to the sampler Y'CBCR conversion's chromaFilter</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-minFilter-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> minFilter must be a valid VkFilter value</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-mipLodBias-01069</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> The absolute value of mipLodBias must be less than or equal to VkPhysicalDeviceLimits::maxSamplerLodBias</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-mipmapMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> mipmapMode must be a valid VkSamplerMipmapMode value</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkSamplerReductionModeCreateInfoEXT or VkSamplerYcbcrConversionInfo</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01072</th><th><span style="color:limegreen;">Y</span></th><th>UnnormalizedCoordinatesEnabled</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If unnormalizedCoordinates is VK_TRUE, minFilter and magFilter must be equal</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01073</th><th><span style="color:limegreen;">Y</span></th><th>UnnormalizedCoordinatesEnabled</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If unnormalizedCoordinates is VK_TRUE, mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01074</th><th><span style="color:limegreen;">Y</span></th><th>UnnormalizedCoordinatesEnabled</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If unnormalizedCoordinates is VK_TRUE, minLod and maxLod must be zero</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01075</th><th><span style="color:limegreen;">Y</span></th><th>UnnormalizedCoordinatesEnabled</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If unnormalizedCoordinates is VK_TRUE, addressModeU and addressModeV must each be either VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01076</th><th><span style="color:limegreen;">Y</span></th><th>AnisotropyFeatureEnabled</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If unnormalizedCoordinates is VK_TRUE, anisotropyEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01077</th><th><span style="color:limegreen;">Y</span></th><th>UnnormalizedCoordinatesEnabled</th><th>explicit</th><th>VkSamplerCreateInfo</th><th>core</th><th> If unnormalizedCoordinates is VK_TRUE, compareEnable must be VK_FALSE</th></tr>
<tr><th>VUID-VkSamplerReductionModeCreateInfoEXT-reductionMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerReductionModeCreateInfoEXT</th><th>(VK_EXT_sampler_filter_minmax)</th><th> reductionMode must be a valid VkSamplerReductionModeEXT value</th></tr>
<tr><th>VUID-VkSamplerReductionModeCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSamplerReductionModeCreateInfoEXT</th><th>(VK_EXT_sampler_filter_minmax)</th><th> sType must be VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-01657</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the format does not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT, chromaFilter must be VK_FILTER_NEAREST</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> chromaFilter must be a valid VkFilter value</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-components-02581</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the format has a _422 or _420 suffix, then components.g must be VK_COMPONENT_SWIZZLE_IDENTITY</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-components-02582</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the format has a _422 or _420 suffix, then components.a must be VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_ONE, or VK_COMPONENT_SWIZZLE_ZERO</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-components-02583</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the format has a _422 or _420 suffix, then components.r must be VK_COMPONENT_SWIZZLE_IDENTITY or VK_COMPONENT_SWIZZLE_B</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-components-02584</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the format has a _422 or _420 suffix, then components.b must be VK_COMPONENT_SWIZZLE_IDENTITY or VK_COMPONENT_SWIZZLE_R</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-components-02585</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the format has a _422 or _420 suffix, and if either components.r or components.b is VK_COMPONENT_SWIZZLE_IDENTITY, both values must be VK_COMPONENT_SWIZZLE_IDENTITY</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-components-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> components must be a valid VkComponentMapping structure</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-forceExplicitReconstruction-01656</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the format does not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT, forceExplicitReconstruction must be FALSE</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-format-01649</th><th><span style="color:limegreen;">Y</span></th><th>CreateYCbCrSampler</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+!(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> format must not be VK_FORMAT_UNDEFINED</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-format-01650</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> format must support VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT or VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-format-01653</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> format must represent unsigned normalized values (i.e. the format must be a UNORM format)</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-format-01904</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferCreateYCbCrSampler</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If an external format conversion is being created, format must be VK_FORMAT_UNDEFINED, otherwise it must not be VK_FORMAT_UNDEFINED.</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> pNext must be NULL or a pointer to a valid instance of VkExternalFormatANDROID</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-01651</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the format does not support VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT, xChromaOffset and yChromaOffset must not be VK_CHROMA_LOCATION_COSITED_EVEN</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-01652</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the format does not support VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT, xChromaOffset and yChromaOffset must not be VK_CHROMA_LOCATION_MIDPOINT</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> xChromaOffset must be a valid VkChromaLocation value</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-yChromaOffset-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> yChromaOffset must be a valid VkChromaLocation value</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrModel-01655</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If ycbcrModel is not VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY, then components.r, components.g, and components.b must correspond to channels of the format; that is, components.r, components.g, and components.b must not be VK_COMPONENT_SWIZZLE_ZERO or VK_COMPONENT_SWIZZLE_ONE, and must not correspond to a channel which contains zero or one as a consequence of conversion to RGBA</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrModel-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> ycbcrModel must be a valid VkSamplerYcbcrModelConversion value</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrRange-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionCreateInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> ycbcrRange must be a valid VkSamplerYcbcrRange value</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionImageFormatProperties-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionImageFormatProperties</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionInfo-conversion-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> conversion must be a valid VkSamplerYcbcrConversion handle</th></tr>
<tr><th>VUID-VkSamplerYcbcrConversionInfo-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSamplerYcbcrConversionInfo</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO</th></tr>
<tr><th>VUID-VkSemaphoreCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkSemaphoreCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreCreateInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportSemaphoreCreateInfo or VkExportSemaphoreWin32HandleInfoKHR</th></tr>
<tr><th>VUID-VkSemaphoreCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO</th></tr>
<tr><th>VUID-VkSemaphoreCreateInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSemaphoreCreateInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkSemaphoreGetFdInfoKHR-handleType-01132</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when semaphore's current payload was created.</th></tr>
<tr><th>VUID-VkSemaphoreGetFdInfoKHR-handleType-01134</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> If handleType refers to a handle type with copy payload transference semantics, as defined below in Importing Semaphore Payloads, there must be no queue waiting on semaphore.</th></tr>
<tr><th>VUID-VkSemaphoreGetFdInfoKHR-handleType-01135</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> If handleType refers to a handle type with copy payload transference semantics, semaphore must be signaled, or have an associated semaphore signal operation pending execution.</th></tr>
<tr><th>VUID-VkSemaphoreGetFdInfoKHR-handleType-01136</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> handleType must be defined as a POSIX file descriptor handle.</th></tr>
<tr><th>VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreGetFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkSemaphoreGetFdInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreGetFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkSemaphoreGetFdInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreGetFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR</th></tr>
<tr><th>VUID-VkSemaphoreGetFdInfoKHR-semaphore-01133</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload's handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType.</th></tr>
<tr><th>VUID-VkSemaphoreGetFdInfoKHR-semaphore-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreGetFdInfoKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> semaphore must be a valid VkSemaphore handle</th></tr>
<tr><th>VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01126</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when the semaphore's current payload was created.</th></tr>
<tr><th>VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01127</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If handleType is defined as an NT handle, vkGetSemaphoreWin32HandleKHR must be called no more than once for each valid unique combination of semaphore and handleType.</th></tr>
<tr><th>VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01129</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If handleType refers to a handle type with copy payload transference semantics, as defined below in Importing Semaphore Payloads, there must be no queue waiting on semaphore.</th></tr>
<tr><th>VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01130</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> If handleType refers to a handle type with copy payload transference semantics, semaphore must be signaled, or have an associated semaphore signal operation pending execution.</th></tr>
<tr><th>VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01131</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> handleType must be defined as an NT handle or a global share handle.</th></tr>
<tr><th>VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreGetWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value</th></tr>
<tr><th>VUID-VkSemaphoreGetWin32HandleInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreGetWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkSemaphoreGetWin32HandleInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreGetWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR</th></tr>
<tr><th>VUID-VkSemaphoreGetWin32HandleInfoKHR-semaphore-01128</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSemaphoreGetWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload's handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType.</th></tr>
<tr><th>VUID-VkSemaphoreGetWin32HandleInfoKHR-semaphore-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSemaphoreGetWin32HandleInfoKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> semaphore must be a valid VkSemaphore handle</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-codeSize-01085</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>core</th><th> codeSize must be greater than 0</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-codeSize-01086</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>!(VK_NV_glsl_shader)</th><th> codeSize must be a multiple of 4</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkShaderModuleCreateInfo</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pCode-01087</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>!(VK_NV_glsl_shader)</th><th> pCode must point to valid SPIR-V code, formatted and packed as described by the Khronos SPIR-V Specification</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pCode-01088</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>!(VK_NV_glsl_shader)</th><th> pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pCode-01089</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>core</th><th> pCode must declare the Shader capability for SPIR-V code</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pCode-01090</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>core</th><th> pCode must not declare any capability that is not supported by the API, as described by the Capabilities section of the SPIR-V Environment appendix</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pCode-01091</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>core</th><th> If pCode declares any of the capabilities listed as optional in the SPIR-V Environment appendix, the corresponding feature(s) must be enabled.</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pCode-01376</th><th><span style="color:limegreen;">Y</span></th><th>InvalidSPIRVCodeSize</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>(VK_NV_glsl_shader)</th><th> If pCode points to SPIR-V code, codeSize must be a multiple of 4</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pCode-01377</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>(VK_NV_glsl_shader)</th><th> pCode must point to either valid SPIR-V code, formatted and packed as described by the Khronos SPIR-V Specification or valid GLSL code which must be written to the GL_KHR_vulkan_glsl extension specification</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pCode-01378</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>(VK_NV_glsl_shader)</th><th> If pCode points to SPIR-V code, that code must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pCode-01379</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkShaderModuleCreateInfo</th><th>(VK_NV_glsl_shader)</th><th> If pCode points to GLSL code, it must be valid GLSL code written to the GL_KHR_vulkan_glsl GLSL extension specification</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pCode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkShaderModuleCreateInfo</th><th>core</th><th> pCode must be a valid pointer to an array of (codeSize/4) uint32_t values</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkShaderModuleCreateInfo</th><th>core</th><th> pNext must be NULL or a pointer to a valid instance of VkShaderModuleValidationCacheCreateInfoEXT</th></tr>
<tr><th>VUID-VkShaderModuleCreateInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkShaderModuleCreateInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO</th></tr>
<tr><th>VUID-VkShaderModuleValidationCacheCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkShaderModuleValidationCacheCreateInfoEXT</th><th>(VK_EXT_validation_cache)</th><th> sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkShaderModuleValidationCacheCreateInfoEXT-validationCache-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkShaderModuleValidationCacheCreateInfoEXT</th><th>(VK_EXT_validation_cache)</th><th> validationCache must be a valid VkValidationCacheEXT handle</th></tr>
<tr><th>VUID-VkShadingRatePaletteNV-pShadingRatePaletteEntries-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> pShadingRatePaletteEntries must be a valid pointer to an array of shadingRatePaletteEntryCount valid VkShadingRatePaletteEntryNV values</th></tr>
<tr><th>VUID-VkShadingRatePaletteNV-shadingRatePaletteEntryCount-02071</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>VkShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> shadingRatePaletteEntryCount must be between 1 and VkPhysicalDeviceShadingRateImagePropertiesNV::shadingRatePaletteSize, inclusive</th></tr>
<tr><th>VUID-VkShadingRatePaletteNV-shadingRatePaletteEntryCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> shadingRatePaletteEntryCount must be greater than 0</th></tr>
<tr><th>VUID-VkSharedPresentSurfaceCapabilitiesKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSharedPresentSurfaceCapabilitiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_KHR_shared_presentable_image)</th><th> sType must be VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR</th></tr>
<tr><th>VUID-VkSparseBufferMemoryBindInfo-bindCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseBufferMemoryBindInfo</th><th>core</th><th> bindCount must be greater than 0</th></tr>
<tr><th>VUID-VkSparseBufferMemoryBindInfo-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseBufferMemoryBindInfo</th><th>core</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-VkSparseBufferMemoryBindInfo-pBinds-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseBufferMemoryBindInfo</th><th>core</th><th> pBinds must be a valid pointer to an array of bindCount valid VkSparseMemoryBind structures</th></tr>
<tr><th>VUID-VkSparseImageFormatProperties2-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSparseImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkSparseImageFormatProperties2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> sType must be VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-extent-01108</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> extent.width must either be a multiple of the sparse image block width of the image, or else (extent.width + offset.x) must equal the width of the image subresource</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-extent-01110</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> extent.height must either be a multiple of the sparse image block height of the image, or else (extent.height + offset.y) must equal the height of the image subresource</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-extent-01112</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> extent.depth must either be a multiple of the sparse image block depth of the image, or else (extent.depth + offset.z) must equal the depth of the image subresource</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> flags must be a valid combination of VkSparseMemoryBindFlagBits values</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-memory-01104</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> If the sparse aliased residency feature is not enabled, and if any other resources are bound to ranges of memory, the range of memory being bound must not overlap with those bound ranges</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-memory-01105</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> memory and memoryOffset must match the memory requirements of the calling command's image, as described in section Resource Memory Association</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-offset-01107</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> offset.x must be a multiple of the sparse image block width (VkSparseImageFormatProperties::imageGranularity.width) of the image</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-offset-01109</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> offset.y must be a multiple of the sparse image block height (VkSparseImageFormatProperties::imageGranularity.height) of the image</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-offset-01111</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> offset.z must be a multiple of the sparse image block depth (VkSparseImageFormatProperties::imageGranularity.depth) of the image</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-subresource-01106</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> subresource must be a valid image subresource for image (see Image Views)</th></tr>
<tr><th>VUID-VkSparseImageMemoryBind-subresource-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSparseImageMemoryBind</th><th>core</th><th> subresource must be a valid VkImageSubresource structure</th></tr>
<tr><th>VUID-VkSparseImageMemoryBindInfo-bindCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseImageMemoryBindInfo</th><th>core</th><th> bindCount must be greater than 0</th></tr>
<tr><th>VUID-VkSparseImageMemoryBindInfo-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseImageMemoryBindInfo</th><th>core</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-VkSparseImageMemoryBindInfo-pBinds-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseImageMemoryBindInfo</th><th>core</th><th> pBinds must be a valid pointer to an array of bindCount valid VkSparseImageMemoryBind structures</th></tr>
<tr><th>VUID-VkSparseImageMemoryBindInfo-subresource-01722</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBindInfo</th><th>core</th><th> The subresource.mipLevel member of each element of pBinds must be less than the mipLevels specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkSparseImageMemoryBindInfo-subresource-01723</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageMemoryBindInfo</th><th>core</th><th> The subresource.arrayLayer member of each element of pBinds must be less than the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-VkSparseImageMemoryRequirements2-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSparseImageMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkSparseImageMemoryRequirements2-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseImageMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> sType must be VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2</th></tr>
<tr><th>VUID-VkSparseImageOpaqueMemoryBindInfo-bindCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseImageOpaqueMemoryBindInfo</th><th>core</th><th> bindCount must be greater than 0</th></tr>
<tr><th>VUID-VkSparseImageOpaqueMemoryBindInfo-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseImageOpaqueMemoryBindInfo</th><th>core</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-01103</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseImageOpaqueMemoryBindInfo</th><th>core</th><th> If the flags member of any element of pBinds contains VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range defined must be within the mip tail region of the metadata aspect of image</th></tr>
<tr><th>VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseImageOpaqueMemoryBindInfo</th><th>core</th><th> pBinds must be a valid pointer to an array of bindCount valid VkSparseMemoryBind structures</th></tr>
<tr><th>VUID-VkSparseMemoryBind-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseMemoryBind</th><th>core</th><th> flags must be a valid combination of VkSparseMemoryBindFlagBits values</th></tr>
<tr><th>VUID-VkSparseMemoryBind-memory-01096</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseMemoryBind</th><th>core</th><th> If memory is not VK_NULL_HANDLE, memory and memoryOffset must match the memory requirements of the resource, as described in section Resource Memory Association</th></tr>
<tr><th>VUID-VkSparseMemoryBind-memory-01097</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseMemoryBind</th><th>core</th><th> If memory is not VK_NULL_HANDLE, memory must not have been created with a memory type that reports VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set</th></tr>
<tr><th>VUID-VkSparseMemoryBind-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSparseMemoryBind</th><th>core</th><th> If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-VkSparseMemoryBind-memoryOffset-01101</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseMemoryBind</th><th>core</th><th> memoryOffset must be less than the size of memory</th></tr>
<tr><th>VUID-VkSparseMemoryBind-resourceOffset-01099</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseMemoryBind</th><th>core</th><th> resourceOffset must be less than the size of the resource</th></tr>
<tr><th>VUID-VkSparseMemoryBind-size-01098</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseMemoryBind</th><th>core</th><th> size must be greater than 0</th></tr>
<tr><th>VUID-VkSparseMemoryBind-size-01100</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseMemoryBind</th><th>core</th><th> size must be less than or equal to the size of the resource minus resourceOffset</th></tr>
<tr><th>VUID-VkSparseMemoryBind-size-01102</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSparseMemoryBind</th><th>core</th><th> size must be less than or equal to the size of memory minus memoryOffset</th></tr>
<tr><th>VUID-VkSpecializationInfo-offset-00773</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSpecializationInfo</th><th>core</th><th> The offset member of each element of pMapEntries must be less than dataSize</th></tr>
<tr><th>VUID-VkSpecializationInfo-pData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSpecializationInfo</th><th>core</th><th> If dataSize is not 0, pData must be a valid pointer to an array of dataSize bytes</th></tr>
<tr><th>VUID-VkSpecializationInfo-pMapEntries-00774</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSpecializationInfo</th><th>core</th><th> The size member of each element of pMapEntries must be less than or equal to dataSize minus offset</th></tr>
<tr><th>VUID-VkSpecializationInfo-pMapEntries-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSpecializationInfo</th><th>core</th><th> If mapEntryCount is not 0, pMapEntries must be a valid pointer to an array of mapEntryCount valid VkSpecializationMapEntry structures</th></tr>
<tr><th>VUID-VkSpecializationMapEntry-constantID-00776</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSpecializationMapEntry</th><th>core</th><th> For a constantID specialization constant declared in a shader, size must match the byte size of the constantID. If the specialization constant is of type boolean, size must be the byte size of VkBool32</th></tr>
<tr><th>VUID-VkStencilOpState-compareOp-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkStencilOpState</th><th>core</th><th> compareOp must be a valid VkCompareOp value</th></tr>
<tr><th>VUID-VkStencilOpState-depthFailOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkStencilOpState</th><th>core</th><th> depthFailOp must be a valid VkStencilOp value</th></tr>
<tr><th>VUID-VkStencilOpState-failOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkStencilOpState</th><th>core</th><th> failOp must be a valid VkStencilOp value</th></tr>
<tr><th>VUID-VkStencilOpState-passOp-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkStencilOpState</th><th>core</th><th> passOp must be a valid VkStencilOp value</th></tr>
<tr><th>VUID-VkStreamDescriptorSurfaceCreateInfoGGP-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkStreamDescriptorSurfaceCreateInfoGGP</th><th>(VK_KHR_surface)+(VK_GGP_stream_descriptor_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkStreamDescriptorSurfaceCreateInfoGGP-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkStreamDescriptorSurfaceCreateInfoGGP</th><th>(VK_KHR_surface)+(VK_GGP_stream_descriptor_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkStreamDescriptorSurfaceCreateInfoGGP-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkStreamDescriptorSurfaceCreateInfoGGP</th><th>(VK_KHR_surface)+(VK_GGP_stream_descriptor_surface)</th><th> sType must be VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP</th></tr>
<tr><th>VUID-VkStreamDescriptorSurfaceCreateInfoGGP-streamDescriptor-02681</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkStreamDescriptorSurfaceCreateInfoGGP</th><th>(VK_KHR_surface)+(VK_GGP_stream_descriptor_surface)</th><th> streamDescriptor must be a valid GgpStreamDescriptor</th></tr>
<tr><th>VUID-VkSubmitInfo-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubmitInfo</th><th>core</th><th> Each of the elements of pCommandBuffers, the elements of pSignalSemaphores, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkSubmitInfo-pCommandBuffers-00075</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubmitInfo</th><th>core</th><th> Each element of pCommandBuffers must not have been allocated with VK_COMMAND_BUFFER_LEVEL_SECONDARY</th></tr>
<tr><th>VUID-VkSubmitInfo-pCommandBuffers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubmitInfo</th><th>core</th><th> If commandBufferCount is not 0, pCommandBuffers must be a valid pointer to an array of commandBufferCount valid VkCommandBuffer handles</th></tr>
<tr><th>VUID-VkSubmitInfo-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubmitInfo</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkD3D12FenceSubmitInfoKHR, VkDeviceGroupSubmitInfo, VkProtectedSubmitInfo, VkWin32KeyedMutexAcquireReleaseInfoKHR, or VkWin32KeyedMutexAcquireReleaseInfoNV</th></tr>
<tr><th>VUID-VkSubmitInfo-pSignalSemaphores-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubmitInfo</th><th>core</th><th> If signalSemaphoreCount is not 0, pSignalSemaphores must be a valid pointer to an array of signalSemaphoreCount valid VkSemaphore handles</th></tr>
<tr><th>VUID-VkSubmitInfo-pWaitDstStageMask-00076</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubmitInfo</th><th>core</th><th> If the geometry shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-VkSubmitInfo-pWaitDstStageMask-00077</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubmitInfo</th><th>core</th><th> If the tessellation shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-VkSubmitInfo-pWaitDstStageMask-00078</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubmitInfo</th><th>core</th><th> Each element of pWaitDstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT.</th></tr>
<tr><th>VUID-VkSubmitInfo-pWaitDstStageMask-02089</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>VkSubmitInfo</th><th>(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-VkSubmitInfo-pWaitDstStageMask-02090</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>VkSubmitInfo</th><th>(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-VkSubmitInfo-pWaitDstStageMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubmitInfo</th><th>core</th><th> If waitSemaphoreCount is not 0, pWaitDstStageMask must be a valid pointer to an array of waitSemaphoreCount valid combinations of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-VkSubmitInfo-pWaitDstStageMask-requiredbitmask</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubmitInfo</th><th>core</th><th> Each element of pWaitDstStageMask must not be 0</th></tr>
<tr><th>VUID-VkSubmitInfo-pWaitSemaphores-parameter</th><th><span style="color:limegreen;">Y</span></th><th>RequiredParameter</th><th>implicit</th><th>VkSubmitInfo</th><th>core</th><th> If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles</th></tr>
<tr><th>VUID-VkSubmitInfo-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>RequiredParameter</th><th>implicit</th><th>VkSubmitInfo</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_SUBMIT_INFO</th></tr>
<tr><th>VUID-VkSubmitInfo-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubmitInfo</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkSubpassBeginInfoKHR-contents-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassBeginInfoKHR</th><th>(VK_KHR_create_renderpass2)</th><th> contents must be a valid VkSubpassContents value</th></tr>
<tr><th>VUID-VkSubpassBeginInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassBeginInfoKHR</th><th>(VK_KHR_create_renderpass2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkSubpassBeginInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassBeginInfoKHR</th><th>(VK_KHR_create_renderpass2)</th><th> sType must be VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR</th></tr>
<tr><th>VUID-VkSubpassDependency-dependencyFlags-02520</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, srcSubpass must not be equal to VK_SUBPASS_EXTERNAL</th></tr>
<tr><th>VUID-VkSubpassDependency-dependencyFlags-02521</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, dstSubpass must not be equal to VK_SUBPASS_EXTERNAL</th></tr>
<tr><th>VUID-VkSubpassDependency-dependencyFlags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency</th><th>core</th><th> dependencyFlags must be a valid combination of VkDependencyFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDependency-dstAccessMask-00869</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> Any access flag included in dstAccessMask must be supported by one of the pipeline stages in dstStageMask, as specified in the table of supported access types</th></tr>
<tr><th>VUID-VkSubpassDependency-dstAccessMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency</th><th>core</th><th> dstAccessMask must be a valid combination of VkAccessFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDependency-dstStageMask-00861</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency-dstStageMask-00863</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency-dstStageMask-02101</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency</th><th>(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-VkSubpassDependency-dstStageMask-02102</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency</th><th>(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-VkSubpassDependency-dstStageMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency</th><th>core</th><th> dstStageMask must be a valid combination of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDependency-dstStageMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency</th><th>core</th><th> dstStageMask must not be 0</th></tr>
<tr><th>VUID-VkSubpassDependency-dstSubpass-00859</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> If dstSubpass is not VK_SUBPASS_EXTERNAL, dstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency-srcAccessMask-00868</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> Any access flag included in srcAccessMask must be supported by one of the pipeline stages in srcStageMask, as specified in the table of supported access types</th></tr>
<tr><th>VUID-VkSubpassDependency-srcAccessMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency</th><th>core</th><th> srcAccessMask must be a valid combination of VkAccessFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDependency-srcStageMask-00860</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency-srcStageMask-00862</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency-srcStageMask-02099</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency</th><th>(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-VkSubpassDependency-srcStageMask-02100</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency</th><th>(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-VkSubpassDependency-srcStageMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency</th><th>core</th><th> srcStageMask must be a valid combination of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDependency-srcStageMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency</th><th>core</th><th> srcStageMask must not be 0</th></tr>
<tr><th>VUID-VkSubpassDependency-srcSubpass-00858</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> If srcSubpass is not VK_SUBPASS_EXTERNAL, srcStageMask must not include VK_PIPELINE_STAGE_HOST_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency-srcSubpass-00864</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> srcSubpass must be less than or equal to dstSubpass, unless one of them is VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies and ensure a valid execution order</th></tr>
<tr><th>VUID-VkSubpassDependency-srcSubpass-00865</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> srcSubpass and dstSubpass must not both be equal to VK_SUBPASS_EXTERNAL</th></tr>
<tr><th>VUID-VkSubpassDependency-srcSubpass-00867</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> If srcSubpass is equal to dstSubpass and not all of the stages in srcStageMask and dstStageMask are framebuffer-space stages, the logically latest pipeline stage in srcStageMask must be logically earlier than or equal to the logically earliest pipeline stage in dstStageMask</th></tr>
<tr><th>VUID-VkSubpassDependency-srcSubpass-00872</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If srcSubpass equals dstSubpass and that subpass has more than one bit set in the view mask, then dependencyFlags must include VK_DEPENDENCY_VIEW_LOCAL_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency-srcSubpass-01989</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> If srcSubpass is equal to dstSubpass, srcStageMask and dstStageMask must not set any bits that are neither VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, nor one of the graphics pipeline stages</th></tr>
<tr><th>VUID-VkSubpassDependency-srcSubpass-02243</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency</th><th>core</th><th> If srcSubpass equals dstSubpass, and srcStageMask and dstStageMask both include a framebuffer-space stage, then dependencyFlags must include VK_DEPENDENCY_BY_REGION_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dependencyFlags-03090</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, srcSubpass must not be equal to VK_SUBPASS_EXTERNAL</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dependencyFlags-03091</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, dstSubpass must not be equal to VK_SUBPASS_EXTERNAL</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dependencyFlags-03092</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If dependencyFlags does not include VK_DEPENDENCY_VIEW_LOCAL_BIT, viewOffset must be 0</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dependencyFlags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> dependencyFlags must be a valid combination of VkDependencyFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dstAccessMask-03089</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> Any access flag included in dstAccessMask must be supported by one of the pipeline stages in dstStageMask, as specified in the table of supported access types</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dstAccessMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> dstAccessMask must be a valid combination of VkAccessFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dstStageMask-02105</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)+(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dstStageMask-02106</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)+(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dstStageMask-03081</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dstStageMask-03083</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dstStageMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> dstStageMask must be a valid combination of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dstStageMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> dstStageMask must not be 0</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-dstSubpass-03079</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If dstSubpass is not VK_SUBPASS_EXTERNAL, dstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> sType must be VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcAccessMask-03088</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> Any access flag included in srcAccessMask must be supported by one of the pipeline stages in srcStageMask, as specified in the table of supported access types</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcAccessMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> srcAccessMask must be a valid combination of VkAccessFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcStageMask-02103</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)+(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcStageMask-02104</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)+(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcStageMask-03080</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcStageMask-03082</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcStageMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> srcStageMask must be a valid combination of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcStageMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> srcStageMask must not be 0</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcSubpass-02244</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If srcSubpass is equal to dstSubpass, srcStageMask and dstStageMask must not set any bits that are neither VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, nor one of the graphics pipeline stages</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcSubpass-02245</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If srcSubpass equals dstSubpass, and srcStageMask and dstStageMask both include a framebuffer-space stage, then dependencyFlags must include VK_DEPENDENCY_BY_REGION_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcSubpass-03078</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If srcSubpass is not VK_SUBPASS_EXTERNAL, srcStageMask must not include VK_PIPELINE_STAGE_HOST_BIT</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcSubpass-03084</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> srcSubpass must be less than or equal to dstSubpass, unless one of them is VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies and ensure a valid execution order</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcSubpass-03085</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> srcSubpass and dstSubpass must not both be equal to VK_SUBPASS_EXTERNAL</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-srcSubpass-03087</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidSubpassDependencies</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If srcSubpass is equal to dstSubpass and not all of the stages in srcStageMask and dstStageMask are framebuffer-space stages, the logically latest pipeline stage in srcStageMask must be logically earlier than or equal to the logically earliest pipeline stage in dstStageMask</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-viewOffset-02530</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If viewOffset is not equal to 0, srcSubpass must not be equal to dstSubpass</th></tr>
<tr><th>VUID-VkSubpassDependency2KHR-viewOffset-03093</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubpassDependency2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If viewOffset is not 0, srcSubpass must not be equal to dstSubpass.</th></tr>
<tr><th>VUID-VkSubpassDescription-attachment-00853</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> The attachment member of each element of pPreserveAttachments must not be VK_ATTACHMENT_UNUSED</th></tr>
<tr><th>VUID-VkSubpassDescription-colorAttachmentCount-00845</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> colorAttachmentCount must be less than or equal to VkPhysicalDeviceLimits::maxColorAttachments</th></tr>
<tr><th>VUID-VkSubpassDescription-flags-00856</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateSubpassMissingAttributesBitMultiviewNVX</th><th>explicit</th><th>VkSubpassDescription</th><th>(VK_NVX_multiview_per_view_attributes)</th><th> If flags includes VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX, it must also include VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX.</th></tr>
<tr><th>VUID-VkSubpassDescription-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription</th><th>core</th><th> flags must be a valid combination of VkSubpassDescriptionFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDescription-layout-02519</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> If any attachment is used by more than one VkAttachmentReference member, then each use must use the same layout</th></tr>
<tr><th>VUID-VkSubpassDescription-loadOp-00846</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then loadOp must not be VK_ATTACHMENT_LOAD_OP_CLEAR</th></tr>
<tr><th>VUID-VkSubpassDescription-pColorAttachments-01417</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have the same sample count</th></tr>
<tr><th>VUID-VkSubpassDescription-pColorAttachments-01506</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidMixedAttachmentSamplesAMD</th><th>explicit</th><th>VkSubpassDescription</th><th>(VK_AMD_mixed_attachment_samples)</th><th> If the VK_AMD_mixed_attachment_samples extension is enabled, and all attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have a sample count that is smaller than or equal to the sample count of pDepthStencilAttachment if it is not VK_ATTACHMENT_UNUSED</th></tr>
<tr><th>VUID-VkSubpassDescription-pColorAttachments-02648</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have formats whose features contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-VkSubpassDescription-pColorAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription</th><th>core</th><th> If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference structures</th></tr>
<tr><th>VUID-VkSubpassDescription-pDepthStencilAttachment-01418</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferMixedSamplesNV, RenderPassCreateAttachmentsMisc, FramebufferMixedSamples</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> If neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, and if pDepthStencilAttachment is not VK_ATTACHMENT_UNUSED and any attachments in pColorAttachments are not VK_ATTACHMENT_UNUSED, they must have the same sample count</th></tr>
<tr><th>VUID-VkSubpassDescription-pDepthStencilAttachment-02650</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> If pDepthStencilAttachment is not NULL and the attachment is not VK_ATTACHMENT_UNUSED then it must have a format whose features contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-VkSubpassDescription-pDepthStencilAttachment-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription</th><th>core</th><th> If pDepthStencilAttachment is not NULL, pDepthStencilAttachment must be a valid pointer to a valid VkAttachmentReference structure</th></tr>
<tr><th>VUID-VkSubpassDescription-pInputAttachments-02647</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> All attachments in pInputAttachments that are not VK_ATTACHMENT_UNUSED must have formats whose features contain at least one of VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.</th></tr>
<tr><th>VUID-VkSubpassDescription-pInputAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription</th><th>core</th><th> If inputAttachmentCount is not 0, pInputAttachments must be a valid pointer to an array of inputAttachmentCount valid VkAttachmentReference structures</th></tr>
<tr><th>VUID-VkSubpassDescription-pPreserveAttachments-00854</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> Each element of pPreserveAttachments must not also be an element of any other member of the subpass description</th></tr>
<tr><th>VUID-VkSubpassDescription-pPreserveAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription</th><th>core</th><th> If preserveAttachmentCount is not 0, pPreserveAttachments must be a valid pointer to an array of preserveAttachmentCount uint32_t values</th></tr>
<tr><th>VUID-VkSubpassDescription-pResolveAttachments-00847</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> If pResolveAttachments is not NULL, for each resolve attachment that is not VK_ATTACHMENT_UNUSED, the corresponding color attachment must not be VK_ATTACHMENT_UNUSED</th></tr>
<tr><th>VUID-VkSubpassDescription-pResolveAttachments-00848</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> If pResolveAttachments is not NULL, for each resolve attachment that is not VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-VkSubpassDescription-pResolveAttachments-00849</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> If pResolveAttachments is not NULL, each resolve attachment that is not VK_ATTACHMENT_UNUSED must have a sample count of VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-VkSubpassDescription-pResolveAttachments-00850</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> If pResolveAttachments is not NULL, each resolve attachment that is not VK_ATTACHMENT_UNUSED must have the same VkFormat as its corresponding color attachment</th></tr>
<tr><th>VUID-VkSubpassDescription-pResolveAttachments-02649</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> All attachments in pResolveAttachments that are not VK_ATTACHMENT_UNUSED must have formats whose features contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-VkSubpassDescription-pResolveAttachments-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription</th><th>core</th><th> If colorAttachmentCount is not 0, and pResolveAttachments is not NULL, pResolveAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference structures</th></tr>
<tr><th>VUID-VkSubpassDescription-pipelineBindPoint-00844</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateSubpassNonGraphicsPipeline</th><th>explicit</th><th>VkSubpassDescription</th><th>core</th><th> pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-VkSubpassDescription-pipelineBindPoint-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription</th><th>core</th><th> pipelineBindPoint must be a valid VkPipelineBindPoint value</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-aspectMask-02529</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The aspectMask member of each element of pInputAttachments must not include VK_IMAGE_ASPECT_METADATA_BIT</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-aspectMask-03175</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreate2SubpassInvalidInputAttachmentParameters</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The aspectMask member of any element of pInputAttachments must be a valid combination of VkImageAspectFlagBits</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-aspectMask-03176</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreate2SubpassInvalidInputAttachmentParameters</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The aspectMask member of any element of pInputAttachments must not be 0</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-attachment-03073</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The attachment member of any element of pPreserveAttachments must not be VK_ATTACHMENT_UNUSED</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-colorAttachmentCount-03063</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> colorAttachmentCount must be less than or equal to VkPhysicalDeviceLimits::maxColorAttachments</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-flags-03076</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateSubpassMissingAttributesBitMultiviewNVX</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)+(VK_NVX_multiview_per_view_attributes)</th><th> If flags includes VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX, it must also include VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX.</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> flags must be a valid combination of VkSubpassDescriptionFlagBits values</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-layout-02528</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If any attachment is used by more than one VkAttachmentReference member, then each use must use the same layout</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-loadOp-03064</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then loadOp must not be VK_ATTACHMENT_LOAD_OP_CLEAR</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pColorAttachments-03069</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have the same sample count</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pColorAttachments-03070</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateInvalidMixedAttachmentSamplesAMD</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)+(VK_AMD_mixed_attachment_samples)</th><th> If the VK_AMD_mixed_attachment_samples extension is enabled, all attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have a sample count that is smaller than or equal to the sample count of pDepthStencilAttachment if it is not VK_ATTACHMENT_UNUSED</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pColorAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference2KHR structures</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pDepthStencilAttachment-03071</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, and if pDepthStencilAttachment is not VK_ATTACHMENT_UNUSED and any attachments in pColorAttachments are not VK_ATTACHMENT_UNUSED, they must have the same sample count</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pDepthStencilAttachment-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If pDepthStencilAttachment is not NULL, pDepthStencilAttachment must be a valid pointer to a valid VkAttachmentReference2KHR structure</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pInputAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If inputAttachmentCount is not 0, pInputAttachments must be a valid pointer to an array of inputAttachmentCount valid VkAttachmentReference2KHR structures</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pPreserveAttachments-03074</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> Any given element of pPreserveAttachments must not also be an element of any other member of the subpass description</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pPreserveAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If preserveAttachmentCount is not 0, pPreserveAttachments must be a valid pointer to an array of preserveAttachmentCount uint32_t values</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pResolveAttachments-03065</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If pResolveAttachments is not NULL, for each resolve attachment that does not have the value VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have the value VK_ATTACHMENT_UNUSED</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pResolveAttachments-03066</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If pResolveAttachments is not NULL, for each resolve attachment that is not VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pResolveAttachments-03067</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If pResolveAttachments is not NULL, each resolve attachment that is not VK_ATTACHMENT_UNUSED must have a sample count of VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pResolveAttachments-03068</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateAttachmentsMisc</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> Any given element of pResolveAttachments must have the same VkFormat as its corresponding color attachment</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pResolveAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If colorAttachmentCount is not 0, and pResolveAttachments is not NULL, pResolveAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference2KHR structures</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pipelineBindPoint-03062</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassCreateSubpassNonGraphicsPipeline</th><th>explicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-pipelineBindPoint-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pipelineBindPoint must be a valid VkPipelineBindPoint value</th></tr>
<tr><th>VUID-VkSubpassDescription2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescription2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> sType must be VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-depthResolveMode-03183</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> The value of depthResolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolvePropertiesKHR::supportedDepthResolveModes or VK_RESOLVE_MODE_NONE_KHR</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-depthResolveMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> depthResolveMode must be a valid VkResolveModeFlagBitsKHR value</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-pDepthStencilResolveAttachment-02651</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED then it must have a format whose features contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-pDepthStencilResolveAttachment-03177</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, pDepthStencilAttachment must not have the value VK_ATTACHMENT_UNUSED</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-pDepthStencilResolveAttachment-03178</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, depthResolveMode and stencilResolveMode must not both be VK_RESOLVE_MODE_NONE_KHR</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-pDepthStencilResolveAttachment-03179</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, pDepthStencilAttachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-pDepthStencilResolveAttachment-03180</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, pDepthStencilResolveAttachment must have a sample count of VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-pDepthStencilResolveAttachment-03181</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> If the VkFormat of pDepthStencilResolveAttachment has a depth component, then the VkFormat of pDepthStencilAttachment must have a depth component with the same number of bits and numerical type</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-pDepthStencilResolveAttachment-03182</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> If the VkFormat of pDepthStencilResolveAttachment has a stencil component, then the VkFormat of pDepthStencilAttachment must have a stencil component with the same number of bits and numerical type</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-pDepthStencilResolveAttachment-03185</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> If the VkFormat of pDepthStencilResolveAttachment has both depth and stencil components, VkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolve is VK_FALSE, and VkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolveNone is VK_FALSE, then the values of depthResolveMode and stencilResolveMode must be identical</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-pDepthStencilResolveAttachment-03186</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> If the VkFormat of pDepthStencilResolveAttachment has both depth and stencil components, VkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolve is VK_FALSE and VkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolveNone is VK_TRUE, then the values of depthResolveMode and stencilResolveMode must be identical or one of them must be VK_RESOLVE_MODE_NONE_KHR</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-pDepthStencilResolveAttachment-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> If pDepthStencilResolveAttachment is not NULL, pDepthStencilResolveAttachment must be a valid pointer to a valid VkAttachmentReference2KHR structure</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> sType must be VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-stencilResolveMode-03184</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> The value of stencilResolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolvePropertiesKHR::supportedStencilResolveModes or VK_RESOLVE_MODE_NONE_KHR</th></tr>
<tr><th>VUID-VkSubpassDescriptionDepthStencilResolveKHR-stencilResolveMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassDescriptionDepthStencilResolveKHR</th><th>(VK_KHR_create_renderpass2)+(VK_KHR_depth_stencil_resolve)</th><th> stencilResolveMode must be a valid VkResolveModeFlagBitsKHR value</th></tr>
<tr><th>VUID-VkSubpassEndInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassEndInfoKHR</th><th>(VK_KHR_create_renderpass2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkSubpassEndInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSubpassEndInfoKHR</th><th>(VK_KHR_create_renderpass2)</th><th> sType must be VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR</th></tr>
<tr><th>VUID-VkSubpassSampleLocationsEXT-sampleLocationsInfo-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSubpassSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure</th></tr>
<tr><th>VUID-VkSubpassSampleLocationsEXT-subpassIndex-01532</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginSampleLocationsInvalidIndicesEXT</th><th>explicit</th><th>VkSubpassSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> subpassIndex must be less than the subpassCount specified in VkRenderPassCreateInfo the render pass specified by VkRenderPassBeginInfo::renderPass was created with</th></tr>
<tr><th>VUID-VkSurfaceCapabilities2EXT-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSurfaceCapabilities2EXT</th><th>(VK_KHR_surface)+(VK_EXT_display_surface_counter)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkSurfaceCapabilities2EXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSurfaceCapabilities2EXT</th><th>(VK_KHR_surface)+(VK_EXT_display_surface_counter)</th><th> sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT</th></tr>
<tr><th>VUID-VkSurfaceCapabilities2EXT-supportedSurfaceCounters-01246</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSurfaceCapabilities2EXT</th><th>(VK_KHR_surface)+(VK_EXT_display_surface_counter)</th><th> supportedSurfaceCounters must not include VK_SURFACE_COUNTER_VBLANK_EXT unless the surface queried is a display surface.</th></tr>
<tr><th>VUID-VkSurfaceCapabilities2KHR-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSurfaceCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkSharedPresentSurfaceCapabilitiesKHR, VkSurfaceCapabilitiesFullScreenExclusiveEXT, or VkSurfaceProtectedCapabilitiesKHR</th></tr>
<tr><th>VUID-VkSurfaceCapabilities2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSurfaceCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR</th></tr>
<tr><th>VUID-VkSurfaceCapabilities2KHR-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSurfaceCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkSurfaceCapabilitiesFullScreenExclusiveEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSurfaceCapabilitiesFullScreenExclusiveEXT</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_EXT_full_screen_exclusive)</th><th> sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT</th></tr>
<tr><th>VUID-VkSurfaceFormat2KHR-pNext-pNext</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSurfaceFormat2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkSurfaceFormat2KHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSurfaceFormat2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> sType must be VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR</th></tr>
<tr><th>VUID-VkSurfaceFullScreenExclusiveInfoEXT-fullScreenExclusive-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSurfaceFullScreenExclusiveInfoEXT</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_EXT_full_screen_exclusive)</th><th> fullScreenExclusive must be a valid VkFullScreenExclusiveEXT value</th></tr>
<tr><th>VUID-VkSurfaceFullScreenExclusiveInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSurfaceFullScreenExclusiveInfoEXT</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_EXT_full_screen_exclusive)</th><th> sType must be VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT</th></tr>
<tr><th>VUID-VkSurfaceFullScreenExclusiveWin32InfoEXT-hmonitor-02673</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSurfaceFullScreenExclusiveWin32InfoEXT</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_EXT_full_screen_exclusive)+(VK_KHR_win32_surface)</th><th> hmonitor must be a valid HMONITOR</th></tr>
<tr><th>VUID-VkSurfaceFullScreenExclusiveWin32InfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSurfaceFullScreenExclusiveWin32InfoEXT</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_EXT_full_screen_exclusive)+(VK_KHR_win32_surface)</th><th> sType must be VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT</th></tr>
<tr><th>VUID-VkSurfaceProtectedCapabilitiesKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSurfaceProtectedCapabilitiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_KHR_surface_protected_capabilities)</th><th> sType must be VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR</th></tr>
<tr><th>VUID-VkSwapchainCounterCreateInfoEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSwapchainCounterCreateInfoEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)</th><th> sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-01244</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSwapchainCounterCreateInfoEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)</th><th> The bits in surfaceCounters must be supported by VkSwapchainCreateInfoKHR::surface, as reported by vkGetPhysicalDeviceSurfaceCapabilities2EXT.</th></tr>
<tr><th>VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCounterCreateInfoEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)</th><th> surfaceCounters must be a valid combination of VkSurfaceCounterFlagBitsEXT values</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> Both of oldSwapchain, and surface that are valid handles must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-compositeAlpha-01280</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> compositeAlpha must be one of the bits present in the supportedCompositeAlpha member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> compositeAlpha must be a valid VkCompositeAlphaFlagBitsKHR value</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-flags-03168</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_swapchain_mutable_format)</th><th> If flags contains VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR then the pNext chain must contain an instance of VkImageFormatListCreateInfoKHR with a viewFormatCount greater than zero and pViewFormats must have an element equal to imageFormat</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-flags-03187</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_surface_protected_capabilities)</th><th> If flags contains VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR, then VkSurfaceProtectedCapabilitiesKHR::supportsProtected must be VK_TRUE in the VkSurfaceProtectedCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilities2KHR for surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> flags must be a valid combination of VkSwapchainCreateFlagBitsKHR values</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageArrayLayers-01275</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> imageArrayLayers must be greater than 0 and less than or equal to the maxImageArrayLayers member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageColorSpace-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> imageColorSpace must be a valid VkColorSpaceKHR value</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageExtent-01274</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> imageExtent must be between minImageExtent and maxImageExtent, inclusive, where minImageExtent and maxImageExtent are members of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageExtent-01689</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> imageExtent members width and height must both be non-zero</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageFormat-01273</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> imageFormat and imageColorSpace must match the format and colorSpace members, respectively, of one of the VkSurfaceFormatKHR structures returned by vkGetPhysicalDeviceSurfaceFormatsKHR for the surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageFormat-01778</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> The implied image creation parameters of the swapchain must be supported as reported by vkGetPhysicalDeviceImageFormatProperties</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageFormat-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> imageFormat must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01277</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If imageSharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01278</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If imageSharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01393</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+!(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> If imageSharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the physicalDevice that was used to create device</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01428</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> If imageSharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageSharingMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> imageSharingMode must be a valid VkSharingMode value</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageUsage-01276</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+!(VK_KHR_shared_presentable_image)</th><th> imageUsage must be a subset of the supported usage flags present in the supportedUsageFlags member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageUsage-01384</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)</th><th> If presentMode is VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, imageUsage must be a subset of the supported usage flags present in the sharedPresentSupportedUsageFlags member of the VkSharedPresentSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilities2KHR for surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageUsage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> imageUsage must be a valid combination of VkImageUsageFlagBits values</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-imageUsage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> imageUsage must not be 0</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-minImageCount-01271</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> minImageCount must be greater than or equal to the value returned in the minImageCount member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-minImageCount-01272</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> minImageCount must be less than or equal to the value returned in the maxImageCount member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface if the returned maxImageCount is not zero</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-minImageCount-01383</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)</th><th> minImageCount must be 1 if presentMode is either VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-oldSwapchain-01933</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If oldSwapchain is not VK_NULL_HANDLE, oldSwapchain must be a non-retired swapchain associated with native window referred to by surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-oldSwapchain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If oldSwapchain is not VK_NULL_HANDLE, oldSwapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-oldSwapchain-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If oldSwapchain is a valid handle, it must have been created, allocated, or retrieved from surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-pNext-02679</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_full_screen_exclusive,VK_KHR_win32_surface)</th><th> If the pNext chain includes an instance of VkSurfaceFullScreenExclusiveInfoEXT with its fullScreenExclusive member set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and surface was created using vkCreateWin32SurfaceKHR, an instance of VkSurfaceFullScreenExclusiveWin32InfoEXT must be present in the pNext chain</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupSwapchainCreateInfoKHR, VkImageFormatListCreateInfoKHR, VkSurfaceFullScreenExclusiveInfoEXT, VkSurfaceFullScreenExclusiveWin32InfoEXT, VkSwapchainCounterCreateInfoEXT, or VkSwapchainDisplayNativeHdrCreateInfoAMD</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-physicalDeviceCount-01429</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If the logical device was created with VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1, flags must not contain VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-preTransform-01279</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> preTransform must be one of the bits present in the supportedTransforms member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-preTransform-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> preTransform must be a valid VkSurfaceTransformFlagBitsKHR value</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-presentMode-01281</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> presentMode must be one of the VkPresentModeKHR values returned by vkGetPhysicalDeviceSurfacePresentModesKHR for the surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-presentMode-01427</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)</th><th> If presentMode is VK_PRESENT_MODE_IMMEDIATE_KHR, VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_FIFO_KHR or VK_PRESENT_MODE_FIFO_RELAXED_KHR, imageUsage must be a subset of the supported usage flags present in the supportedUsageFlags member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for surface</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-presentMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> presentMode must be a valid VkPresentModeKHR value</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-surface-01270</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> surface must be a surface that is supported by the device as determined using vkGetPhysicalDeviceSurfaceSupportKHR</th></tr>
<tr><th>VUID-VkSwapchainCreateInfoKHR-surface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkSwapchainCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> surface must be a valid VkSurfaceKHR handle</th></tr>
<tr><th>VUID-VkSwapchainDisplayNativeHdrCreateInfoAMD-localDimmingEnable-XXXXX</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSwapchainDisplayNativeHdrCreateInfoAMD</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_AMD_display_native_hdr)</th><th> It is only valid to set localDimmingEnable to VK_TRUE if VkDisplayNativeHdrSurfaceCapabilitiesAMD::localDimmingSupport is supported.</th></tr>
<tr><th>VUID-VkSwapchainDisplayNativeHdrCreateInfoAMD-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkSwapchainDisplayNativeHdrCreateInfoAMD</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_AMD_display_native_hdr)</th><th> sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD</th></tr>
<tr><th>VUID-VkTextureLODGatherFormatPropertiesAMD-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkTextureLODGatherFormatPropertiesAMD</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_AMD_texture_gather_bias_lod)</th><th> sType must be VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD</th></tr>
<tr><th>VUID-VkValidationCacheCreateInfoEXT-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkValidationCacheCreateInfoEXT</th><th>(VK_EXT_validation_cache)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkValidationCacheCreateInfoEXT-initialDataSize-01534</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkValidationCacheCreateInfoEXT</th><th>(VK_EXT_validation_cache)</th><th> If initialDataSize is not 0, it must be equal to the size of pInitialData, as returned by vkGetValidationCacheDataEXT when pInitialData was originally retrieved</th></tr>
<tr><th>VUID-VkValidationCacheCreateInfoEXT-initialDataSize-01535</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkValidationCacheCreateInfoEXT</th><th>(VK_EXT_validation_cache)</th><th> If initialDataSize is not 0, pInitialData must have been retrieved from a previous call to vkGetValidationCacheDataEXT</th></tr>
<tr><th>VUID-VkValidationCacheCreateInfoEXT-pInitialData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkValidationCacheCreateInfoEXT</th><th>(VK_EXT_validation_cache)</th><th> If initialDataSize is not 0, pInitialData must be a valid pointer to an array of initialDataSize bytes</th></tr>
<tr><th>VUID-VkValidationCacheCreateInfoEXT-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkValidationCacheCreateInfoEXT</th><th>(VK_EXT_validation_cache)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkValidationCacheCreateInfoEXT-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkValidationCacheCreateInfoEXT</th><th>(VK_EXT_validation_cache)</th><th> sType must be VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT</th></tr>
<tr><th>VUID-VkValidationFeaturesEXT-pDisabledValidationFeatures-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkValidationFeaturesEXT</th><th>(VK_EXT_validation_features)</th><th> If disabledValidationFeatureCount is not 0, pDisabledValidationFeatures must be a valid pointer to an array of disabledValidationFeatureCount valid VkValidationFeatureDisableEXT values</th></tr>
<tr><th>VUID-VkValidationFeaturesEXT-pEnabledValidationFeatures-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkValidationFeaturesEXT</th><th>(VK_EXT_validation_features)</th><th> If enabledValidationFeatureCount is not 0, pEnabledValidationFeatures must be a valid pointer to an array of enabledValidationFeatureCount valid VkValidationFeatureEnableEXT values</th></tr>
<tr><th>VUID-VkValidationFeaturesEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkValidationFeaturesEXT</th><th>(VK_EXT_validation_features)</th><th> sType must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT</th></tr>
<tr><th>VUID-VkValidationFlagsEXT-disabledValidationCheckCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkValidationFlagsEXT</th><th>(VK_EXT_validation_flags)</th><th> disabledValidationCheckCount must be greater than 0</th></tr>
<tr><th>VUID-VkValidationFlagsEXT-pDisabledValidationChecks-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkValidationFlagsEXT</th><th>(VK_EXT_validation_flags)</th><th> pDisabledValidationChecks must be a valid pointer to an array of disabledValidationCheckCount valid VkValidationCheckEXT values</th></tr>
<tr><th>VUID-VkValidationFlagsEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkValidationFlagsEXT</th><th>(VK_EXT_validation_flags)</th><th> sType must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT</th></tr>
<tr><th>VUID-VkVertexInputAttributeDescription-binding-00621</th><th><span style="color:limegreen;">Y</span></th><th>VUID_VkVertexInputAttributeDescription_binding_00621</th><th>explicit</th><th>VkVertexInputAttributeDescription</th><th>core</th><th> binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings</th></tr>
<tr><th>VUID-VkVertexInputAttributeDescription-format-00623</th><th><span style="color:limegreen;">Y</span></th><th>CreatePipelineBadVertexAttributeFormat</th><th>explicit</th><th>VkVertexInputAttributeDescription</th><th>core</th><th> format must be allowed as a vertex buffer format, as specified by the VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties</th></tr>
<tr><th>VUID-VkVertexInputAttributeDescription-format-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkVertexInputAttributeDescription</th><th>core</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-VkVertexInputAttributeDescription-location-00620</th><th><span style="color:limegreen;">Y</span></th><th>VUID_VkVertexInputAttributeDescription_location_00620</th><th>explicit</th><th>VkVertexInputAttributeDescription</th><th>core</th><th> location must be less than VkPhysicalDeviceLimits::maxVertexInputAttributes</th></tr>
<tr><th>VUID-VkVertexInputAttributeDescription-offset-00622</th><th><span style="color:limegreen;">Y</span></th><th>VUID_VkVertexInputAttributeDescription_offset_00622</th><th>explicit</th><th>VkVertexInputAttributeDescription</th><th>core</th><th> offset must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributeOffset</th></tr>
<tr><th>VUID-VkVertexInputBindingDescription-binding-00618</th><th><span style="color:limegreen;">Y</span></th><th>VUID_VkVertexInputBindingDescription_binding_00618</th><th>explicit</th><th>VkVertexInputBindingDescription</th><th>core</th><th> binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings</th></tr>
<tr><th>VUID-VkVertexInputBindingDescription-inputRate-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkVertexInputBindingDescription</th><th>core</th><th> inputRate must be a valid VkVertexInputRate value</th></tr>
<tr><th>VUID-VkVertexInputBindingDescription-stride-00619</th><th><span style="color:limegreen;">Y</span></th><th>VUID_VkVertexInputBindingDescription_stride_00619</th><th>explicit</th><th>VkVertexInputBindingDescription</th><th>core</th><th> stride must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindingStride</th></tr>
<tr><th>VUID-VkVertexInputBindingDivisorDescriptionEXT-binding-01869</th><th><span style="color:limegreen;">Y</span></th><th>VertexAttributeDivisorExtension</th><th>explicit</th><th>VkVertexInputBindingDivisorDescriptionEXT</th><th>(VK_EXT_vertex_attribute_divisor)</th><th> binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings</th></tr>
<tr><th>VUID-VkVertexInputBindingDivisorDescriptionEXT-divisor-01870</th><th><span style="color:limegreen;">Y</span></th><th>VertexAttributeDivisorExtension</th><th>explicit</th><th>VkVertexInputBindingDivisorDescriptionEXT</th><th>(VK_EXT_vertex_attribute_divisor)</th><th> divisor must be a value between 0 and VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor, inclusive.</th></tr>
<tr><th>VUID-VkVertexInputBindingDivisorDescriptionEXT-inputRate-01871</th><th><span style="color:limegreen;">Y</span></th><th>VertexAttributeDivisorExtension</th><th>explicit</th><th>VkVertexInputBindingDivisorDescriptionEXT</th><th>(VK_EXT_vertex_attribute_divisor)</th><th> VkVertexInputBindingDescription::inputRate must be of type VK_VERTEX_INPUT_RATE_INSTANCE for this binding.</th></tr>
<tr><th>VUID-VkVertexInputBindingDivisorDescriptionEXT-vertexAttributeInstanceRateDivisor-02229</th><th><span style="color:limegreen;">Y</span></th><th>VertexAttributeDivisorDisabled</th><th>explicit</th><th>VkVertexInputBindingDivisorDescriptionEXT</th><th>(VK_EXT_vertex_attribute_divisor)</th><th> If the vertexAttributeInstanceRateDivisor feature is not enabled, divisor must be 1</th></tr>
<tr><th>VUID-VkVertexInputBindingDivisorDescriptionEXT-vertexAttributeInstanceRateZeroDivisor-02228</th><th><span style="color:limegreen;">Y</span></th><th>VertexAttributeDivisorInstanceRateZero</th><th>explicit</th><th>VkVertexInputBindingDivisorDescriptionEXT</th><th>(VK_EXT_vertex_attribute_divisor)</th><th> If the vertexAttributeInstanceRateZeroDivisor feature is not enabled, divisor must not be 0</th></tr>
<tr><th>VUID-VkViSurfaceCreateInfoNN-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkViSurfaceCreateInfoNN</th><th>(VK_KHR_surface)+(VK_NN_vi_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkViSurfaceCreateInfoNN-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkViSurfaceCreateInfoNN</th><th>(VK_KHR_surface)+(VK_NN_vi_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkViSurfaceCreateInfoNN-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkViSurfaceCreateInfoNN</th><th>(VK_KHR_surface)+(VK_NN_vi_surface)</th><th> sType must be VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN</th></tr>
<tr><th>VUID-VkViSurfaceCreateInfoNN-window-01318</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkViSurfaceCreateInfoNN</th><th>(VK_KHR_surface)+(VK_NN_vi_surface)</th><th> window must be a valid nn::vi::NativeWindowHandle</th></tr>
<tr><th>VUID-VkViewport-height-01772</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance1,VK_AMD_negative_viewport_height)</th><th> height must be greater than 0.0</th></tr>
<tr><th>VUID-VkViewport-height-01773</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>core</th><th> The absolute value of height must be less than or equal to VkPhysicalDeviceLimits::maxViewportDimensions[1]</th></tr>
<tr><th>VUID-VkViewport-maxDepth-01235</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>(VK_EXT_depth_range_unrestricted)</th><th> Unless VK_EXT_depth_range_unrestricted extension is enabled maxDepth must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-VkViewport-maxDepth-02541</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkViewport</th><th>!(VK_EXT_depth_range_unrestricted)</th><th> maxDepth must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-VkViewport-minDepth-01234</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>(VK_EXT_depth_range_unrestricted)</th><th> Unless VK_EXT_depth_range_unrestricted extension is enabled minDepth must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-VkViewport-minDepth-02540</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkViewport</th><th>!(VK_EXT_depth_range_unrestricted)</th><th> minDepth must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-VkViewport-width-01770</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>core</th><th> width must be greater than 0.0</th></tr>
<tr><th>VUID-VkViewport-width-01771</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>core</th><th> width must be less than or equal to VkPhysicalDeviceLimits::maxViewportDimensions[0]</th></tr>
<tr><th>VUID-VkViewport-x-01232</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>core</th><th> (x + width) must be less than or equal to viewportBoundsRange[1]</th></tr>
<tr><th>VUID-VkViewport-x-01774</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>core</th><th> x must be greater than or equal to viewportBoundsRange[0]</th></tr>
<tr><th>VUID-VkViewport-y-01233</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>core</th><th> (y + height) must be less than or equal to viewportBoundsRange[1]</th></tr>
<tr><th>VUID-VkViewport-y-01775</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>core</th><th> y must be greater than or equal to viewportBoundsRange[0]</th></tr>
<tr><th>VUID-VkViewport-y-01776</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1,VK_AMD_negative_viewport_height)</th><th> y must be less than or equal to viewportBoundsRange[1]</th></tr>
<tr><th>VUID-VkViewport-y-01777</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>VkViewport</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1,VK_AMD_negative_viewport_height)</th><th> (y + height) must be greater than or equal to viewportBoundsRange[0]</th></tr>
<tr><th>VUID-VkViewportSwizzleNV-w-parameter</th><th><span style="color:limegreen;">Y</span></th><th>ViewportSwizzleNV</th><th>implicit</th><th>VkViewportSwizzleNV</th><th>(VK_NV_viewport_swizzle)</th><th> w must be a valid VkViewportCoordinateSwizzleNV value</th></tr>
<tr><th>VUID-VkViewportSwizzleNV-x-parameter</th><th><span style="color:limegreen;">Y</span></th><th>ViewportSwizzleNV</th><th>implicit</th><th>VkViewportSwizzleNV</th><th>(VK_NV_viewport_swizzle)</th><th> x must be a valid VkViewportCoordinateSwizzleNV value</th></tr>
<tr><th>VUID-VkViewportSwizzleNV-y-parameter</th><th><span style="color:limegreen;">Y</span></th><th>ViewportSwizzleNV</th><th>implicit</th><th>VkViewportSwizzleNV</th><th>(VK_NV_viewport_swizzle)</th><th> y must be a valid VkViewportCoordinateSwizzleNV value</th></tr>
<tr><th>VUID-VkViewportSwizzleNV-z-parameter</th><th><span style="color:limegreen;">Y</span></th><th>ViewportSwizzleNV</th><th>implicit</th><th>VkViewportSwizzleNV</th><th>(VK_NV_viewport_swizzle)</th><th> z must be a valid VkViewportCoordinateSwizzleNV value</th></tr>
<tr><th>VUID-VkWaylandSurfaceCreateInfoKHR-display-01304</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWaylandSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> display must point to a valid Wayland wl_display.</th></tr>
<tr><th>VUID-VkWaylandSurfaceCreateInfoKHR-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWaylandSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkWaylandSurfaceCreateInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWaylandSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkWaylandSurfaceCreateInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWaylandSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> sType must be VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkWaylandSurfaceCreateInfoKHR-surface-01305</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWaylandSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> surface must point to a valid Wayland wl_surface.</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-commonparent</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoKHR</th><th>(VK_KHR_win32_keyed_mutex)</th><th> Both of the elements of pAcquireSyncs, and the elements of pReleaseSyncs that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireKeys-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoKHR</th><th>(VK_KHR_win32_keyed_mutex)</th><th> If acquireCount is not 0, pAcquireKeys must be a valid pointer to an array of acquireCount uint64_t values</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireSyncs-00081</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoKHR</th><th>(VK_KHR_win32_keyed_mutex)</th><th> Each member of pAcquireSyncs and pReleaseSyncs must be a device memory object imported by setting VkImportMemoryWin32HandleInfoKHR::handleType to VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT.</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireSyncs-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoKHR</th><th>(VK_KHR_win32_keyed_mutex)</th><th> If acquireCount is not 0, pAcquireSyncs must be a valid pointer to an array of acquireCount valid VkDeviceMemory handles</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireTimeouts-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoKHR</th><th>(VK_KHR_win32_keyed_mutex)</th><th> If acquireCount is not 0, pAcquireTimeouts must be a valid pointer to an array of acquireCount uint32_t values</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseKeys-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoKHR</th><th>(VK_KHR_win32_keyed_mutex)</th><th> If releaseCount is not 0, pReleaseKeys must be a valid pointer to an array of releaseCount uint64_t values</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseSyncs-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoKHR</th><th>(VK_KHR_win32_keyed_mutex)</th><th> If releaseCount is not 0, pReleaseSyncs must be a valid pointer to an array of releaseCount valid VkDeviceMemory handles</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoKHR</th><th>(VK_KHR_win32_keyed_mutex)</th><th> sType must be VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-commonparent</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoNV</th><th>(VK_NV_win32_keyed_mutex)</th><th> Both of the elements of pAcquireSyncs, and the elements of pReleaseSyncs that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireKeys-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoNV</th><th>(VK_NV_win32_keyed_mutex)</th><th> If acquireCount is not 0, pAcquireKeys must be a valid pointer to an array of acquireCount uint64_t values</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireSyncs-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoNV</th><th>(VK_NV_win32_keyed_mutex)</th><th> If acquireCount is not 0, pAcquireSyncs must be a valid pointer to an array of acquireCount valid VkDeviceMemory handles</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireTimeoutMilliseconds-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoNV</th><th>(VK_NV_win32_keyed_mutex)</th><th> If acquireCount is not 0, pAcquireTimeoutMilliseconds must be a valid pointer to an array of acquireCount uint32_t values</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseKeys-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoNV</th><th>(VK_NV_win32_keyed_mutex)</th><th> If releaseCount is not 0, pReleaseKeys must be a valid pointer to an array of releaseCount uint64_t values</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseSyncs-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoNV</th><th>(VK_NV_win32_keyed_mutex)</th><th> If releaseCount is not 0, pReleaseSyncs must be a valid pointer to an array of releaseCount valid VkDeviceMemory handles</th></tr>
<tr><th>VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkWin32KeyedMutexAcquireReleaseInfoNV</th><th>(VK_NV_win32_keyed_mutex)</th><th> sType must be VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV</th></tr>
<tr><th>VUID-VkWin32SurfaceCreateInfoKHR-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32SurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkWin32SurfaceCreateInfoKHR-hinstance-01307</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWin32SurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> hinstance must be a valid Win32 HINSTANCE.</th></tr>
<tr><th>VUID-VkWin32SurfaceCreateInfoKHR-hwnd-01308</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkWin32SurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> hwnd must be a valid Win32 HWND.</th></tr>
<tr><th>VUID-VkWin32SurfaceCreateInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32SurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkWin32SurfaceCreateInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWin32SurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> sType must be VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> Both of dstSet, and the elements of pTexelBufferView that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorCount-00317</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must have identical descriptorType and stageFlags.</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorCount-00318</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must all either use immutable samplers or must all not use immutable samplers.</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorCount-03048</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>(VK_EXT_descriptor_indexing)</th><th> All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must have identical VkDescriptorBindingFlagBitsEXT.</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> descriptorCount must be greater than 0</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00319</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> descriptorType must match the type of dstBinding within dstSet</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00322</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pImageInfo must be a valid pointer to an array of descriptorCount valid VkDescriptorImageInfo structures</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00323</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBufferViewObject</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, pTexelBufferView must be a valid pointer to an array of descriptorCount valid VkBufferView handles</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00324</th><th><span style="color:limegreen;">Y</span></th><th>WriteDescriptorSetIntegrityCheck</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pBufferInfo must be a valid pointer to an array of descriptorCount valid VkDescriptorBufferInfo structures</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00325</th><th><span style="color:limegreen;">Y</span></th><th>SampleDescriptorUpdateError</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was not allocated with a layout that included immutable samplers for dstBinding with descriptorType, the sampler member of each element of pImageInfo must be a valid VkSampler object</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00326</th><th><span style="color:limegreen;">Y</span></th><th>DSUsageBitsErrors, ImageViewDescriptorUpdateError</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView and imageLayout members of each element of pImageInfo must be a valid VkImageView and VkImageLayout, respectively</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00327</th><th><span style="color:limegreen;">Y</span></th><th>DSBufferLimitErrors</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the offset member of each element of pBufferInfo must be a multiple of VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00328</th><th><span style="color:limegreen;">Y</span></th><th>DSBufferLimitErrors</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the offset member of each element of pBufferInfo must be a multiple of VkPhysicalDeviceLimits::minStorageBufferOffsetAlignment</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00329</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, and the buffer member of any element of pBufferInfo is the handle of a non-sparse buffer, then that buffer must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00330</th><th><span style="color:limegreen;">Y</span></th><th>PushDescriptorSetCmdPushBadArgs, DSUsageBitsErrors</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the buffer member of each element of pBufferInfo must have been created with VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT set</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00331</th><th><span style="color:limegreen;">Y</span></th><th>DSUsageBitsErrors</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the buffer member of each element of pBufferInfo must have been created with VK_BUFFER_USAGE_STORAGE_BUFFER_BIT set</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00332</th><th><span style="color:limegreen;">Y</span></th><th>DSBufferLimitErrors</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the range member of each element of pBufferInfo, or the effective range if range is VK_WHOLE_SIZE, must be less than or equal to VkPhysicalDeviceLimits::maxUniformBufferRange</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00333</th><th><span style="color:limegreen;">Y</span></th><th>DSBufferLimitErrors</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the range member of each element of pBufferInfo, or the effective range if range is VK_WHOLE_SIZE, must be less than or equal to VkPhysicalDeviceLimits::maxStorageBufferRange</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00334</th><th><span style="color:limegreen;">Y</span></th><th>DSUsageBitsErrors</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, the VkBuffer that each element of pTexelBufferView was created from must have been created with VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT set</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00335</th><th><span style="color:limegreen;">Y</span></th><th>DSUsageBitsErrors</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the VkBuffer that each element of pTexelBufferView was created from must have been created with VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00336</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have been created with the identity swizzle</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00337</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_SAMPLED_BIT set</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00338</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-00339</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_STORAGE_BIT set</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-01402</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, for each descriptor that will be accessed via load or store operations the imageLayout member for corresponding elements of pImageInfo must be VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-01403</th><th><span style="color:limegreen;">Y</span></th><th>WriteDescriptorSetIntegrityCheck</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the imageLayout member of each element of pImageInfo must be a member of the list given in Sampled Image or Combined Image Sampler, corresponding to its type</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-01946</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, then the imageView member of each pImageInfo element must have been created without a VkSamplerYcbcrConversionInfo structure in its pNext chain</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-01947</th><th><span style="color:limegreen;">Y</span></th><th>MultiplaneImageSamplerConversionMismatch</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and if any element of pImageInfo has a imageView member that was created with a VkSamplerYcbcrConversionInfo structure in its pNext chain, then dstSet must have been allocated with a layout that included immutable samplers for dstBinding</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-01948</th><th><span style="color:limegreen;">Y</span></th><th>MultiplaneImageSamplerConversionMismatch</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was allocated with a layout that included immutable samplers for dstBinding, then the imageView member of each element of pImageInfo which corresponds to an immutable sampler that enables sampler Y'CBCR conversion must have been created with a VkSamplerYcbcrConversionInfo structure in its pNext chain with an identically defined VkSamplerYcbcrConversionInfo to the corresponding immutable sampler</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-02219</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>(VK_EXT_inline_uniform_block)</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-02220</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>(VK_EXT_inline_uniform_block)</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-02221</th><th><span style="color:limegreen;">Y</span></th><th>InlineUniformBlockEXT</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>(VK_EXT_inline_uniform_block)</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, the pNext chain must include a VkWriteDescriptorSetInlineUniformBlockEXT structure whose dataSize member equals descriptorCount</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-02382</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>(VK_NV_ray_tracing)</th><th> If descriptorType is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, the pNext chain must include a VkWriteDescriptorSetAccelerationStructureNV structure whose accelerationStructureCount member equals descriptorCount</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-descriptorType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> descriptorType must be a valid VkDescriptorType value</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-dstArrayElement-00321</th><th><span style="color:limegreen;">Y</span></th><th>WriteDescriptorSetIntegrityCheck, DSUpdateOutOfBounds</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> The sum of dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by dstBinding, and all applicable consecutive bindings, as described by consecutive binding updates</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-dstBinding-00315</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDSUpdateIndex</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> dstBinding must be less than or equal to the maximum value of binding of all VkDescriptorSetLayoutBinding structures specified when dstSet's descriptor set layout was created</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-dstBinding-00316</th><th><span style="color:limegreen;">Y</span></th><th>DSUpdateEmptyBinding</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> dstBinding must be a binding with a non-zero descriptorCount</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-dstSet-00320</th><th><span style="color:limegreen;">Y</span></th><th>UpdateDestroyDescriptorSetLayout</th><th>explicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> dstSet must be a valid VkDescriptorSet handle</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkWriteDescriptorSetAccelerationStructureNV or VkWriteDescriptorSetInlineUniformBlockEXT</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET</th></tr>
<tr><th>VUID-VkWriteDescriptorSet-sType-unique</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSet</th><th>core</th><th> Each sType member in the pNext chain must be unique</th></tr>
<tr><th>VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-02236</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSetAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> accelerationStructureCount must be equal to descriptorCount in the extended structure</th></tr>
<tr><th>VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSetAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> accelerationStructureCount must be greater than 0</th></tr>
<tr><th>VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSetAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid VkAccelerationStructureNV handles</th></tr>
<tr><th>VUID-VkWriteDescriptorSetAccelerationStructureNV-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSetAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV</th></tr>
<tr><th>VUID-VkWriteDescriptorSetInlineUniformBlockEXT-dataSize-02222</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>VkWriteDescriptorSetInlineUniformBlockEXT</th><th>(VK_EXT_inline_uniform_block)</th><th> dataSize must be an integer multiple of 4</th></tr>
<tr><th>VUID-VkWriteDescriptorSetInlineUniformBlockEXT-dataSize-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSetInlineUniformBlockEXT</th><th>(VK_EXT_inline_uniform_block)</th><th> dataSize must be greater than 0</th></tr>
<tr><th>VUID-VkWriteDescriptorSetInlineUniformBlockEXT-pData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSetInlineUniformBlockEXT</th><th>(VK_EXT_inline_uniform_block)</th><th> pData must be a valid pointer to an array of dataSize bytes</th></tr>
<tr><th>VUID-VkWriteDescriptorSetInlineUniformBlockEXT-sType-sType</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>VkWriteDescriptorSetInlineUniformBlockEXT</th><th>(VK_EXT_inline_uniform_block)</th><th> sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT</th></tr>
<tr><th>VUID-VkXcbSurfaceCreateInfoKHR-connection-01310</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkXcbSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> connection must point to a valid X11 xcb_connection_t.</th></tr>
<tr><th>VUID-VkXcbSurfaceCreateInfoKHR-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkXcbSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkXcbSurfaceCreateInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkXcbSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkXcbSurfaceCreateInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkXcbSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> sType must be VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkXcbSurfaceCreateInfoKHR-window-01311</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkXcbSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> window must be a valid X11 xcb_window_t.</th></tr>
<tr><th>VUID-VkXlibSurfaceCreateInfoKHR-dpy-01313</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkXlibSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> dpy must point to a valid Xlib Display.</th></tr>
<tr><th>VUID-VkXlibSurfaceCreateInfoKHR-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkXlibSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> flags must be 0</th></tr>
<tr><th>VUID-VkXlibSurfaceCreateInfoKHR-pNext-pNext</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkXlibSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> pNext must be NULL</th></tr>
<tr><th>VUID-VkXlibSurfaceCreateInfoKHR-sType-sType</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>VkXlibSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> sType must be VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR</th></tr>
<tr><th>VUID-VkXlibSurfaceCreateInfoKHR-window-01314</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>VkXlibSurfaceCreateInfoKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> window must be a valid Xlib Window.</th></tr>
<tr><th>VUID-vkAcquireFullScreenExclusiveModeEXT-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireFullScreenExclusiveModeEXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkAcquireFullScreenExclusiveModeEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireFullScreenExclusiveModeEXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02674</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkAcquireFullScreenExclusiveModeEXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> swapchain must not be in the retired state</th></tr>
<tr><th>VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02675</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkAcquireFullScreenExclusiveModeEXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> swapchain must be a swapchain created with an instance of VkSurfaceFullScreenExclusiveInfoEXT, with fullScreenExclusive set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT</th></tr>
<tr><th>VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02676</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkAcquireFullScreenExclusiveModeEXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> swapchain must not currently have exclusive full-screen access</th></tr>
<tr><th>VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireFullScreenExclusiveModeEXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-vkAcquireNextImage2KHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImage2KHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkAcquireNextImage2KHR-pAcquireInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImage2KHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> pAcquireInfo must be a valid pointer to a valid VkAcquireNextImageInfoKHR structure</th></tr>
<tr><th>VUID-vkAcquireNextImage2KHR-pImageIndex-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImage2KHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> pImageIndex must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkAcquireNextImage2KHR-swapchain-01803</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkAcquireNextImage2KHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If the number of currently acquired images is greater than the difference between the number of images in the swapchain member of pAcquireInfo and the value of VkSurfaceCapabilitiesKHR::minImageCount as returned by a call to vkGetPhysicalDeviceSurfaceCapabilities2KHR with the surface used to create swapchain, the timeout member of pAcquireInfo must not be UINT64_MAX</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> Both of device, and swapchain that are valid handles must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-fence-01287</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If fence is not VK_NULL_HANDLE it must be unsignaled and must not be associated with any other queue command that has not yet completed execution on that queue</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-fence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-fence-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If fence is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-pImageIndex-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> pImageIndex must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-semaphore-01286</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If semaphore is not VK_NULL_HANDLE it must be unsignaled</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-semaphore-01779</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If semaphore is not VK_NULL_HANDLE it must not have any uncompleted signal or wait operations pending</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-semaphore-01780</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> semaphore and fence must not both be equal to VK_NULL_HANDLE</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-semaphore-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-semaphore-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If semaphore is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-swapchain-01285</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> swapchain must not be in the retired state</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-swapchain-01802</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If the number of currently acquired images is greater than the difference between the number of images in swapchain and the value of VkSurfaceCapabilitiesKHR::minImageCount as returned by a call to vkGetPhysicalDeviceSurfaceCapabilities2KHR with the surface used to create swapchain, timeout must not be UINT64_MAX</th></tr>
<tr><th>VUID-vkAcquireNextImageKHR-swapchain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireNextImageKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-vkAcquireXlibDisplayEXT-display-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireXlibDisplayEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display)</th><th> display must be a valid VkDisplayKHR handle</th></tr>
<tr><th>VUID-vkAcquireXlibDisplayEXT-dpy-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireXlibDisplayEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display)</th><th> dpy must be a valid pointer to a Display value</th></tr>
<tr><th>VUID-vkAcquireXlibDisplayEXT-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAcquireXlibDisplayEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkAllocateCommandBuffers-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAllocateCommandBuffers</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkAllocateCommandBuffers-pAllocateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAllocateCommandBuffers</th><th>core</th><th> pAllocateInfo must be a valid pointer to a valid VkCommandBufferAllocateInfo structure</th></tr>
<tr><th>VUID-vkAllocateCommandBuffers-pCommandBuffers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAllocateCommandBuffers</th><th>core</th><th> pCommandBuffers must be a valid pointer to an array of pAllocateInfo::commandBufferCount VkCommandBuffer handles</th></tr>
<tr><th>VUID-vkAllocateDescriptorSets-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAllocateDescriptorSets</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAllocateDescriptorSets</th><th>core</th><th> pAllocateInfo must be a valid pointer to a valid VkDescriptorSetAllocateInfo structure</th></tr>
<tr><th>VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAllocateDescriptorSets</th><th>core</th><th> pDescriptorSets must be a valid pointer to an array of pAllocateInfo::descriptorSetCount VkDescriptorSet handles</th></tr>
<tr><th>VUID-vkAllocateMemory-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAllocateMemory</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkAllocateMemory-pAllocateInfo-01713</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkAllocateMemory</th><th>core</th><th> pAllocateInfo->allocationSize must be less than or equal to VkPhysicalDeviceMemoryProperties::memoryHeaps[pAllocateInfo->memoryTypeIndex].size as returned by vkGetPhysicalDeviceMemoryProperties for the VkPhysicalDevice that device was created from.</th></tr>
<tr><th>VUID-vkAllocateMemory-pAllocateInfo-01714</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkAllocateMemory</th><th>core</th><th> pAllocateInfo->memoryTypeIndex must be less than VkPhysicalDeviceMemoryProperties::memoryTypeCount as returned by vkGetPhysicalDeviceMemoryProperties for the VkPhysicalDevice that device was created from.</th></tr>
<tr><th>VUID-vkAllocateMemory-pAllocateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAllocateMemory</th><th>core</th><th> pAllocateInfo must be a valid pointer to a valid VkMemoryAllocateInfo structure</th></tr>
<tr><th>VUID-vkAllocateMemory-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkAllocateMemory</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkAllocateMemory-pMemory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkAllocateMemory</th><th>core</th><th> pMemory must be a valid pointer to a VkDeviceMemory handle</th></tr>
<tr><th>VUID-vkBeginCommandBuffer-commandBuffer-00049</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkBeginCommandBuffer</th><th>core</th><th> commandBuffer must not be in the recording or pending state.</th></tr>
<tr><th>VUID-vkBeginCommandBuffer-commandBuffer-00050</th><th><span style="color:limegreen;">Y</span></th><th>CommandBufferResetErrors</th><th>explicit</th><th>vkBeginCommandBuffer</th><th>core</th><th> If commandBuffer was allocated from a VkCommandPool which did not have the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT flag set, commandBuffer must be in the initial state.</th></tr>
<tr><th>VUID-vkBeginCommandBuffer-commandBuffer-00051</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkBeginCommandBuffer</th><th>core</th><th> If commandBuffer is a secondary command buffer, the pInheritanceInfo member of pBeginInfo must be a valid VkCommandBufferInheritanceInfo structure</th></tr>
<tr><th>VUID-vkBeginCommandBuffer-commandBuffer-00052</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkBeginCommandBuffer</th><th>core</th><th> If commandBuffer is a secondary command buffer and either the occlusionQueryEnable member of the pInheritanceInfo member of pBeginInfo is VK_FALSE, or the precise occlusion queries feature is not enabled, the queryFlags member of the pInheritanceInfo member pBeginInfo must not contain VK_QUERY_CONTROL_PRECISE_BIT</th></tr>
<tr><th>VUID-vkBeginCommandBuffer-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBeginCommandBuffer</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkBeginCommandBuffer-pBeginInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBeginCommandBuffer</th><th>core</th><th> pBeginInfo must be a valid pointer to a valid VkCommandBufferBeginInfo structure</th></tr>
<tr><th>VUID-vkBindAccelerationStructureMemoryNV-bindInfoCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindAccelerationStructureMemoryNV</th><th>(VK_NV_ray_tracing)</th><th> bindInfoCount must be greater than 0</th></tr>
<tr><th>VUID-vkBindAccelerationStructureMemoryNV-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindAccelerationStructureMemoryNV</th><th>(VK_NV_ray_tracing)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkBindAccelerationStructureMemoryNV-pBindInfos-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindAccelerationStructureMemoryNV</th><th>(VK_NV_ray_tracing)</th><th> pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindAccelerationStructureMemoryInfoNV structures</th></tr>
<tr><th>VUID-vkBindBufferMemory-None-01898</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindBufferMemory</th><th>(VK_VERSION_1_1)</th><th> If buffer was created with the VK_BUFFER_CREATE_PROTECTED_BIT bit set, the buffer must be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT</th></tr>
<tr><th>VUID-vkBindBufferMemory-None-01899</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindBufferMemory</th><th>(VK_VERSION_1_1)</th><th> If buffer was created with the VK_BUFFER_CREATE_PROTECTED_BIT bit not set, the buffer must not be bound to a memory object created with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT</th></tr>
<tr><th>VUID-vkBindBufferMemory-buffer-01029</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>explicit</th><th>vkBindBufferMemory</th><th>core</th><th> buffer must not already be backed by a memory object</th></tr>
<tr><th>VUID-vkBindBufferMemory-buffer-01030</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>explicit</th><th>vkBindBufferMemory</th><th>core</th><th> buffer must not have been created with any sparse memory binding flags</th></tr>
<tr><th>VUID-vkBindBufferMemory-buffer-01038</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindBufferMemory</th><th>(VK_NV_dedicated_allocation)</th><th> If buffer was created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::buffer equal to a buffer handle created with identical creation parameters to buffer and memoryOffset must be zero</th></tr>
<tr><th>VUID-vkBindBufferMemory-buffer-01039</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindBufferMemory</th><th>(VK_NV_dedicated_allocation)+!(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If buffer was not created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image</th></tr>
<tr><th>VUID-vkBindBufferMemory-buffer-01444</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindBufferMemory</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If buffer requires a dedicated allocation(as reported by vkGetBufferMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for buffer), memory must have been created with VkMemoryDedicatedAllocateInfo::buffer equal to buffer</th></tr>
<tr><th>VUID-vkBindBufferMemory-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>VertexBufferInvalid</th><th>implicit</th><th>vkBindBufferMemory</th><th>core</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkBindBufferMemory-buffer-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindBufferMemory</th><th>core</th><th> buffer must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkBindBufferMemory-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindBufferMemory</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkBindBufferMemory-memory-01035</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>explicit</th><th>vkBindBufferMemory</th><th>core</th><th> memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer</th></tr>
<tr><th>VUID-vkBindBufferMemory-memory-01508</th><th><span style="color:limegreen;">Y</span></th><th>DedicatedAllocation</th><th>explicit</th><th>vkBindBufferMemory</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::buffer was not VK_NULL_HANDLE, then buffer must equal VkMemoryDedicatedAllocateInfo::buffer, and memoryOffset must be zero.</th></tr>
<tr><th>VUID-vkBindBufferMemory-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>implicit</th><th>vkBindBufferMemory</th><th>core</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-vkBindBufferMemory-memory-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindBufferMemory</th><th>core</th><th> memory must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkBindBufferMemory-memoryOffset-01031</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>explicit</th><th>vkBindBufferMemory</th><th>core</th><th> memoryOffset must be less than the size of memory</th></tr>
<tr><th>VUID-vkBindBufferMemory-memoryOffset-01036</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory, VertexBufferInvalid</th><th>explicit</th><th>vkBindBufferMemory</th><th>core</th><th> memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer</th></tr>
<tr><th>VUID-vkBindBufferMemory-size-01037</th><th><span style="color:limegreen;">Y</span></th><th>DedicatedAllocation, BindInvalidMemory</th><th>explicit</th><th>vkBindBufferMemory</th><th>core</th><th> The size member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer must be less than or equal to the size of memory minus memoryOffset</th></tr>
<tr><th>VUID-vkBindBufferMemory2-bindInfoCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindBufferMemory2</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> bindInfoCount must be greater than 0</th></tr>
<tr><th>VUID-vkBindBufferMemory2-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindBufferMemory2</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkBindBufferMemory2-pBindInfos-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindBufferMemory2</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindBufferMemoryInfo structures</th></tr>
<tr><th>VUID-vkBindImageMemory-None-01901</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindImageMemory</th><th>(VK_VERSION_1_1)</th><th> If image was created with the VK_IMAGE_CREATE_PROTECTED_BIT bit set, the image must be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT</th></tr>
<tr><th>VUID-vkBindImageMemory-None-01902</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindImageMemory</th><th>(VK_VERSION_1_1)</th><th> If image was created with the VK_IMAGE_CREATE_PROTECTED_BIT bit not set, the image must not be bound to a memory object created with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT</th></tr>
<tr><th>VUID-vkBindImageMemory-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindImageMemory</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkBindImageMemory-image-01044</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>explicit</th><th>vkBindImageMemory</th><th>core</th><th> image must not already be backed by a memory object</th></tr>
<tr><th>VUID-vkBindImageMemory-image-01045</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>explicit</th><th>vkBindImageMemory</th><th>core</th><th> image must not have been created with any sparse memory binding flags</th></tr>
<tr><th>VUID-vkBindImageMemory-image-01050</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindImageMemory</th><th>(VK_NV_dedicated_allocation)</th><th> If image was created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::image equal to an image handle created with identical creation parameters to image and memoryOffset must be zero</th></tr>
<tr><th>VUID-vkBindImageMemory-image-01051</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindImageMemory</th><th>(VK_NV_dedicated_allocation)+!(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If image was not created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image</th></tr>
<tr><th>VUID-vkBindImageMemory-image-01445</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindImageMemory</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)</th><th> If image requires a dedicated allocation (as reported by vkGetImageMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for image), memory must have been created with VkMemoryDedicatedAllocateInfo::image equal to image</th></tr>
<tr><th>VUID-vkBindImageMemory-image-01608</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindImageMemory</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> image must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT set.</th></tr>
<tr><th>VUID-vkBindImageMemory-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>BindMemoryToDestroyedObject</th><th>implicit</th><th>vkBindImageMemory</th><th>core</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkBindImageMemory-image-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindImageMemory</th><th>core</th><th> image must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkBindImageMemory-memory-01047</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>explicit</th><th>vkBindImageMemory</th><th>core</th><th> memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image</th></tr>
<tr><th>VUID-vkBindImageMemory-memory-01509</th><th><span style="color:limegreen;">Y</span></th><th>DedicatedAllocation</th><th>explicit</th><th>vkBindImageMemory</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+!(VK_NV_dedicated_allocation_image_aliasing)</th><th> If the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero.</th></tr>
<tr><th>VUID-vkBindImageMemory-memory-02628</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindImageMemory</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_NV_dedicated_allocation_image_aliasing)</th><th> If the dedicated allocation image aliasing feature is not enabled, and the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero.</th></tr>
<tr><th>VUID-vkBindImageMemory-memory-02629</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkBindImageMemory</th><th>(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_NV_dedicated_allocation_image_aliasing)</th><th> If the dedicated allocation image aliasing feature is enabled, and the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then memoryOffset must be zero, and image must be either equal to VkMemoryDedicatedAllocateInfo::image or an image that was created using the same parameters in VkImageCreateInfo, with the exception that extent and arrayLayers may differ subject to the following restrictions: every dimension in the extent parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created; and the arrayLayers parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created.</th></tr>
<tr><th>VUID-vkBindImageMemory-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>implicit</th><th>vkBindImageMemory</th><th>core</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-vkBindImageMemory-memory-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindImageMemory</th><th>core</th><th> memory must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkBindImageMemory-memoryOffset-01046</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>explicit</th><th>vkBindImageMemory</th><th>core</th><th> memoryOffset must be less than the size of memory</th></tr>
<tr><th>VUID-vkBindImageMemory-memoryOffset-01048</th><th><span style="color:limegreen;">Y</span></th><th>BindInvalidMemory</th><th>explicit</th><th>vkBindImageMemory</th><th>core</th><th> memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image</th></tr>
<tr><th>VUID-vkBindImageMemory-size-01049</th><th><span style="color:limegreen;">Y</span></th><th>DedicatedAllocation, BindInvalidMemory</th><th>explicit</th><th>vkBindImageMemory</th><th>core</th><th> The size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image must be less than or equal to the size of memory minus memoryOffset</th></tr>
<tr><th>VUID-vkBindImageMemory2-bindInfoCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindImageMemory2</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> bindInfoCount must be greater than 0</th></tr>
<tr><th>VUID-vkBindImageMemory2-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindImageMemory2</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkBindImageMemory2-pBindInfos-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkBindImageMemory2</th><th>(VK_VERSION_1_1,VK_KHR_bind_memory2)</th><th> pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindImageMemoryInfo structures</th></tr>
<tr><th>VUID-vkCmdBeginConditionalRenderingEXT-None-01980</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> Conditional rendering must not already be active</th></tr>
<tr><th>VUID-vkCmdBeginConditionalRenderingEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBeginConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdBeginConditionalRenderingEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBeginConditionalRenderingEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBeginConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBeginConditionalRenderingEXT-pConditionalRenderingBegin-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> pConditionalRenderingBegin must be a valid pointer to a valid VkConditionalRenderingBeginInfoEXT structure</th></tr>
<tr><th>VUID-vkCmdBeginDebugUtilsLabelEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBeginDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdBeginDebugUtilsLabelEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBeginDebugUtilsLabelEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBeginDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBeginDebugUtilsLabelEXT-pLabelInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure</th></tr>
<tr><th>VUID-vkCmdBeginQuery-None-00807</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQuery</th><th>core</th><th> All queries used by the command must be unavailable</th></tr>
<tr><th>VUID-vkCmdBeginQuery-commandBuffer-01885</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQuery</th><th>(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdBeginQuery-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQuery</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdBeginQuery-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQuery</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBeginQuery-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQuery</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBeginQuery-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQuery</th><th>core</th><th> Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBeginQuery-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQuery</th><th>core</th><th> flags must be a valid combination of VkQueryControlFlagBits values</th></tr>
<tr><th>VUID-vkCmdBeginQuery-query-00802</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQuery</th><th>core</th><th> query must be less than the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdBeginQuery-query-00808</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQuery</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If vkCmdBeginQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdBeginQuery-queryPool-01922</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQuery</th><th>core</th><th> queryPool must have been created with a queryType that differs from that of any queries that are active within commandBuffer</th></tr>
<tr><th>VUID-vkCmdBeginQuery-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQuery</th><th>core</th><th> queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkCmdBeginQuery-queryType-00800</th><th><span style="color:limegreen;">Y</span></th><th>QueryPreciseBit</th><th>explicit</th><th>vkCmdBeginQuery</th><th>core</th><th> If the precise occlusion queries feature is not enabled, or the queryType used to create queryPool was not VK_QUERY_TYPE_OCCLUSION, flags must not contain VK_QUERY_CONTROL_PRECISE_BIT</th></tr>
<tr><th>VUID-vkCmdBeginQuery-queryType-00803</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQuery</th><th>core</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_OCCLUSION, the VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBeginQuery-queryType-00804</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQuery</th><th>core</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate graphics operations, the VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBeginQuery-queryType-00805</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQuery</th><th>core</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate compute operations, the VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdBeginQuery-queryType-02327</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQuery</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBeginQuery-queryType-02328</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQuery</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT then VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackQueries must be supported</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-None-02330</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> All queries used by the command must be unavailable</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-commandBuffer-02336</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)+(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> flags must be a valid combination of VkQueryControlFlagBits values</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-query-02332</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> query must be less than the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-query-02337</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)+(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If vkCmdBeginQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-queryPool-02329</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> queryPool must have been created with a queryType that differs from that of any queries that are active within commandBuffer</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-queryType-02331</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the precise occlusion queries feature is not enabled, or the queryType used to create queryPool was not VK_QUERY_TYPE_OCCLUSION, flags must not contain VK_QUERY_CONTROL_PRECISE_BIT</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-queryType-02333</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_OCCLUSION, the VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-queryType-02334</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate graphics operations, the VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-queryType-02335</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate compute operations, the VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-queryType-02338</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-queryType-02339</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index parameter must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-queryType-02340</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was not VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index must be zero</th></tr>
<tr><th>VUID-vkCmdBeginQueryIndexedEXT-queryType-02341</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT then VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackQueries must be supported</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-bufferlevel</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> commandBuffer must be a primary VkCommandBuffer</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-contents-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> contents must be a valid VkSubpassContents value</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-framebuffer-02532</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> For any attachment in framebuffer that is used by renderPass and is bound to memory locations that are also bound to another attachment used by renderPass, and if at least one of those uses causes either attachment to be written to, both attachments must have had the VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT set</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-initialLayout-00895</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-initialLayout-00896</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-initialLayout-00897</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-initialLayout-00898</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_SRC_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-initialLayout-00899</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_DST_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-initialLayout-00900</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> If any of the initialLayout members of the VkAttachmentDescription structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is not VK_IMAGE_LAYOUT_UNDEFINED, then each such initialLayout must be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-initialLayout-01758</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass</th><th>(VK_VERSION_1_1,VK_KHR_maintenance2)</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-pRenderPassBegin-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> pRenderPassBegin must be a valid pointer to a valid VkRenderPassBeginInfo structure</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginWithinRenderPass</th><th>implicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass-srcStageMask-00901</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginRenderPass</th><th>core</th><th> The srcStageMask and dstStageMask members of any element of the pDependencies member of VkRenderPassCreateInfo used to create renderPass must be supported by the capabilities of the queue family identified by the queueFamilyIndex member of the VkCommandPoolCreateInfo used to create the command pool which commandBuffer was allocated from</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-bufferlevel</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> commandBuffer must be a primary VkCommandBuffer</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-framebuffer-02533</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> For any attachment in framebuffer that is used by renderPass and is bound to memory locations that are also bound to another attachment used by renderPass, and if at least one of those uses causes either attachment to be written to, both attachments must have had the VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT set</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-initialLayout-03094</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-initialLayout-03096</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-initialLayout-03097</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-initialLayout-03098</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_SRC_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-initialLayout-03099</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginLayoutsFramebufferImageUsageMismatches</th><th>explicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_DST_BIT</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-initialLayout-03100</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If any of the initialLayout members of the VkAttachmentDescription structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is not VK_IMAGE_LAYOUT_UNDEFINED, then each such initialLayout must be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-pRenderPassBegin-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pRenderPassBegin must be a valid pointer to a valid VkRenderPassBeginInfo structure</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-pSubpassBeginInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pSubpassBeginInfo must be a valid pointer to a valid VkSubpassBeginInfoKHR structure</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassBeginWithinRenderPass</th><th>implicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdBeginRenderPass2KHR-srcStageMask-03101</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The srcStageMask and dstStageMask members of any element of the pDependencies member of VkRenderPassCreateInfo used to create renderPass must be supported by the capabilities of the queue family identified by the queueFamilyIndex member of the VkCommandPoolCreateInfo used to create the command pool which commandBuffer was allocated from</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-None-02367</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> Transform feedback must not be active</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-None-02373</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)+(VK_VERSION_1_1,VK_KHR_multiview)</th><th> Transform feedback must not be made active in a render pass instance with multiview enabled</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> Both of commandBuffer, and the elements of pCounterBuffers that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-counterBufferCount-02607</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> If counterBufferCount is not 0, and pCounterBuffers is not NULL, pCounterBuffers must be a valid pointer to an array of counterBufferCount VkBuffer handles that are either valid or VK_NULL_HANDLE</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-firstCounterBuffer-02368</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> firstCounterBuffer must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-firstCounterBuffer-02369</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> The sum of firstCounterBuffer and counterBufferCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-pCounterBuffer-02371</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> If pCounterBuffer is NULL, then pCounterBufferOffsets must also be NULL</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-pCounterBufferOffsets-02370</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> For each buffer handle in the array, if it is not VK_NULL_HANDLE it must reference a buffer large enough to hold 4 bytes at the corresponding offset from the pCounterBufferOffsets array</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-pCounterBufferOffsets-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> If counterBufferCount is not 0, and pCounterBufferOffsets is not NULL, pCounterBufferOffsets must be a valid pointer to an array of counterBufferCount VkDeviceSize values</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-pCounterBuffers-02372</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> For each buffer handle in the pCounterBuffers array that is not VK_NULL_HANDLE it must have been created with a usage value containing VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-renderpass</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdBeginTransformFeedbackEXT-transformFeedback-02366</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBeginTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> Each of commandBuffer, layout, and the elements of pDescriptorSets must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> descriptorSetCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-dynamicOffsetCount-00359</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> dynamicOffsetCount must be equal to the total number of dynamic descriptors in pDescriptorSets</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-firstSet-00360</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> The sum of firstSet and descriptorSetCount must be less than or equal to VkPipelineLayoutCreateInfo::setLayoutCount provided when layout was created</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-layout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>DescriptorSetCompatibility</th><th>implicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> layout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-pDescriptorSets-00358</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> Each element of pDescriptorSets must have been allocated with a VkDescriptorSetLayout that matches (is the same as, or identically defined as) the VkDescriptorSetLayout at set n in layout, where n is the sum of firstSet and the index into pDescriptorSets</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-pDescriptorSets-01979</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> For each dynamic uniform or storage buffer binding in pDescriptorSets, the sum of the effective offset, as defined above, and the range of the binding must be less than or equal to the size of the buffer</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDescriptorSet</th><th>implicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> pDescriptorSets must be a valid pointer to an array of descriptorSetCount valid VkDescriptorSet handles</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01971</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> Each element of pDynamicOffsets which corresponds to a descriptor binding with type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must be a multiple of VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01972</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> Each element of pDynamicOffsets which corresponds to a descriptor binding with type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must be a multiple of VkPhysicalDeviceLimits::minStorageBufferOffsetAlignment</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> If dynamicOffsetCount is not 0, pDynamicOffsets must be a valid pointer to an array of dynamicOffsetCount uint32_t values</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-pipelineBindPoint-00361</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> pipelineBindPoint must be supported by the commandBuffer's parent VkCommandPool's queue family</th></tr>
<tr><th>VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindDescriptorSets</th><th>core</th><th> pipelineBindPoint must be a valid VkPipelineBindPoint value</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-buffer-00433</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindIndexBuffer</th><th>core</th><th> buffer must have been created with the VK_BUFFER_USAGE_INDEX_BUFFER_BIT flag</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-buffer-00434</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindIndexBuffer</th><th>core</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindIndexBuffer</th><th>core</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindIndexBuffer</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindIndexBuffer</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindIndexBuffer</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindIndexBuffer</th><th>core</th><th> Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-indexType-02507</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindIndexBuffer</th><th>(VK_NV_ray_tracing)</th><th> indexType must not be VK_INDEX_TYPE_NONE_NV.</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-indexType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindIndexBuffer</th><th>core</th><th> indexType must be a valid VkIndexType value</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-offset-00431</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindIndexBuffer</th><th>core</th><th> offset must be less than the size of buffer</th></tr>
<tr><th>VUID-vkCmdBindIndexBuffer-offset-00432</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindIndexBuffer</th><th>core</th><th> The sum of offset and the address of the range of VkDeviceMemory object that is backing buffer, must be a multiple of the type indicated by indexType</th></tr>
<tr><th>VUID-vkCmdBindPipeline-None-02323</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindPipeline</th><th>(VK_EXT_transform_feedback)</th><th> This command must not be recorded when transform feedback is active</th></tr>
<tr><th>VUID-vkCmdBindPipeline-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindPipeline</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdBindPipeline-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindPipeline</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBindPipeline-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindPipeline</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBindPipeline-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindPipeline</th><th>core</th><th> Both of commandBuffer, and pipeline must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBindPipeline-pipeline-00781</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindPipeline</th><th>core</th><th> If the variable multisample rate feature is not supported, pipeline is a graphics pipeline, the current subpass has no attachments, and this is not the first call to this function with a graphics pipeline after transitioning to the current subpass, then the sample count specified by this pipeline must match that set in the previous pipeline</th></tr>
<tr><th>VUID-vkCmdBindPipeline-pipeline-parameter</th><th><span style="color:limegreen;">Y</span></th><th>PipelineNotBound, InvalidPipeline</th><th>implicit</th><th>vkCmdBindPipeline</th><th>core</th><th> pipeline must be a valid VkPipeline handle</th></tr>
<tr><th>VUID-vkCmdBindPipeline-pipelineBindPoint-00777</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindPipeline</th><th>core</th><th> If pipelineBindPoint is VK_PIPELINE_BIND_POINT_COMPUTE, the VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdBindPipeline-pipelineBindPoint-00778</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindPipeline</th><th>core</th><th> If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, the VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBindPipeline-pipelineBindPoint-00779</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindPipeline</th><th>core</th><th> If pipelineBindPoint is VK_PIPELINE_BIND_POINT_COMPUTE, pipeline must be a compute pipeline</th></tr>
<tr><th>VUID-vkCmdBindPipeline-pipelineBindPoint-00780</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindPipeline</th><th>core</th><th> If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline must be a graphics pipeline</th></tr>
<tr><th>VUID-vkCmdBindPipeline-pipelineBindPoint-02391</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindPipeline</th><th>(VK_NV_ray_tracing)</th><th> If pipelineBindPoint is VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, the VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdBindPipeline-pipelineBindPoint-02392</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindPipeline</th><th>(VK_NV_ray_tracing)</th><th> If pipelineBindPoint is VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, the pipeline must be a ray tracing pipeline</th></tr>
<tr><th>VUID-vkCmdBindPipeline-pipelineBindPoint-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindPipeline</th><th>core</th><th> pipelineBindPoint must be a valid VkPipelineBindPoint value</th></tr>
<tr><th>VUID-vkCmdBindPipeline-variableSampleLocations-01525</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindPipeline</th><th>(VK_EXT_sample_locations)</th><th> If VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_FALSE, and pipeline is a graphics pipeline created with a VkPipelineSampleLocationsStateCreateInfoEXT structure having its sampleLocationsEnable member set to VK_TRUE but without VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT enabled then the current render pass instance must have been begun by specifying a VkRenderPassSampleLocationsBeginInfoEXT structure whose pPostSubpassSampleLocations member contains an element with a subpassIndex matching the current subpass index and the sampleLocationsInfo member of that element must match the sampleLocationsInfo specified in VkPipelineSampleLocationsStateCreateInfoEXT when the pipeline was created</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-None-02058</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> The shading rate image feature must be enabled.</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> Both of commandBuffer, and imageView must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-imageLayout-02063</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> If imageView is not VK_NULL_HANDLE, imageLayout must be VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV or VK_IMAGE_LAYOUT_GENERAL.</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-imageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> imageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-imageView-02059</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> If imageView is not VK_NULL_HANDLE, it must be a valid VkImageView handle of type VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY.</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-imageView-02060</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> If imageView is not VK_NULL_HANDLE, it must have a format of VK_FORMAT_R8_UINT.</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-imageView-02061</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> If imageView is not VK_NULL_HANDLE, it must have been created with a usage value including VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-imageView-02062</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> If imageView is not VK_NULL_HANDLE, imageLayout must match the actual VkImageLayout of each subresource accessible from imageView at the time the subresource is accessed.</th></tr>
<tr><th>VUID-vkCmdBindShadingRateImageNV-imageView-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindShadingRateImageNV</th><th>(VK_NV_shading_rate_image)</th><th> imageView must be a valid VkImageView handle</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-None-02365</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> Transform feedback must not be active when the vkCmdBindTransformFeedbackBuffersEXT command is recorded</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> If pSizes is not NULL, bindingCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> Both of commandBuffer, and the elements of pBuffers must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-firstBinding-02356</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> firstBinding must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-firstBinding-02357</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> The sum of firstBinding and bindingCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-pBuffers-02360</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> All elements of pBuffers must have been created with the VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT flag</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-pBuffers-02364</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> Each element of pBuffers that is non-sparse must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-pBuffers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> pBuffers must be a valid pointer to an array of bindingCount valid VkBuffer handles</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02358</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> All elements of pOffsets must be less than the size of the corresponding element in pBuffers</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02359</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> All elements of pOffsets must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02363</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> All elements of pOffsets plus pSizes, where the pSizes, element is not VK_WHOLE_SIZE, must be less than or equal to the size of the corresponding element in pBuffers</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> pOffsets must be a valid pointer to an array of bindingCount VkDeviceSize values</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-pSize-02361</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the optional pSize array is specified, each element of pSizes must either be VK_WHOLE_SIZE, or be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBufferSize</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-pSizes-02362</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> All elements of pSizes must be less than or equal to the size of the corresponding buffer in pBuffers</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-pSizes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> If pSizes is not NULL, pSizes must be a valid pointer to an array of bindingCount VkDeviceSize values</th></tr>
<tr><th>VUID-vkCmdBindTransformFeedbackBuffersEXT-transformFeedback-02355</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindTransformFeedbackBuffersEXT</th><th>(VK_EXT_transform_feedback)</th><th> VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-bindingCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> bindingCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> Both of commandBuffer, and the elements of pBuffers must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-firstBinding-00624</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> firstBinding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-firstBinding-00625</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> The sum of firstBinding and bindingCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-pBuffers-00627</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> All elements of pBuffers must have been created with the VK_BUFFER_USAGE_VERTEX_BUFFER_BIT flag</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-pBuffers-00628</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> Each element of pBuffers that is non-sparse must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-pBuffers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> pBuffers must be a valid pointer to an array of bindingCount valid VkBuffer handles</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-pOffsets-00626</th><th><span style="color:limegreen;">Y</span></th><th>BadVertexBufferOffset</th><th>explicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> All elements of pOffsets must be less than the size of the corresponding element in pBuffers</th></tr>
<tr><th>VUID-vkCmdBindVertexBuffers-pOffsets-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBindVertexBuffers</th><th>core</th><th> pOffsets must be a valid pointer to an array of bindingCount VkDeviceSize values</th></tr>
<tr><th>VUID-vkCmdBlitImage-commandBuffer-01834</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image</th></tr>
<tr><th>VUID-vkCmdBlitImage-commandBuffer-01835</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image</th></tr>
<tr><th>VUID-vkCmdBlitImage-commandBuffer-01836</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image</th></tr>
<tr><th>VUID-vkCmdBlitImage-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdBlitImage-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBlitImage-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBlitImage-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImage-00224</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImage-00225</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImage-00234</th><th><span style="color:limegreen;">Y</span></th><th>ImageSampleCounts, MiscBlitImageTests</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> dstImage must have been created with a samples value of VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImage-01562</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> dstImage must not use a format listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImage-02000</th><th><span style="color:limegreen;">Y</span></th><th>BlitToDepthImageTests, BlitImageFormatTypes</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> The format features of dstImage must contain VK_FORMAT_FEATURE_BLIT_DST_BIT.</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImage-02545</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>(VK_EXT_fragment_density_map)</th><th> dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> dstImage must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImageLayout-00226</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageLayout</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImageLayout-00227</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageLayout</th><th>explicit</th><th>vkCmdBlitImage</th><th>!(VK_KHR_shared_presentable_image)</th><th> dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImageLayout-01399</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>(VK_KHR_shared_presentable_image)</th><th> dstImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstImageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> dstImageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstSubresource-01706</th><th><span style="color:limegreen;">Y</span></th><th>MiscBlitImageTests</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created</th></tr>
<tr><th>VUID-vkCmdBlitImage-dstSubresource-01708</th><th><span style="color:limegreen;">Y</span></th><th>MiscBlitImageTests</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created</th></tr>
<tr><th>VUID-vkCmdBlitImage-filter-00237</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageFilters</th><th>explicit</th><th>vkCmdBlitImage</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If filter is VK_FILTER_CUBIC_EXT, srcImage must have a VkImageType of VK_IMAGE_TYPE_2D</th></tr>
<tr><th>VUID-vkCmdBlitImage-filter-02001</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageFilters</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> If filter is VK_FILTER_LINEAR, then the format features of srcImage must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdBlitImage-filter-02002</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageFilters</th><th>explicit</th><th>vkCmdBlitImage</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If filter is VK_FILTER_CUBIC_EXT, then the format features of srcImage must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT.</th></tr>
<tr><th>VUID-vkCmdBlitImage-filter-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> filter must be a valid VkFilter value</th></tr>
<tr><th>VUID-vkCmdBlitImage-pRegions-00215</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets, MiscBlitImageTests</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> The source region specified by each element of pRegions must be a region that is contained within srcImage</th></tr>
<tr><th>VUID-vkCmdBlitImage-pRegions-00216</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageOffsets, MiscBlitImageTests</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> The destination region specified by each element of pRegions must be a region that is contained within dstImage</th></tr>
<tr><th>VUID-vkCmdBlitImage-pRegions-00217</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> The union of all destination regions, specified by the elements of pRegions, must not overlap in memory with any texel that may be sampled during the blit operation</th></tr>
<tr><th>VUID-vkCmdBlitImage-pRegions-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> pRegions must be a valid pointer to an array of regionCount valid VkImageBlit structures</th></tr>
<tr><th>VUID-vkCmdBlitImage-regionCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> regionCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdBlitImage-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-00219</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-00220</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-00228</th><th><span style="color:limegreen;">Y</span></th><th>ImageSampleCounts, MiscBlitImageTests</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> The sample count of srcImage and dstImage must both be equal to VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-00229</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageFormatTypes</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> If either of srcImage or dstImage was created with a signed integer VkFormat, the other must also have been created with a signed integer VkFormat</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-00230</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageFormatTypes</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> If either of srcImage or dstImage was created with an unsigned integer VkFormat, the other must also have been created with an unsigned integer VkFormat</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-00231</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageFormatTypes</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> If either of srcImage or dstImage was created with a depth/stencil format, the other must have exactly the same format</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-00232</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> If srcImage was created with a depth/stencil format, filter must be VK_FILTER_NEAREST</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-00233</th><th><span style="color:limegreen;">Y</span></th><th>ImageSampleCounts, MiscBlitImageTests</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> srcImage must have been created with a samples value of VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-01561</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> srcImage must not use a format listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-01999</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageFormatTypes</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> The format features of srcImage must contain VK_FORMAT_FEATURE_BLIT_SRC_BIT.</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> srcImage must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImageLayout-00221</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageLayout</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImageLayout-00222</th><th><span style="color:limegreen;">Y</span></th><th>BlitImageLayout</th><th>explicit</th><th>vkCmdBlitImage</th><th>!(VK_KHR_shared_presentable_image)</th><th> srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImageLayout-01398</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdBlitImage</th><th>(VK_KHR_shared_presentable_image)</th><th> srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcImageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBlitImage</th><th>core</th><th> srcImageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcSubresource-01705</th><th><span style="color:limegreen;">Y</span></th><th>MiscBlitImageTests</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created</th></tr>
<tr><th>VUID-vkCmdBlitImage-srcSubresource-01707</th><th><span style="color:limegreen;">Y</span></th><th>MiscBlitImageTests</th><th>explicit</th><th>vkCmdBlitImage</th><th>core</th><th> The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> The VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> Each of commandBuffer, dst, instanceData, scratch, and src that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-dst-02488</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> dst must have been created with compatible VkAccelerationStructureInfoNV where VkAccelerationStructureInfoNV::type and VkAccelerationStructureInfoNV::flags are identical, VkAccelerationStructureInfoNV::instanceCount and VkAccelerationStructureInfoNV::geometryCount for dst are greater than or equal to the build size and each geometry in VkAccelerationStructureInfoNV::pGeometries for dst has greater than or equal to the number of vertices, indices, and AABBs.</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-dst-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> dst must be a valid VkAccelerationStructureNV handle</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-geometryCount-02241</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> geometryCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-instanceData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> If instanceData is not VK_NULL_HANDLE, instanceData must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-pInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> pInfo must be a valid pointer to a valid VkAccelerationStructureInfoNV structure</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-scratch-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> scratch must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-src-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> If src is not VK_NULL_HANDLE, src must be a valid VkAccelerationStructureNV handle</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-update-02489</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> If update is VK_TRUE, src must not be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-update-02490</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> If update is VK_TRUE, src must have been built before with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV set in VkAccelerationStructureInfoNV::flags</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-update-02491</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> If update is VK_FALSE, The size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with VkAccelerationStructureMemoryRequirementsInfoNV::accelerationStructure set to dst and VkAccelerationStructureMemoryRequirementsInfoNV::type set to VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV must be less than or equal to the size of scratch minus scratchOffset</th></tr>
<tr><th>VUID-vkCmdBuildAccelerationStructureNV-update-02492</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdBuildAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> If update is VK_TRUE, The size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with VkAccelerationStructureMemoryRequirementsInfoNV::accelerationStructure set to dst and VkAccelerationStructureMemoryRequirementsInfoNV::type set to VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV must be less than or equal to the size of scratch minus scratchOffset</th></tr>
<tr><th>VUID-vkCmdClearAttachments-aspectMask-02501</th><th><span style="color:limegreen;">Y</span></th><th>MissingClearAttachment</th><th>explicit</th><th>vkCmdClearAttachments</th><th>core</th><th> If the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_COLOR_BIT, then the colorAttachment member of that element must either refer to a color attachment which is VK_ATTACHMENT_UNUSED, or must be a valid color attachment.</th></tr>
<tr><th>VUID-vkCmdClearAttachments-aspectMask-02502</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearAttachments</th><th>core</th><th> If the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_DEPTH_BIT, then the current subpass' depth/stencil attachment must either be VK_ATTACHMENT_UNUSED, or must have a depth component</th></tr>
<tr><th>VUID-vkCmdClearAttachments-aspectMask-02503</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearAttachments</th><th>core</th><th> If the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_STENCIL_BIT, then the current subpass' depth/stencil attachment must either be VK_ATTACHMENT_UNUSED, or must have a stencil component</th></tr>
<tr><th>VUID-vkCmdClearAttachments-attachmentCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearAttachments</th><th>core</th><th> attachmentCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdClearAttachments-baseArrayLayer-00018</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearAttachments</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the render pass instance this is recorded in uses multiview, then baseArrayLayer must be zero and layerCount must be one.</th></tr>
<tr><th>VUID-vkCmdClearAttachments-commandBuffer-02504</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearAttachments</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then each attachment to be cleared must not be a protected image.</th></tr>
<tr><th>VUID-vkCmdClearAttachments-commandBuffer-02505</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearAttachments</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then each attachment to be cleared must not be an unprotected image.</th></tr>
<tr><th>VUID-vkCmdClearAttachments-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearAttachments</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdClearAttachments-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearAttachments</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdClearAttachments-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearAttachments</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdClearAttachments-layerCount-01934</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearAttachments</th><th>core</th><th> The layerCount member of each element of pRects must not be 0</th></tr>
<tr><th>VUID-vkCmdClearAttachments-pAttachments-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearAttachments</th><th>core</th><th> pAttachments must be a valid pointer to an array of attachmentCount valid VkClearAttachment structures</th></tr>
<tr><th>VUID-vkCmdClearAttachments-pRects-00016</th><th><span style="color:limegreen;">Y</span></th><th>SecondaryCommandBufferClearColorAttachmentsRenderArea, CmdClearAttachmentTests</th><th>explicit</th><th>vkCmdClearAttachments</th><th>core</th><th> The rectangular region specified by each element of pRects must be contained within the render area of the current render pass instance</th></tr>
<tr><th>VUID-vkCmdClearAttachments-pRects-00017</th><th><span style="color:limegreen;">Y</span></th><th>CmdClearAttachmentTests</th><th>explicit</th><th>vkCmdClearAttachments</th><th>core</th><th> The layers specified by each element of pRects must be contained within every attachment that pAttachments refers to</th></tr>
<tr><th>VUID-vkCmdClearAttachments-pRects-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearAttachments</th><th>core</th><th> pRects must be a valid pointer to an array of rectCount VkClearRect structures</th></tr>
<tr><th>VUID-vkCmdClearAttachments-rect-02682</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearAttachments</th><th>core</th><th> The rect member of each element of pRects must have an extent.width greater than 0</th></tr>
<tr><th>VUID-vkCmdClearAttachments-rect-02683</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearAttachments</th><th>core</th><th> The rect member of each element of pRects must have an extent.height greater than 0</th></tr>
<tr><th>VUID-vkCmdClearAttachments-rectCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearAttachments</th><th>core</th><th> rectCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdClearAttachments-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearAttachments</th><th>core</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdClearColorImage-aspectMask-02498</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearColorImage</th><th>core</th><th> The VkImageSubresourceRange::aspectMask members of the elements of the pRanges array must each only include VK_IMAGE_ASPECT_COLOR_BIT</th></tr>
<tr><th>VUID-vkCmdClearColorImage-baseArrayLayer-01472</th><th><span style="color:limegreen;">Y</span></th><th>ClearColorImageWithBadRange</th><th>explicit</th><th>vkCmdClearColorImage</th><th>core</th><th> The VkImageSubresourceRange::baseArrayLayer members of the elements of the pRanges array must each be less than the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-vkCmdClearColorImage-baseMipLevel-01470</th><th><span style="color:limegreen;">Y</span></th><th>ClearColorImageWithBadRange</th><th>explicit</th><th>vkCmdClearColorImage</th><th>core</th><th> The VkImageSubresourceRange::baseMipLevel members of the elements of the pRanges array must each be less than the mipLevels specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-vkCmdClearColorImage-commandBuffer-01805</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearColorImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then image must not be a protected image</th></tr>
<tr><th>VUID-vkCmdClearColorImage-commandBuffer-01806</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearColorImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then image must not be an unprotected image</th></tr>
<tr><th>VUID-vkCmdClearColorImage-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearColorImage</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdClearColorImage-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearColorImage</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdClearColorImage-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearColorImage</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdClearColorImage-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearColorImage</th><th>core</th><th> Both of commandBuffer, and image must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdClearColorImage-image-00002</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdClearColorImage</th><th>core</th><th> image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdClearColorImage-image-00003</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdClearColorImage</th><th>core</th><th> If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdClearColorImage-image-00007</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdClearColorImage</th><th>core</th><th> image must not have a compressed or depth/stencil format</th></tr>
<tr><th>VUID-vkCmdClearColorImage-image-01545</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearColorImage</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> image must not use a format listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views</th></tr>
<tr><th>VUID-vkCmdClearColorImage-image-01993</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdClearColorImage</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> The format features of image must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.</th></tr>
<tr><th>VUID-vkCmdClearColorImage-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearColorImage</th><th>core</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkCmdClearColorImage-imageLayout-00004</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageLayout</th><th>explicit</th><th>vkCmdClearColorImage</th><th>core</th><th> imageLayout must specify the layout of the image subresource ranges of image specified in pRanges at the time this command is executed on a VkDevice</th></tr>
<tr><th>VUID-vkCmdClearColorImage-imageLayout-00005</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageLayout</th><th>explicit</th><th>vkCmdClearColorImage</th><th>!(VK_KHR_shared_presentable_image)</th><th> imageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdClearColorImage-imageLayout-01394</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearColorImage</th><th>(VK_KHR_shared_presentable_image)</th><th> imageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</th></tr>
<tr><th>VUID-vkCmdClearColorImage-imageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearColorImage</th><th>core</th><th> imageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdClearColorImage-pColor-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearColorImage</th><th>core</th><th> pColor must be a valid pointer to a valid VkClearColorValue union</th></tr>
<tr><th>VUID-vkCmdClearColorImage-pRanges-01692</th><th><span style="color:limegreen;">Y</span></th><th>ClearColorImageWithBadRange</th><th>explicit</th><th>vkCmdClearColorImage</th><th>core</th><th> For each VkImageSubresourceRange element of pRanges, if the levelCount member is not VK_REMAINING_MIP_LEVELS, then baseMipLevel + levelCount must be less than the mipLevels specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-vkCmdClearColorImage-pRanges-01693</th><th><span style="color:limegreen;">Y</span></th><th>ClearColorImageWithBadRange</th><th>explicit</th><th>vkCmdClearColorImage</th><th>core</th><th> For each VkImageSubresourceRange element of pRanges, if the layerCount member is not VK_REMAINING_ARRAY_LAYERS, then baseArrayLayer + layerCount must be less than the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-vkCmdClearColorImage-pRanges-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearColorImage</th><th>core</th><th> pRanges must be a valid pointer to an array of rangeCount valid VkImageSubresourceRange structures</th></tr>
<tr><th>VUID-vkCmdClearColorImage-rangeCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearColorImage</th><th>core</th><th> rangeCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdClearColorImage-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearColorImage</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-aspectMask-02499</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> The VkImageSubresourceRange::aspectMask members of the elements of the pRanges array must each only include VK_IMAGE_ASPECT_DEPTH_BIT if the image format has a depth component</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-aspectMask-02500</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> The VkImageSubresourceRange::aspectMask members of the elements of the pRanges array must each only include VK_IMAGE_ASPECT_STENCIL_BIT if the image format has a stencil component</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-baseArrayLayer-01476</th><th><span style="color:limegreen;">Y</span></th><th>ClearDepthStencilWithBadRange</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> The VkImageSubresourceRange::baseArrayLayer members of the elements of the pRanges array must each be less than the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-baseMipLevel-01474</th><th><span style="color:limegreen;">Y</span></th><th>ClearDepthStencilWithBadRange</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> The VkImageSubresourceRange::baseMipLevel members of the elements of the pRanges array must each be less than the mipLevels specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-commandBuffer-01807</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then image must not be a protected image</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-commandBuffer-01808</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then image must not be an unprotected image</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> Both of commandBuffer, and image must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-image-00009</th><th><span style="color:limegreen;">Y</span></th><th>ClearDepthStencilImageErrors</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>!(VK_EXT_separate_stencil_usage)</th><th> image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-image-00010</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-image-00014</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> image must have a depth/stencil format</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-image-01994</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> The format features of image must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-imageLayout-00011</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageLayout</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> imageLayout must specify the layout of the image subresource ranges of image specified in pRanges at the time this command is executed on a VkDevice</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-imageLayout-00012</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageLayout</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> imageLayout must be either of VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-imageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> imageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-pDepthStencil-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> pDepthStencil must be a valid pointer to a valid VkClearDepthStencilValue structure</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-pRanges-01694</th><th><span style="color:limegreen;">Y</span></th><th>ClearDepthStencilWithBadRange</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> For each VkImageSubresourceRange element of pRanges, if the levelCount member is not VK_REMAINING_MIP_LEVELS, then baseMipLevel + levelCount must be less than the mipLevels specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-pRanges-01695</th><th><span style="color:limegreen;">Y</span></th><th>ClearDepthStencilWithBadRange</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> For each VkImageSubresourceRange element of pRanges, if the layerCount member is not VK_REMAINING_ARRAY_LAYERS, then baseArrayLayer + layerCount must be less than the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-pRanges-02658</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>(VK_EXT_separate_stencil_usage)</th><th> If any element of pRanges.aspect includes VK_IMAGE_ASPECT_STENCIL_BIT, and image was created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageStencilUsageCreateInfoEXT::stencilUsage used to create image</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-pRanges-02659</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>(VK_EXT_separate_stencil_usage)</th><th> If any element of pRanges.aspect includes VK_IMAGE_ASPECT_STENCIL_BIT, and image was not created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageCreateInfo::usage used to create image</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-pRanges-02660</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdClearDepthStencilImage</th><th>(VK_EXT_separate_stencil_usage)</th><th> If any element of pRanges.aspect includes VK_IMAGE_ASPECT_DEPTH_BIT, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageCreateInfo::usage used to create image</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-pRanges-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> pRanges must be a valid pointer to an array of rangeCount valid VkImageSubresourceRange structures</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-rangeCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> rangeCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdClearDepthStencilImage-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>ClearDepthStencilImageErrors</th><th>implicit</th><th>vkCmdClearDepthStencilImage</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdCopyAccelerationStructureNV-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdCopyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> The VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdCopyAccelerationStructureNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyAccelerationStructureNV-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdCopyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdCopyAccelerationStructureNV-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> Each of commandBuffer, dst, and src must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdCopyAccelerationStructureNV-dst-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> dst must be a valid VkAccelerationStructureNV handle</th></tr>
<tr><th>VUID-vkCmdCopyAccelerationStructureNV-mode-02496</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV or VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV</th></tr>
<tr><th>VUID-vkCmdCopyAccelerationStructureNV-mode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> mode must be a valid VkCopyAccelerationStructureModeNV value</th></tr>
<tr><th>VUID-vkCmdCopyAccelerationStructureNV-src-02497</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> src must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV if mode is VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV</th></tr>
<tr><th>VUID-vkCmdCopyAccelerationStructureNV-src-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> src must be a valid VkAccelerationStructureNV handle</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-commandBuffer-01822</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then srcBuffer must not be a protected buffer</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-commandBuffer-01823</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-commandBuffer-01824</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> Each of commandBuffer, dstBuffer, and srcBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-dstBuffer-00120</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-dstBuffer-00121</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-dstBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> dstBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-dstOffset-00114</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> The dstOffset member of each element of pRegions must be less than the size of dstBuffer</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-pRegions-00117</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> The union of the source regions, and the union of the destination regions, specified by the elements of pRegions, must not overlap in memory</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-pRegions-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> pRegions must be a valid pointer to an array of regionCount valid VkBufferCopy structures</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-regionCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> regionCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-size-00115</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> The size member of each element of pRegions must be less than or equal to the size of srcBuffer minus srcOffset</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-size-00116</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> The size member of each element of pRegions must be less than or equal to the size of dstBuffer minus dstOffset</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-srcBuffer-00118</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> srcBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-srcBuffer-00119</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> If srcBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-srcBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> srcBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyBuffer-srcOffset-00113</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBuffer</th><th>core</th><th> The srcOffset member of each element of pRegions must be less than the size of srcBuffer</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-commandBuffer-01828</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then srcBuffer must not be a protected buffer</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-commandBuffer-01829</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-commandBuffer-01830</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>implicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> Each of commandBuffer, dstImage, and srcBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-dstImage-00177</th><th><span style="color:limegreen;">Y</span></th><th>InvalidUsageBits</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-dstImage-00178</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-dstImage-00179</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-dstImage-01997</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-dstImage-02543</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>(VK_EXT_fragment_density_map)</th><th> dstImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-dstImage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> dstImage must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-dstImageLayout-00180</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-dstImageLayout-00181</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>!(VK_KHR_shared_presentable_image)</th><th> dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-dstImageLayout-01396</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>(VK_KHR_shared_presentable_image)</th><th> dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-dstImageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> dstImageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-imageOffset-01793</th><th><span style="color:limegreen;">Y</span></th><th>CompressedImageMipCopyTests, MinImageTransferGranularity</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> The imageOffset and imageExtent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-imageSubresource-01701</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> The imageSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-imageSubresource-01702</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> The imageSubresource.baseArrayLayer + imageSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-pRegions-00171</th><th><span style="color:limegreen;">Y</span></th><th>CompressedImageMipCopyTests, ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> srcBuffer must be large enough to contain all buffer locations that are accessed according to Buffer and Image Addressing, for each element of pRegions</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-pRegions-00172</th><th><span style="color:limegreen;">Y</span></th><th>MiscImageLayerTests, ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> The image region specified by each element of pRegions must be a region that is contained within dstImage</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-pRegions-00173</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-pRegions-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> pRegions must be a valid pointer to an array of regionCount valid VkBufferImageCopy structures</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-regionCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> regionCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-srcBuffer-00174</th><th><span style="color:limegreen;">Y</span></th><th>InvalidUsageBits</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> srcBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-srcBuffer-00176</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> If srcBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyBufferToImage-srcBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyBufferToImage</th><th>core</th><th> srcBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyImage-None-01549</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> In a copy to or from a plane of a multi-planar image, the VkFormat of the image and plane must be compatible according to the description of compatible planes for the plane being copied</th></tr>
<tr><th>VUID-vkCmdCopyImage-aspectMask-01550</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> When a copy is performed to or from an image with a multi-planar format, the aspectMask of the srcSubresource and/or dstSubresource that refers to the multi-planar image must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT (with VK_IMAGE_ASPECT_PLANE_2_BIT valid only for a VkFormat with three planes)</th></tr>
<tr><th>VUID-vkCmdCopyImage-commandBuffer-01825</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image</th></tr>
<tr><th>VUID-vkCmdCopyImage-commandBuffer-01826</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image</th></tr>
<tr><th>VUID-vkCmdCopyImage-commandBuffer-01827</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image</th></tr>
<tr><th>VUID-vkCmdCopyImage-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdCopyImage-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyImage-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageAspectMismatch</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdCopyImage-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstImage-00131</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstImage-00132</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstImage-01547</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If dstImage is non-sparse then the image or disjoint plane that is the destination of the copy must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstImage-01996</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstImage-02542</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_EXT_fragment_density_map)</th><th> dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstImage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> dstImage must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstImageLayout-00133</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageLayout</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstImageLayout-00134</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageLayout</th><th>explicit</th><th>vkCmdCopyImage</th><th>!(VK_KHR_shared_presentable_image)</th><th> dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstImageLayout-01395</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_KHR_shared_presentable_image)</th><th> dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstImageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> dstImageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstOffset-01784</th><th><span style="color:limegreen;">Y</span></th><th>MinImageTransferGranularity, CopyImageCompressedBlockAlignment</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> The dstOffset and extent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstSubresource-01697</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created</th></tr>
<tr><th>VUID-vkCmdCopyImage-dstSubresource-01699</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatchMaintenance1</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created</th></tr>
<tr><th>VUID-vkCmdCopyImage-pRegions-00122</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageSrcSizeExceeded</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> The source region specified by each element of pRegions must be a region that is contained within srcImage</th></tr>
<tr><th>VUID-vkCmdCopyImage-pRegions-00123</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageDstSizeExceeded</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> The destination region specified by each element of pRegions must be a region that is contained within dstImage</th></tr>
<tr><th>VUID-vkCmdCopyImage-pRegions-00124</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory</th></tr>
<tr><th>VUID-vkCmdCopyImage-pRegions-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> pRegions must be a valid pointer to an array of regionCount valid VkImageCopy structures</th></tr>
<tr><th>VUID-vkCmdCopyImage-regionCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> regionCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdCopyImage-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImage-00126</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImage-00127</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImage-00135</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageFormatSizeMismatch, CopyImageMultiplaneAspectBits</th><th>explicit</th><th>vkCmdCopyImage</th><th>!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> The VkFormat of each of srcImage and dstImage must be compatible, as defined above</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImage-00136</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageSampleCountMismatch</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> The sample count of srcImage and dstImage must match</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImage-01546</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If srcImage is non-sparse then the image or disjoint plane to be copied must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImage-01548</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the VkFormat of each of srcImage and dstImage is not a multi-planar format, the VkFormat of each of srcImage and dstImage must be compatible, as defined above</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImage-01995</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT.</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> srcImage must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImageLayout-00128</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageLayout</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImageLayout-00129</th><th><span style="color:limegreen;">Y</span></th><th>InvalidImageLayout</th><th>explicit</th><th>vkCmdCopyImage</th><th>!(VK_KHR_shared_presentable_image)</th><th> srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImageLayout-01917</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>(VK_KHR_shared_presentable_image)</th><th> srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcImageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImage</th><th>core</th><th> srcImageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcOffset-01783</th><th><span style="color:limegreen;">Y</span></th><th>MinImageTransferGranularity, CopyImageCompressedBlockAlignment</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> The srcOffset and extent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcSubresource-01696</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created</th></tr>
<tr><th>VUID-vkCmdCopyImage-srcSubresource-01698</th><th><span style="color:limegreen;">Y</span></th><th>CopyImageTypeExtentMismatchMaintenance1, CopyImageTypeExtentMismatch</th><th>explicit</th><th>vkCmdCopyImage</th><th>core</th><th> The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-commandBuffer-01831</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-commandBuffer-01832</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-commandBuffer-01833</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>implicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> Each of commandBuffer, dstBuffer, and srcImage must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-dstBuffer-00191</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-dstBuffer-00192</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-dstBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> dstBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-imageOffset-01794</th><th><span style="color:limegreen;">Y</span></th><th>CompressedImageMipCopyTests, MinImageTransferGranularity, ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> The imageOffset and imageExtent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-imageSubresource-01703</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> The imageSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-imageSubresource-01704</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> The imageSubresource.baseArrayLayer + imageSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-pRegions-00182</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> The image region specified by each element of pRegions must be a region that is contained within srcImage</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-pRegions-00183</th><th><span style="color:limegreen;">Y</span></th><th>CompressedImageMipCopyTests, ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> dstBuffer must be large enough to contain all buffer locations that are accessed according to Buffer and Image Addressing, for each element of pRegions</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-pRegions-00184</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-pRegions-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> pRegions must be a valid pointer to an array of regionCount valid VkBufferImageCopy structures</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-regionCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> regionCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-srcImage-00186</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-srcImage-00187</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-srcImage-00188</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> srcImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-srcImage-01998</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT.</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-srcImage-02544</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>(VK_EXT_fragment_density_map)</th><th> srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-srcImage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> srcImage must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-srcImageLayout-00189</th><th><span style="color:limegreen;">Y</span></th><th>ImageBufferCopyTests</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-srcImageLayout-00190</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>!(VK_KHR_shared_presentable_image)</th><th> srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-srcImageLayout-01397</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyImageToBuffer</th><th>(VK_KHR_shared_presentable_image)</th><th> srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdCopyImageToBuffer-srcImageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyImageToBuffer</th><th>core</th><th> srcImageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> Each of commandBuffer, dstBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-dstBuffer-00824</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> dstBuffer must have enough storage, from dstOffset, to contain the result of each query, as described here</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-dstBuffer-00825</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-dstBuffer-00826</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-dstBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> dstBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-dstOffset-00819</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> dstOffset must be less than the size of dstBuffer</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-firstQuery-00820</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> firstQuery must be less than the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-firstQuery-00821</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-flags-00822</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> If VK_QUERY_RESULT_64_BIT is not set in flags then dstOffset and stride must be multiples of 4</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-flags-00823</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> If VK_QUERY_RESULT_64_BIT is set in flags then dstOffset and stride must be multiples of 8</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> flags must be a valid combination of VkQueryResultFlagBits values</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-queryType-00827</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_TIMESTAMP, flags must not contain VK_QUERY_RESULT_PARTIAL_BIT</th></tr>
<tr><th>VUID-vkCmdCopyQueryPoolResults-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdCopyQueryPoolResults</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDebugMarkerBeginEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerBeginEXT</th><th>(VK_EXT_debug_marker)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdDebugMarkerBeginEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerBeginEXT</th><th>(VK_EXT_debug_marker)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDebugMarkerBeginEXT-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerBeginEXT</th><th>(VK_EXT_debug_marker)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDebugMarkerBeginEXT-pMarkerInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerBeginEXT</th><th>(VK_EXT_debug_marker)</th><th> pMarkerInfo must be a valid pointer to a valid VkDebugMarkerMarkerInfoEXT structure</th></tr>
<tr><th>VUID-vkCmdDebugMarkerEndEXT-commandBuffer-01239</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDebugMarkerEndEXT</th><th>(VK_EXT_debug_marker)</th><th> There must be an outstanding vkCmdDebugMarkerBeginEXT command prior to the vkCmdDebugMarkerEndEXT on the queue that commandBuffer is submitted to</th></tr>
<tr><th>VUID-vkCmdDebugMarkerEndEXT-commandBuffer-01240</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDebugMarkerEndEXT</th><th>(VK_EXT_debug_marker)</th><th> If commandBuffer is a secondary command buffer, there must be an outstanding vkCmdDebugMarkerBeginEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdDebugMarkerEndEXT.</th></tr>
<tr><th>VUID-vkCmdDebugMarkerEndEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerEndEXT</th><th>(VK_EXT_debug_marker)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdDebugMarkerEndEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerEndEXT</th><th>(VK_EXT_debug_marker)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDebugMarkerEndEXT-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerEndEXT</th><th>(VK_EXT_debug_marker)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDebugMarkerInsertEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerInsertEXT</th><th>(VK_EXT_debug_marker)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdDebugMarkerInsertEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerInsertEXT</th><th>(VK_EXT_debug_marker)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDebugMarkerInsertEXT-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerInsertEXT</th><th>(VK_EXT_debug_marker)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDebugMarkerInsertEXT-pMarkerInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDebugMarkerInsertEXT</th><th>(VK_EXT_debug_marker)</th><th> pMarkerInfo must be a valid pointer to a valid VkDebugMarkerMarkerInfoEXT structure</th></tr>
<tr><th>VUID-vkCmdDispatch-None-00389</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDispatch-None-00390</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDispatch-None-00391</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipeline</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> A valid compute pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_COMPUTE</th></tr>
<tr><th>VUID-vkCmdDispatch-None-00392</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a push constant value must have been set for VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for push constants with the one used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDispatch-None-00393</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDispatch-None-00394</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDispatch-None-00395</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDispatch-None-00396</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDispatch-None-00397</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDispatch-None-00400</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+!(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDispatch-None-02005</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdDispatch-None-02006</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT.</th></tr>
<tr><th>VUID-vkCmdDispatch-commandBuffer-01844</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDispatch-commandBuffer-01845</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.</th></tr>
<tr><th>VUID-vkCmdDispatch-commandBuffer-01846</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage other than the compute pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE reads from any image or buffer, the image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDispatch-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatch</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdDispatch-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatch</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDispatch-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatch</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDispatch-filterCubic-02609</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDispatch-filterCubicMinmax-02610</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDispatch-flags-02040</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatch</th><th>(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDispatch-groupCountX-00386</th><th><span style="color:limegreen;">Y</span></th><th>CmdDispatchExceedLimits</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]</th></tr>
<tr><th>VUID-vkCmdDispatch-groupCountY-00387</th><th><span style="color:limegreen;">Y</span></th><th>CmdDispatchExceedLimits</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]</th></tr>
<tr><th>VUID-vkCmdDispatch-groupCountZ-00388</th><th><span style="color:limegreen;">Y</span></th><th>CmdDispatchExceedLimits</th><th>explicit</th><th>vkCmdDispatch</th><th>core</th><th> groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]</th></tr>
<tr><th>VUID-vkCmdDispatch-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatch</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDispatchBase-None-00420</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> All valid usage rules from vkCmdDispatch apply</th></tr>
<tr><th>VUID-vkCmdDispatchBase-baseGroupX-00421</th><th><span style="color:limegreen;">Y</span></th><th>CmdDispatchExceedLimits</th><th>explicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> baseGroupX must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]</th></tr>
<tr><th>VUID-vkCmdDispatchBase-baseGroupX-00422</th><th><span style="color:limegreen;">Y</span></th><th>CmdDispatchExceedLimits</th><th>explicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> baseGroupX must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]</th></tr>
<tr><th>VUID-vkCmdDispatchBase-baseGroupX-00427</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If any of baseGroupX, baseGroupY, or baseGroupZ are not zero, then the bound compute pipeline must have been created with the VK_PIPELINE_CREATE_DISPATCH_BASE flag.</th></tr>
<tr><th>VUID-vkCmdDispatchBase-baseGroupZ-00423</th><th><span style="color:limegreen;">Y</span></th><th>CmdDispatchExceedLimits</th><th>explicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> baseGroupZ must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]</th></tr>
<tr><th>VUID-vkCmdDispatchBase-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> The VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdDispatchBase-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDispatchBase-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDispatchBase-groupCountX-00424</th><th><span style="color:limegreen;">Y</span></th><th>CmdDispatchExceedLimits</th><th>explicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] minus baseGroupX</th></tr>
<tr><th>VUID-vkCmdDispatchBase-groupCountY-00425</th><th><span style="color:limegreen;">Y</span></th><th>CmdDispatchExceedLimits</th><th>explicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] minus baseGroupY</th></tr>
<tr><th>VUID-vkCmdDispatchBase-groupCountZ-00426</th><th><span style="color:limegreen;">Y</span></th><th>CmdDispatchExceedLimits</th><th>explicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] minus baseGroupZ</th></tr>
<tr><th>VUID-vkCmdDispatchBase-renderpass</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDispatchBase</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-00402</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-00403</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-00404</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipeline</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> A valid compute pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_COMPUTE</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-00408</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a push constant value must have been set for VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for push constants with the one used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-00409</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-00410</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-00411</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-00412</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-00413</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-00416</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+!(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-02007</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-None-02008</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT.</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-buffer-00401</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-buffer-00405</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-commandBuffer-01847</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-commandBuffer-02639</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-filterCubic-02611</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-filterCubicMinmax-02612</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-flags-02041</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-offset-00406</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-offset-00407</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> The sum of offset and the size of VkDispatchIndirectCommand must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDispatchIndirect-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDispatchIndirect</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDraw-None-00437</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDraw-None-00438</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDraw-None-00439</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDraw-None-00440</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound</th></tr>
<tr><th>VUID-vkCmdDraw-None-00441</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description</th></tr>
<tr><th>VUID-vkCmdDraw-None-00442</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipeline</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDraw-None-00443</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDraw-None-00444</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDraw-None-00445</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDraw-None-00446</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDraw-None-00447</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDraw-None-00448</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDraw-None-00449</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDraw-None-00452</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+!(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDraw-None-01499</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDraw-None-02009</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdDraw-None-02010</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdDraw-commandBuffer-01850</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDraw-commandBuffer-01851</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.</th></tr>
<tr><th>VUID-vkCmdDraw-commandBuffer-01852</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDraw-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDraw</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDraw-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDraw</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDraw-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDraw</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDraw-filterCubic-02613</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDraw-filterCubicMinmax-02614</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDraw-flags-02042</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDraw-maxMultiviewInstanceIndex-00453</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDraw-renderPass-00435</th><th><span style="color:limegreen;">Y</span></th><th>DrawWithPipelineIncompatibleWithRenderPass</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDraw-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDraw</th><th>core</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDraw-sampleLocationsEnable-01512</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>(VK_EXT_sample_locations)</th><th> If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDraw-subpass-00436</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDraw</th><th>core</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00456</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00457</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00458</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00459</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00460</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00461</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipeline</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00462</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00464</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00465</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00466</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00467</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00468</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00469</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-00472</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+!(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-01500</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-02011</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-None-02012</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-commandBuffer-01853</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-commandBuffer-01854</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-commandBuffer-01855</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-filterCubic-02615</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-filterCubicMinmax-02616</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-flags-02043</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-indexSize-00463</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> (indexSize * (firstIndex + indexCount) + offset) must be less than or equal to the size of the bound index buffer, with indexSize being based on the type specified by indexType, where the index buffer, indexType, and offset are specified via vkCmdBindIndexBuffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-maxMultiviewInstanceIndex-00473</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-renderPass-00454</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-sampleLocationsEnable-01513</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>(VK_EXT_sample_locations)</th><th> If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndexed-subpass-00455</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexed</th><th>core</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00533</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00534</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00535</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00536</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00537</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipeline</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00538</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00542</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00543</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00544</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00545</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00546</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00547</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-00550</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+!(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-01503</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-02018</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-None-02019</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-buffer-00526</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-buffer-01665</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-commandBuffer-01862</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-commandBuffer-02643</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-drawCount-00528</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-drawCount-00529</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If the multi-draw indirect feature is not enabled, drawCount must be 0 or 1</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-drawCount-00539</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If drawCount is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-drawCount-00540</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If drawCount is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-drawCount-00541</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-filterCubic-02621</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-filterCubicMinmax-02622</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-firstInstance-00530</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndexedIndirectCommand structures accessed by this command must be 0</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-flags-02047</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-maxMultiviewInstanceIndex-00551</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-offset-00527</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-renderPass-00531</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-sampleLocationsEnable-01516</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>(VK_EXT_sample_locations)</th><th> If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirect-subpass-00532</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirect</th><th>core</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00562</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00563</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00564</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00565</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00566</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00567</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00571</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00572</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00573</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00574</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00575</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-00576</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-01504</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-None-02022</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-buffer-01666</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-buffer-01667</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-01865</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-02645</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-00568</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-00569</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-01668</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-01669</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> countBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-countBufferOffset-00556</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> countBufferOffset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-drawCount-00570</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-firstInstance-00559</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndexedIndirectCommand structures accessed by this command must be 0</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-flags-02049</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)+(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-maxDrawCount-00558</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-maxMultiviewInstanceIndex-00578</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-offset-00555</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-renderPass-00560</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-renderpass</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-sampleLocationsEnable-01517</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)+(VK_EXT_sample_locations)</th><th> If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-stride-00557</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountAMD-subpass-00561</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-02020</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-02021</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03147</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03148</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03149</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03150</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03151</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipeline</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03152</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndexedIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03156</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03157</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03158</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03159</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03160</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03161</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03163</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-None-03173</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+!(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-buffer-03136</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndexedIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-buffer-03137</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-02644</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-03165</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03138</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndexedIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03139</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03153</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03154</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> countBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-countBufferOffset-03141</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndexedIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> countBufferOffset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-drawCount-03155</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-filterCubic-02623</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-filterCubicMinmax-02624</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-firstInstance-03144</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndexedIndirectCommand structures accessed by this command must be 0</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-flags-02048</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-maxDrawCount-03143</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-maxMultiviewInstanceIndex-03164</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-offset-03140</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndexedIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-renderPass-03145</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-sampleLocationsEnable-03174</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_EXT_sample_locations)</th><th> If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-stride-03142</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndexedIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)</th></tr>
<tr><th>VUID-vkCmdDrawIndexedIndirectCountKHR-subpass-03146</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndexedIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00481</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00482</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00483</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00484</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00485</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipeline</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00486</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00490</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00491</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00492</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00493</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00494</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00495</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-00498</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+!(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-01501</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-02013</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-None-02014</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-buffer-00474</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-buffer-01660</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-commandBuffer-01856</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-commandBuffer-02640</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-drawCount-00476</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-drawCount-00477</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If the multi-draw indirect feature is not enabled, drawCount must be 0 or 1</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-drawCount-00487</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If drawCount is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-drawCount-00488</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If drawCount is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-drawCount-00489</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-filterCubic-02617</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-filterCubicMinmax-02618</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-firstInstance-00478</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndirectCommand structures accessed by this command must be 0</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-flags-02044</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-maxMultiviewInstanceIndex-00499</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-offset-00475</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-renderPass-00479</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-sampleLocationsEnable-01514</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>(VK_EXT_sample_locations)</th><th> If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndirect-subpass-00480</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirect</th><th>core</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02293</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02294</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02295</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02296</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02297</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02298</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02299</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02300</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02301</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02302</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02303</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02304</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02305</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02306</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-None-02307</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+!(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-02309</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)+(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-02646</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)+(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> Both of commandBuffer, and counterBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-counterBuffer-02290</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> counterBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-counterBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> counterBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-filterCubic-02625</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-filterCubicMinmax-02626</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-maxMultiviewInstanceIndex-02308</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)+(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-renderPass-02291</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-renderpass</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-sampleLocationsEnable-02312</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)+(VK_EXT_sample_locations)</th><th> If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-subpass-02292</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-transformFeedback-02287</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-transformFeedbackDraw-02288</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> The implementation must support VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackDraw</th></tr>
<tr><th>VUID-vkCmdDrawIndirectByteCountEXT-vertexStride-02289</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectByteCountEXT</th><th>(VK_EXT_transform_feedback)</th><th> vertexStride must be greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxTransformFeedbackBufferDataStride</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00509</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00510</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00511</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00512</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00513</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00514</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00518</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00519</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00520</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00521</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00522</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-00523</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-01502</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-None-02017</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-buffer-01661</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-buffer-01662</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-commandBuffer-01859</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-commandBuffer-02642</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-countBuffer-00515</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-countBuffer-00516</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If the count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-countBuffer-00517</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-countBuffer-01663</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-countBuffer-01664</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-countBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> countBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-countBufferOffset-00503</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> countBufferOffset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-firstInstance-00506</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndirectCommand structures accessed by this command must be 0</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-flags-02046</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)+(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-maxDrawCount-00505</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-maxMultiviewInstanceIndex-00525</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-offset-00502</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-renderPass-00507</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-renderpass</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-sampleLocationsEnable-01515</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)+(VK_EXT_sample_locations)</th><th> If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-stride-00504</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountAMD-subpass-00508</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountAMD</th><th>(VK_AMD_draw_indirect_count)</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-02015</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-02016</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)</th><th> If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03115</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03116</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03117</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03118</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03119</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPipeline</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03120</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03124</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03125</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03126</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03127</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03128</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03129</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03131</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-None-03170</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+!(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-buffer-03104</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-buffer-03105</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-commandBuffer-02641</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-commandBuffer-03133</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-countBuffer-03106</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-countBuffer-03107</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-countBuffer-03121</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-countBuffer-03122</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If the count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-countBuffer-03123</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-countBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> countBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-countBufferOffset-03109</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> countBufferOffset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-filterCubic-02619</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-filterCubicMinmax-02620</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic,VK_EXT_filter_cubic)+(VK_EXT_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-firstInstance-03112</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndirectCommand structures accessed by this command must be 0</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-flags-02045</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-maxDrawCount-03111</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-maxMultiviewInstanceIndex-03132</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-offset-03108</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-renderPass-03113</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-sampleLocationsEnable-03171</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)+(VK_EXT_sample_locations)</th><th> If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-stride-03110</th><th><span style="color:limegreen;">Y</span></th><th>DrawIndirectCountKHR</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)</th></tr>
<tr><th>VUID-vkCmdDrawIndirectCountKHR-subpass-03114</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawIndirectCountKHR</th><th>(VK_KHR_draw_indirect_count)</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02186</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> For each set n that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02187</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> For each push constant that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02188</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the currently bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02189</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02190</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02194</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02195</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02196</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02197</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02198</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02199</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02201</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-02176</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-02177</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-02203</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)+(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-02204</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)+(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-02205</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)+(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02178</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02179</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02191</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02192</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If the count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02193</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> countBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-countBufferOffset-02181</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> countBufferOffset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-linearTilingFeatures-02200</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> Any VkImageView being sampled with VK_FILTER_LINEAR as a result of this command must be of a format which supports linear filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-maxDrawCount-02183</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-maxMultiviewInstanceIndex-02202</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)+(VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-offset-02180</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-renderPass-02184</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-sampleLocationsEnable-02206</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)+(VK_EXT_sample_locations)</th><th> If the currently bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-stride-02182</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandNV)</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectCountNV-subpass-02185</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectCountNV</th><th>(VK_NV_mesh_shader)</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02150</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> For each set n that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02151</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> For each push constant that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02152</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the currently bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02153</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02154</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02155</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02159</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02160</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02161</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02162</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02163</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02164</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02166</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-None-02168</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)+(VK_IMG_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-buffer-02143</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-buffer-02144</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-02170</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)+(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-02171</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)+(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-02172</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)+(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02146</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderNV</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandNV)</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02147</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderNV</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If the multi-draw indirect feature is not enabled, drawCount must be 0 or 1</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02156</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If drawCount is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02157</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> If drawCount is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02158</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-flags-02174</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)+(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-linearTilingFeatures-02165</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> Any VkImageView being sampled with VK_FILTER_LINEAR as a result of this command must be of a format which supports linear filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-linearTilingFeatures-02167</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)+(VK_IMG_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must be of a format which supports cubic filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-maxMultiviewInstanceIndex-02169</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)+(VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-offset-02145</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-renderPass-02148</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-sampleLocationsEnable-02173</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)+(VK_EXT_sample_locations)</th><th> If the currently bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksIndirectNV-subpass-02149</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksIndirectNV</th><th>(VK_NV_mesh_shader)</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02122</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> For each set n that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02123</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> For each push constant that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02124</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the currently bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02125</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02126</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> If the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02127</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02128</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02129</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02130</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02131</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02132</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02134</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-None-02136</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)+(VK_IMG_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-commandBuffer-02138</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)+(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-commandBuffer-02139</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)+(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-commandBuffer-02140</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)+(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-flags-02142</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)+(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-linearTilingFeatures-02133</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> Any VkImageView being sampled with VK_FILTER_LINEAR as a result of this command must be of a format which supports linear filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-linearTilingFeatures-02135</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)+(VK_IMG_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must be of a format which supports cubic filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-maxMultiviewInstanceIndex-02137</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)+(VK_KHR_multiview)</th><th> If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-renderPass-02120</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-sampleLocationsEnable-02141</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)+(VK_EXT_sample_locations)</th><th> If the currently bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-subpass-02121</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.</th></tr>
<tr><th>VUID-vkCmdDrawMeshTasksNV-taskCount-02119</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdDrawMeshTasksNV</th><th>(VK_NV_mesh_shader)</th><th> taskCount must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount</th></tr>
<tr><th>VUID-vkCmdEndConditionalRenderingEXT-None-01985</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> Conditional rendering must be active</th></tr>
<tr><th>VUID-vkCmdEndConditionalRenderingEXT-None-01986</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> If conditional rendering was made active outside of a render pass instance, it must not be ended inside a render pass instance</th></tr>
<tr><th>VUID-vkCmdEndConditionalRenderingEXT-None-01987</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> If conditional rendering was made active within a subpass it must be ended in the same subpass</th></tr>
<tr><th>VUID-vkCmdEndConditionalRenderingEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdEndConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdEndConditionalRenderingEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdEndConditionalRenderingEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdEndConditionalRenderingEXT</th><th>(VK_EXT_conditional_rendering)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01912</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> There must be an outstanding vkCmdBeginDebugUtilsLabelEXT command prior to the vkCmdEndDebugUtilsLabelEXT on the queue that commandBuffer is submitted to</th></tr>
<tr><th>VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01913</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> If commandBuffer is a secondary command buffer, there must be an outstanding vkCmdBeginDebugUtilsLabelEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdEndDebugUtilsLabelEXT.</th></tr>
<tr><th>VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdEndDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdEndDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdEndQuery-None-01923</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdEndQuery</th><th>core</th><th> All queries used by the command must be active</th></tr>
<tr><th>VUID-vkCmdEndQuery-commandBuffer-01886</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndQuery</th><th>(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdEndQuery-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndQuery</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdEndQuery-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndQuery</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdEndQuery-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndQuery</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdEndQuery-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndQuery</th><th>core</th><th> Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdEndQuery-query-00810</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndQuery</th><th>core</th><th> query must be less than the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdEndQuery-query-00812</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndQuery</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If vkCmdEndQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdEndQuery-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndQuery</th><th>core</th><th> queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-None-02342</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> All queries used by the command must be active</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-commandBuffer-02344</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)+(VK_VERSION_1_1)</th><th> commandBuffer must not be a protected command buffer</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-query-02343</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> query must be less than the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-query-02345</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)+(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If vkCmdEndQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-queryType-02346</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index parameter must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams</th></tr>
<tr><th>VUID-vkCmdEndQueryIndexedEXT-queryType-02347</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndQueryIndexedEXT</th><th>(VK_EXT_transform_feedback)</th><th> If the queryType used to create queryPool was not VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index must be zero</th></tr>
<tr><th>VUID-vkCmdEndRenderPass-None-00910</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassEndBeforeFinalSubpass</th><th>explicit</th><th>vkCmdEndRenderPass</th><th>core</th><th> The current subpass index must be equal to the number of subpasses in the render pass minus one</th></tr>
<tr><th>VUID-vkCmdEndRenderPass-None-02351</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndRenderPass</th><th>(VK_EXT_transform_feedback)</th><th> This command must not be recorded when transform feedback is active</th></tr>
<tr><th>VUID-vkCmdEndRenderPass-bufferlevel</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass</th><th>core</th><th> commandBuffer must be a primary VkCommandBuffer</th></tr>
<tr><th>VUID-vkCmdEndRenderPass-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdEndRenderPass-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdEndRenderPass-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdEndRenderPass-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass</th><th>core</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdEndRenderPass2KHR-None-02352</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)+(VK_EXT_transform_feedback)</th><th> This command must not be recorded when transform feedback is active</th></tr>
<tr><th>VUID-vkCmdEndRenderPass2KHR-None-03103</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassEndBeforeFinalSubpass</th><th>explicit</th><th>vkCmdEndRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The current subpass index must be equal to the number of subpasses in the render pass minus one</th></tr>
<tr><th>VUID-vkCmdEndRenderPass2KHR-bufferlevel</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> commandBuffer must be a primary VkCommandBuffer</th></tr>
<tr><th>VUID-vkCmdEndRenderPass2KHR-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdEndRenderPass2KHR-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdEndRenderPass2KHR-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdEndRenderPass2KHR-pSubpassEndInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pSubpassEndInfo must be a valid pointer to a valid VkSubpassEndInfoKHR structure</th></tr>
<tr><th>VUID-vkCmdEndRenderPass2KHR-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-None-02375</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> Transform feedback must be active</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> Both of commandBuffer, and the elements of pCounterBuffers that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-counterBufferCount-02608</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> If counterBufferCount is not 0, and pCounterBuffers is not NULL, pCounterBuffers must be a valid pointer to an array of counterBufferCount VkBuffer handles that are either valid or VK_NULL_HANDLE</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-firstCounterBuffer-02376</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> firstCounterBuffer must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-firstCounterBuffer-02377</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> The sum of firstCounterBuffer and counterBufferCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-pCounterBuffer-02379</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> If pCounterBuffer is NULL, then pCounterBufferOffsets must also be NULL</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-pCounterBufferOffsets-02378</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> For each buffer handle in the array, if it is not VK_NULL_HANDLE it must reference a buffer large enough to hold 4 bytes at the corresponding offset from the pCounterBufferOffsets array</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-pCounterBufferOffsets-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> If counterBufferCount is not 0, and pCounterBufferOffsets is not NULL, pCounterBufferOffsets must be a valid pointer to an array of counterBufferCount VkDeviceSize values</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-pCounterBuffers-02380</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> For each buffer handle in the pCounterBuffers array that is not VK_NULL_HANDLE it must have been created with a usage value containing VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-renderpass</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdEndTransformFeedbackEXT-transformFeedback-02374</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdEndTransformFeedbackEXT</th><th>(VK_EXT_transform_feedback)</th><th> VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-None-02286</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>(VK_EXT_transform_feedback)</th><th> This command must not be recorded when transform feedback is active</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-bufferlevel</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> commandBuffer must be a primary VkCommandBuffer</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBuffer-00087</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> commandBuffer must have been allocated with a level of VK_COMMAND_BUFFER_LEVEL_PRIMARY</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBuffer-00101</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If the inherited queries feature is not enabled, commandBuffer must not have any queries active</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBuffer-00102</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If commandBuffer has a VK_QUERY_TYPE_OCCLUSION query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::occlusionQueryEnable set to VK_TRUE</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBuffer-00103</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If commandBuffer has a VK_QUERY_TYPE_OCCLUSION query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::queryFlags having all bits set that are set for the query</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBuffer-00104</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If commandBuffer has a VK_QUERY_TYPE_PIPELINE_STATISTICS query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::pipelineStatistics having all bits set that are set in the VkQueryPool the query uses</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBuffer-01820</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then each element of pCommandBuffers must be a protected command buffer.</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBuffer-01821</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then each element of pCommandBuffers must be an unprotected command buffer.</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commandBufferCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> commandBufferCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> Both of commandBuffer, and the elements of pCommandBuffers must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-contents-00095</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If vkCmdExecuteCommands is being called within a render pass instance, that render pass instance must have been begun with the contents parameter of vkCmdBeginRenderPass set to VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00088</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> Each element of pCommandBuffers must have been allocated with a level of VK_COMMAND_BUFFER_LEVEL_SECONDARY</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00089</th><th><span style="color:limegreen;">Y</span></th><th>ExecuteUnrecordedSecondaryCB</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> Each element of pCommandBuffers must be in the pending or executable state.</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00090</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, and it was recorded into any other primary command buffer, that primary command buffer must not be in the pending state</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00091</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not be in the pending state.</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00092</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not have already been recorded to commandBuffer.</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00093</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not appear more than once in pCommandBuffers.</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00094</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> Each element of pCommandBuffers must have been allocated from a VkCommandPool that was created for the same queue family as the VkCommandPool from which commandBuffer was allocated</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00096</th><th><span style="color:limegreen;">Y</span></th><th>BadRenderPassScopeSecondaryCmdBuffer</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If vkCmdExecuteCommands is being called within a render pass instance, each element of pCommandBuffers must have been recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00097</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If vkCmdExecuteCommands is being called within a render pass instance, each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::subpass set to the index of the subpass which the given command buffer will be executed in</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00099</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If vkCmdExecuteCommands is being called within a render pass instance, and any element of pCommandBuffers was recorded with VkCommandBufferInheritanceInfo::framebuffer not equal to VK_NULL_HANDLE, that VkFramebuffer must match the VkFramebuffer used in the current render pass instance</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00100</th><th><span style="color:limegreen;">Y</span></th><th>BadRenderPassScopeSecondaryCmdBuffer</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If vkCmdExecuteCommands is not being called within a render pass instance, each element of pCommandBuffers must not have been recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-00105</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> Each element of pCommandBuffers must not begin any query types that are active in commandBuffer</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pCommandBuffers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> pCommandBuffers must be a valid pointer to an array of commandBufferCount valid VkCommandBuffer handles</th></tr>
<tr><th>VUID-vkCmdExecuteCommands-pInheritanceInfo-00098</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdExecuteCommands</th><th>core</th><th> If vkCmdExecuteCommands is being called within a render pass instance, the render passes specified in the pBeginInfo::pInheritanceInfo::renderPass members of the vkBeginCommandBuffer commands used to begin recording each element of pCommandBuffers must be compatible with the current render pass.</th></tr>
<tr><th>VUID-vkCmdFillBuffer-commandBuffer-00030</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdFillBuffer</th><th>!(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics or compute operations</th></tr>
<tr><th>VUID-vkCmdFillBuffer-commandBuffer-01811</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdFillBuffer</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer</th></tr>
<tr><th>VUID-vkCmdFillBuffer-commandBuffer-01812</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdFillBuffer</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer</th></tr>
<tr><th>VUID-vkCmdFillBuffer-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdFillBuffer</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support transfer, graphics or compute operations</th></tr>
<tr><th>VUID-vkCmdFillBuffer-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdFillBuffer</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdFillBuffer-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdFillBuffer</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdFillBuffer-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdFillBuffer</th><th>core</th><th> Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdFillBuffer-dstBuffer-00029</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdFillBuffer</th><th>core</th><th> dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdFillBuffer-dstBuffer-00031</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdFillBuffer</th><th>core</th><th> If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdFillBuffer-dstBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdFillBuffer</th><th>core</th><th> dstBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdFillBuffer-dstOffset-00024</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdFillBuffer</th><th>core</th><th> dstOffset must be less than the size of dstBuffer</th></tr>
<tr><th>VUID-vkCmdFillBuffer-dstOffset-00025</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdFillBuffer</th><th>core</th><th> dstOffset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdFillBuffer-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdFillBuffer</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdFillBuffer-size-00026</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdFillBuffer</th><th>core</th><th> If size is not equal to VK_WHOLE_SIZE, size must be greater than 0</th></tr>
<tr><th>VUID-vkCmdFillBuffer-size-00027</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdFillBuffer</th><th>core</th><th> If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to the size of dstBuffer minus dstOffset</th></tr>
<tr><th>VUID-vkCmdFillBuffer-size-00028</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdFillBuffer</th><th>core</th><th> If size is not equal to VK_WHOLE_SIZE, size must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdInsertDebugUtilsLabelEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdInsertDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdInsertDebugUtilsLabelEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdInsertDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdInsertDebugUtilsLabelEXT-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdInsertDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdInsertDebugUtilsLabelEXT-pLabelInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdInsertDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure</th></tr>
<tr><th>VUID-vkCmdNextSubpass-None-00909</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassNextSubpassExcessive</th><th>explicit</th><th>vkCmdNextSubpass</th><th>core</th><th> The current subpass index must be less than the number of subpasses in the render pass minus one</th></tr>
<tr><th>VUID-vkCmdNextSubpass-None-02349</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdNextSubpass</th><th>(VK_EXT_transform_feedback)</th><th> This command must not be recorded when transform feedback is active</th></tr>
<tr><th>VUID-vkCmdNextSubpass-bufferlevel</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass</th><th>core</th><th> commandBuffer must be a primary VkCommandBuffer</th></tr>
<tr><th>VUID-vkCmdNextSubpass-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdNextSubpass-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdNextSubpass-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdNextSubpass-contents-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass</th><th>core</th><th> contents must be a valid VkSubpassContents value</th></tr>
<tr><th>VUID-vkCmdNextSubpass-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass</th><th>core</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdNextSubpass2KHR-None-02350</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdNextSubpass2KHR</th><th>(VK_KHR_create_renderpass2)+(VK_EXT_transform_feedback)</th><th> This command must not be recorded when transform feedback is active</th></tr>
<tr><th>VUID-vkCmdNextSubpass2KHR-None-03102</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassNextSubpassExcessive</th><th>explicit</th><th>vkCmdNextSubpass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The current subpass index must be less than the number of subpasses in the render pass minus one</th></tr>
<tr><th>VUID-vkCmdNextSubpass2KHR-bufferlevel</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> commandBuffer must be a primary VkCommandBuffer</th></tr>
<tr><th>VUID-vkCmdNextSubpass2KHR-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdNextSubpass2KHR-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdNextSubpass2KHR-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdNextSubpass2KHR-pSubpassBeginInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pSubpassBeginInfo must be a valid pointer to a valid VkSubpassBeginInfoKHR structure</th></tr>
<tr><th>VUID-vkCmdNextSubpass2KHR-pSubpassEndInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pSubpassEndInfo must be a valid pointer to a valid VkSubpassEndInfoKHR structure</th></tr>
<tr><th>VUID-vkCmdNextSubpass2KHR-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdNextSubpass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-bufferMemoryBarrierCount-01178</th><th><span style="color:limegreen;">Y</span></th><th>ImageBarrierSubpassConflicts</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If vkCmdPipelineBarrier is called within a render pass instance, bufferMemoryBarrierCount must be 0</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-dependencyFlags-01186</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If vkCmdPipelineBarrier is called outside of a render pass instance, dependencyFlags must not include VK_DEPENDENCY_VIEW_LOCAL_BIT</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-dependencyFlags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> dependencyFlags must be a valid combination of VkDependencyFlagBits values</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-dstStageMask-01169</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-dstStageMask-01171</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-dstStageMask-02117</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-dstStageMask-02118</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-dstStageMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> dstStageMask must be a valid combination of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-dstStageMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> dstStageMask must not be 0</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-image-02635</th><th><span style="color:limegreen;">Y</span></th><th>InvalidSecondaryCommandBufferBarrier, ImageBarrierSubpassConflict, ImageBarrierSubpassConflicts</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>(VK_KHR_depth_stencil_resolve)</th><th> If vkCmdPipelineBarrier is called within a render pass instance, the image member of any element of pImageMemoryBarriers must be equal to one of the elements of pAttachments that the current framebuffer was created with, that is also referred to by one of the elements of the pColorAttachments, pResolveAttachments or pDepthStencilAttachment members of the VkSubpassDescription instance or by the pDepthStencilResolveAttachment member of the VkSubpassDescriptionDepthStencilResolveKHR structure that the current subpass was created with</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-image-02637</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>!(VK_KHR_depth_stencil_resolve)</th><th> If vkCmdPipelineBarrier is called within a render pass instance, the image member of any element of pImageMemoryBarriers must be equal to one of the elements of pAttachments that the current framebuffer was created with, that is also referred to by one of the elements of the pColorAttachments, pResolveAttachments or pDepthStencilAttachment members of the VkSubpassDescription instance that the current subpass was created with</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-oldLayout-01181</th><th><span style="color:limegreen;">Y</span></th><th>ImageBarrierSubpassConflicts</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If vkCmdPipelineBarrier is called within a render pass instance, the oldLayout and newLayout members of an element of pImageMemoryBarriers must be equal</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-oldLayout-02636</th><th><span style="color:limegreen;">Y</span></th><th>ImageBarrierSubpassConflicts</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>(VK_KHR_depth_stencil_resolve)</th><th> If vkCmdPipelineBarrier is called within a render pass instance, the oldLayout and newLayout members of any element of pImageMemoryBarriers must be equal to the layout member of an element of the pColorAttachments, pResolveAttachments or pDepthStencilAttachment members of the VkSubpassDescription instance or by the pDepthStencilResolveAttachment member of the VkSubpassDescriptionDepthStencilResolveKHR structure that the current subpass was created with, that refers to the same image</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-oldLayout-02638</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>!(VK_KHR_depth_stencil_resolve)</th><th> If vkCmdPipelineBarrier is called within a render pass instance, the oldLayout and newLayout members of any element of pImageMemoryBarriers must be equal to the layout member of an element of the pColorAttachments, pResolveAttachments or pDepthStencilAttachment members of the VkSubpassDescription instance that the current subpass was created with, that refers to the same image</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-pBufferMemoryBarriers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If bufferMemoryBarrierCount is not 0, pBufferMemoryBarriers must be a valid pointer to an array of bufferMemoryBarrierCount valid VkBufferMemoryBarrier structures</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-pDependencies-02285</th><th><span style="color:limegreen;">Y</span></th><th>ImageBarrierSubpassConflicts</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If vkCmdPipelineBarrier is called within a render pass instance, the render pass must have been created with at least one VkSubpassDependency instance in VkRenderPassCreateInfo::pDependencies that expresses a dependency from the current subpass to itself, and for which srcStageMask contains a subset of the bit values in VkSubpassDependency::srcStageMask, dstStageMask contains a subset of the bit values in VkSubpassDependency::dstStageMask, dependencyFlags is equal to VkSubpassDependency::dependencyFlags, srcAccessMask member of each element of pMemoryBarriers and pImageMemoryBarriers contains a subset of the bit values in VkSubpassDependency::srcAccessMask, and dstAccessMask member of each element of pMemoryBarriers and pImageMemoryBarriers contains a subset of the bit values in VkSubpassDependency::dstAccessMask</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-pImageMemoryBarriers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If imageMemoryBarrierCount is not 0, pImageMemoryBarriers must be a valid pointer to an array of imageMemoryBarrierCount valid VkImageMemoryBarrier structures</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-pMemoryBarriers-01184</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> Each element of pMemoryBarriers, pBufferMemoryBarriers and pImageMemoryBarriers must not have any access flag included in its srcAccessMask member if that bit is not supported by any of the pipeline stages in srcStageMask, as specified in the table of supported access types.</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-pMemoryBarriers-01185</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> Each element of pMemoryBarriers, pBufferMemoryBarriers and pImageMemoryBarriers must not have any access flag included in its dstAccessMask member if that bit is not supported by any of the pipeline stages in dstStageMask, as specified in the table of supported access types.</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-pMemoryBarriers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If memoryBarrierCount is not 0, pMemoryBarriers must be a valid pointer to an array of memoryBarrierCount valid VkMemoryBarrier structures</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-srcQueueFamilyIndex-01182</th><th><span style="color:limegreen;">Y</span></th><th>ImageBarrierSubpassConflicts</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If vkCmdPipelineBarrier is called within a render pass instance, the srcQueueFamilyIndex and dstQueueFamilyIndex members of any element of pImageMemoryBarriers must be VK_QUEUE_FAMILY_IGNORED</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-srcStageMask-01168</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-srcStageMask-01170</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-srcStageMask-01183</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> Any pipeline stage included in srcStageMask or dstStageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages.</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-srcStageMask-02115</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-srcStageMask-02116</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdPipelineBarrier</th><th>(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-srcStageMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> srcStageMask must be a valid combination of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-vkCmdPipelineBarrier-srcStageMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPipelineBarrier</th><th>core</th><th> srcStageMask must not be 0</th></tr>
<tr><th>VUID-vkCmdProcessCommandsNVX-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdProcessCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdProcessCommandsNVX-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdProcessCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdProcessCommandsNVX-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdProcessCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdProcessCommandsNVX-pProcessCommandsInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdProcessCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pProcessCommandsInfo must be a valid pointer to a valid VkCmdProcessCommandsInfoNVX structure</th></tr>
<tr><th>VUID-vkCmdProcessCommandsNVX-renderpass</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdProcessCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdPushConstants-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushConstants</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdPushConstants-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushConstants</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdPushConstants-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushConstants</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdPushConstants-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushConstants</th><th>core</th><th> Both of commandBuffer, and layout must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdPushConstants-layout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushConstants</th><th>core</th><th> layout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-vkCmdPushConstants-offset-00368</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdPushConstants</th><th>core</th><th> offset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdPushConstants-offset-00370</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdPushConstants</th><th>core</th><th> offset must be less than VkPhysicalDeviceLimits::maxPushConstantsSize</th></tr>
<tr><th>VUID-vkCmdPushConstants-offset-01795</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPushConstants</th><th>explicit</th><th>vkCmdPushConstants</th><th>core</th><th> For each byte in the range specified by offset and size and for each shader stage in stageFlags, there must be a push constant range in layout that includes that byte and that stage</th></tr>
<tr><th>VUID-vkCmdPushConstants-offset-01796</th><th><span style="color:limegreen;">Y</span></th><th>InvalidPushConstants</th><th>explicit</th><th>vkCmdPushConstants</th><th>core</th><th> For each byte in the range specified by offset and size and for each push constant range that overlaps that byte, stageFlags must include all stages in that push constant range's VkPushConstantRange::stageFlags</th></tr>
<tr><th>VUID-vkCmdPushConstants-pValues-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushConstants</th><th>core</th><th> pValues must be a valid pointer to an array of size bytes</th></tr>
<tr><th>VUID-vkCmdPushConstants-size-00369</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdPushConstants</th><th>core</th><th> size must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdPushConstants-size-00371</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdPushConstants</th><th>core</th><th> size must be less than or equal to VkPhysicalDeviceLimits::maxPushConstantsSize minus offset</th></tr>
<tr><th>VUID-vkCmdPushConstants-size-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushConstants</th><th>core</th><th> size must be greater than 0</th></tr>
<tr><th>VUID-vkCmdPushConstants-stageFlags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdPushConstants</th><th>core</th><th> stageFlags must be a valid combination of VkShaderStageFlagBits values</th></tr>
<tr><th>VUID-vkCmdPushConstants-stageFlags-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushConstants</th><th>core</th><th> stageFlags must not be 0</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>PushDescriptorSetCmdPushBadArgs</th><th>implicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> Both of commandBuffer, and layout must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-descriptorWriteCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> descriptorWriteCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-layout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> layout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> pDescriptorWrites must be a valid pointer to an array of descriptorWriteCount valid VkWriteDescriptorSet structures</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-00363</th><th><span style="color:limegreen;">Y</span></th><th>PushDescriptorSetCmdPushBadArgs</th><th>explicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> pipelineBindPoint must be supported by the commandBuffer's parent VkCommandPool's queue family</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> pipelineBindPoint must be a valid VkPipelineBindPoint value</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-set-00364</th><th><span style="color:limegreen;">Y</span></th><th>PushDescriptorSetCmdPushBadArgs</th><th>explicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> set must be less than VkPipelineLayoutCreateInfo::setLayoutCount provided when layout was created</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetKHR-set-00365</th><th><span style="color:limegreen;">Y</span></th><th>PushDescriptorSetCmdPushBadArgs</th><th>explicit</th><th>vkCmdPushDescriptorSetKHR</th><th>(VK_KHR_push_descriptor)</th><th> set must be the unique set number in the pipeline layout that uses a descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-00366</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdPushDescriptorSetWithTemplateKHR</th><th>(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> The pipelineBindPoint specified during the creation of the descriptor update template must be supported by the commandBuffer's parent VkCommandPool's queue family</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetWithTemplateKHR</th><th>(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetWithTemplateKHR</th><th>(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetWithTemplateKHR</th><th>(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetWithTemplateKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetWithTemplateKHR</th><th>(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> Each of commandBuffer, descriptorUpdateTemplate, and layout must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetWithTemplateKHR-descriptorUpdateTemplate-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetWithTemplateKHR</th><th>(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetWithTemplateKHR-layout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdPushDescriptorSetWithTemplateKHR</th><th>(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> layout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-vkCmdPushDescriptorSetWithTemplateKHR-pData-01686</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdPushDescriptorSetWithTemplateKHR</th><th>(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> pData must be a valid pointer to a memory that contains one or more valid instances of VkDescriptorImageInfo, VkDescriptorBufferInfo, or VkBufferView in a layout defined by descriptorUpdateTemplate when it was created with vkCreateDescriptorUpdateTemplateKHR</th></tr>
<tr><th>VUID-vkCmdReserveSpaceForCommandsNVX-bufferlevel</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdReserveSpaceForCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> commandBuffer must be a secondary VkCommandBuffer</th></tr>
<tr><th>VUID-vkCmdReserveSpaceForCommandsNVX-commandBuffer-01329</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdReserveSpaceForCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The provided commandBuffer must not have had a prior space reservation since its creation or the last reset.</th></tr>
<tr><th>VUID-vkCmdReserveSpaceForCommandsNVX-commandBuffer-01330</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdReserveSpaceForCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The state of the commandBuffer must be legal to execute all commands within the sequence provided by the indirectCommandsLayout member of pProcessCommandsInfo.</th></tr>
<tr><th>VUID-vkCmdReserveSpaceForCommandsNVX-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdReserveSpaceForCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdReserveSpaceForCommandsNVX-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdReserveSpaceForCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdReserveSpaceForCommandsNVX-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdReserveSpaceForCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdReserveSpaceForCommandsNVX-pReserveSpaceInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdReserveSpaceForCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pReserveSpaceInfo must be a valid pointer to a valid VkCmdReserveSpaceForCommandsInfoNVX structure</th></tr>
<tr><th>VUID-vkCmdReserveSpaceForCommandsNVX-renderpass</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdReserveSpaceForCommandsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> This command must only be called inside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdResetEvent-commandBuffer-01157</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResetEvent</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> commandBuffer's current device mask must include exactly one physical device.</th></tr>
<tr><th>VUID-vkCmdResetEvent-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetEvent</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdResetEvent-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetEvent</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdResetEvent-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetEvent</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdResetEvent-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetEvent</th><th>core</th><th> Both of commandBuffer, and event must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdResetEvent-event-01156</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResetEvent</th><th>core</th><th> When this command executes, event must not be waited on by a vkCmdWaitEvents command that is currently executing</th></tr>
<tr><th>VUID-vkCmdResetEvent-event-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetEvent</th><th>core</th><th> event must be a valid VkEvent handle</th></tr>
<tr><th>VUID-vkCmdResetEvent-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetEvent</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdResetEvent-stageMask-01153</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResetEvent</th><th>core</th><th> stageMask must not include VK_PIPELINE_STAGE_HOST_BIT</th></tr>
<tr><th>VUID-vkCmdResetEvent-stageMask-01154</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResetEvent</th><th>core</th><th> If the geometry shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdResetEvent-stageMask-01155</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResetEvent</th><th>core</th><th> If the tessellation shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdResetEvent-stageMask-02109</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdResetEvent</th><th>(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdResetEvent-stageMask-02110</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdResetEvent</th><th>(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdResetEvent-stageMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdResetEvent</th><th>core</th><th> stageMask must be a valid combination of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-vkCmdResetEvent-stageMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetEvent</th><th>core</th><th> stageMask must not be 0</th></tr>
<tr><th>VUID-vkCmdResetQueryPool-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetQueryPool</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdResetQueryPool-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetQueryPool</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdResetQueryPool-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetQueryPool</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdResetQueryPool-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetQueryPool</th><th>core</th><th> Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdResetQueryPool-firstQuery-00796</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResetQueryPool</th><th>core</th><th> firstQuery must be less than the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdResetQueryPool-firstQuery-00797</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResetQueryPool</th><th>core</th><th> The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdResetQueryPool-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetQueryPool</th><th>core</th><th> queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkCmdResetQueryPool-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResetQueryPool</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdResolveImage-commandBuffer-01837</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image</th></tr>
<tr><th>VUID-vkCmdResolveImage-commandBuffer-01838</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image</th></tr>
<tr><th>VUID-vkCmdResolveImage-commandBuffer-01839</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image</th></tr>
<tr><th>VUID-vkCmdResolveImage-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdResolveImage-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdResolveImage-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdResolveImage-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstImage-00258</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstImage-00259</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstImage-02003</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> The format features of dstImage must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT.</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstImage-02546</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>(VK_EXT_fragment_density_map)</th><th> dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstImage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> dstImage must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstImageLayout-00262</th><th><span style="color:limegreen;">Y</span></th><th>ResolveImageLayoutMismatch</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstImageLayout-00263</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>!(VK_KHR_shared_presentable_image)</th><th> dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstImageLayout-01401</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>(VK_KHR_shared_presentable_image)</th><th> dstImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstImageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> dstImageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstSubresource-01710</th><th><span style="color:limegreen;">Y</span></th><th>ResolveInvalidSubresource</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created</th></tr>
<tr><th>VUID-vkCmdResolveImage-dstSubresource-01712</th><th><span style="color:limegreen;">Y</span></th><th>ResolveInvalidSubresource</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created</th></tr>
<tr><th>VUID-vkCmdResolveImage-pRegions-00253</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> The source region specified by each element of pRegions must be a region that is contained within srcImage</th></tr>
<tr><th>VUID-vkCmdResolveImage-pRegions-00254</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> The destination region specified by each element of pRegions must be a region that is contained within dstImage</th></tr>
<tr><th>VUID-vkCmdResolveImage-pRegions-00255</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory</th></tr>
<tr><th>VUID-vkCmdResolveImage-pRegions-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> pRegions must be a valid pointer to an array of regionCount valid VkImageResolve structures</th></tr>
<tr><th>VUID-vkCmdResolveImage-regionCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> regionCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdResolveImage-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdResolveImage-srcImage-00256</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdResolveImage-srcImage-00257</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> srcImage must have a sample count equal to any valid sample count value other than VK_SAMPLE_COUNT_1_BIT</th></tr>
<tr><th>VUID-vkCmdResolveImage-srcImage-01386</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> srcImage and dstImage must have been created with the same image format</th></tr>
<tr><th>VUID-vkCmdResolveImage-srcImage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> srcImage must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkCmdResolveImage-srcImageLayout-00260</th><th><span style="color:limegreen;">Y</span></th><th>ResolveImageLayoutMismatch</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice</th></tr>
<tr><th>VUID-vkCmdResolveImage-srcImageLayout-00261</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>!(VK_KHR_shared_presentable_image)</th><th> srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdResolveImage-srcImageLayout-01400</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdResolveImage</th><th>(VK_KHR_shared_presentable_image)</th><th> srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL</th></tr>
<tr><th>VUID-vkCmdResolveImage-srcImageLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdResolveImage</th><th>core</th><th> srcImageLayout must be a valid VkImageLayout value</th></tr>
<tr><th>VUID-vkCmdResolveImage-srcSubresource-01709</th><th><span style="color:limegreen;">Y</span></th><th>ResolveInvalidSubresource</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created</th></tr>
<tr><th>VUID-vkCmdResolveImage-srcSubresource-01711</th><th><span style="color:limegreen;">Y</span></th><th>ResolveInvalidSubresource</th><th>explicit</th><th>vkCmdResolveImage</th><th>core</th><th> The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created</th></tr>
<tr><th>VUID-vkCmdSetBlendConstants-None-00612</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetBlendConstants</th><th>core</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_BLEND_CONSTANTS dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetBlendConstants-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetBlendConstants</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetBlendConstants-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetBlendConstants</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetBlendConstants-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetBlendConstants</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetCheckpointNV-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetCheckpointNV</th><th>(VK_NV_device_diagnostic_checkpoints)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations</th></tr>
<tr><th>VUID-vkCmdSetCheckpointNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetCheckpointNV</th><th>(VK_NV_device_diagnostic_checkpoints)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetCheckpointNV-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetCheckpointNV</th><th>(VK_NV_device_diagnostic_checkpoints)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetCoarseSampleOrderNV-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetCoarseSampleOrderNV</th><th>(VK_NV_shading_rate_image)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetCoarseSampleOrderNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetCoarseSampleOrderNV</th><th>(VK_NV_shading_rate_image)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetCoarseSampleOrderNV-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetCoarseSampleOrderNV</th><th>(VK_NV_shading_rate_image)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetCoarseSampleOrderNV-pCustomSampleOrders-02235</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetCoarseSampleOrderNV</th><th>(VK_NV_shading_rate_image)</th><th> The array pCustomSampleOrders must not contain two structures with matching values for both the shadingRate and sampleCount members.</th></tr>
<tr><th>VUID-vkCmdSetCoarseSampleOrderNV-pCustomSampleOrders-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetCoarseSampleOrderNV</th><th>(VK_NV_shading_rate_image)</th><th> If customSampleOrderCount is not 0, pCustomSampleOrders must be a valid pointer to an array of customSampleOrderCount valid VkCoarseSampleOrderCustomNV structures</th></tr>
<tr><th>VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-02081</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>vkCmdSetCoarseSampleOrderNV</th><th>(VK_NV_shading_rate_image)</th><th> If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, customSamplerOrderCount must be 0</th></tr>
<tr><th>VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetCoarseSampleOrderNV</th><th>(VK_NV_shading_rate_image)</th><th> sampleOrderType must be a valid VkCoarseSampleOrderTypeNV value</th></tr>
<tr><th>VUID-vkCmdSetDepthBias-None-00789</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetDepthBias</th><th>core</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetDepthBias-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDepthBias</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetDepthBias-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDepthBias</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetDepthBias-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDepthBias</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetDepthBias-depthBiasClamp-00790</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetDepthBias</th><th>core</th><th> If the depth bias clamping feature is not enabled, depthBiasClamp must be 0.0</th></tr>
<tr><th>VUID-vkCmdSetDepthBounds-None-00599</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetDepthBounds</th><th>core</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_DEPTH_BOUNDS dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetDepthBounds-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDepthBounds</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetDepthBounds-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDepthBounds</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetDepthBounds-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDepthBounds</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetDepthBounds-maxDepthBounds-00601</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetDepthBounds</th><th>(VK_EXT_depth_range_unrestricted)</th><th> Unless the VK_EXT_depth_range_unrestricted extension is enabled maxDepthBounds must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-vkCmdSetDepthBounds-maxDepthBounds-02509</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetDepthBounds</th><th>!(VK_EXT_depth_range_unrestricted)</th><th> maxDepthBounds must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-vkCmdSetDepthBounds-minDepthBounds-00600</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetDepthBounds</th><th>(VK_EXT_depth_range_unrestricted)</th><th> Unless the VK_EXT_depth_range_unrestricted extension is enabled minDepthBounds must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-vkCmdSetDepthBounds-minDepthBounds-02508</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetDepthBounds</th><th>!(VK_EXT_depth_range_unrestricted)</th><th> minDepthBounds must be between 0.0 and 1.0, inclusive</th></tr>
<tr><th>VUID-vkCmdSetDeviceMask-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetDeviceMask</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations</th></tr>
<tr><th>VUID-vkCmdSetDeviceMask-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDeviceMask</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetDeviceMask-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetDeviceMask</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetDeviceMask-deviceMask-00108</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>vkCmdSetDeviceMask</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceMask must be a valid device mask value</th></tr>
<tr><th>VUID-vkCmdSetDeviceMask-deviceMask-00109</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>vkCmdSetDeviceMask</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceMask must not be zero</th></tr>
<tr><th>VUID-vkCmdSetDeviceMask-deviceMask-00110</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>vkCmdSetDeviceMask</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> deviceMask must not include any set bits that were not in the VkDeviceGroupCommandBufferBeginInfo::deviceMask value when the command buffer began recording.</th></tr>
<tr><th>VUID-vkCmdSetDeviceMask-deviceMask-00111</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDeviceMask</th><th>explicit</th><th>vkCmdSetDeviceMask</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If vkCmdSetDeviceMask is called inside a render pass instance, deviceMask must not include any set bits that were not in the VkDeviceGroupRenderPassBeginInfo::deviceMask value when the render pass instance began recording.</th></tr>
<tr><th>VUID-vkCmdSetDiscardRectangleEXT-None-00583</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetDiscardRectangleEXT</th><th>(VK_EXT_discard_rectangles)</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetDiscardRectangleEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetDiscardRectangleEXT</th><th>(VK_EXT_discard_rectangles)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetDiscardRectangleEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDiscardRectangleEXT</th><th>(VK_EXT_discard_rectangles)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetDiscardRectangleEXT-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDiscardRectangleEXT</th><th>(VK_EXT_discard_rectangles)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetDiscardRectangleEXT-discardRectangleCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDiscardRectangleEXT</th><th>(VK_EXT_discard_rectangles)</th><th> discardRectangleCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdSetDiscardRectangleEXT-firstDiscardRectangle-00585</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetDiscardRectangleEXT</th><th>(VK_EXT_discard_rectangles)</th><th> The sum of firstDiscardRectangle and discardRectangleCount must be less than or equal to VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles</th></tr>
<tr><th>VUID-vkCmdSetDiscardRectangleEXT-offset-00588</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetDiscardRectangleEXT</th><th>(VK_EXT_discard_rectangles)</th><th> Evaluation of (offset.x + extent.width) in each VkRect2D element of pDiscardRectangles must not cause a signed integer addition overflow</th></tr>
<tr><th>VUID-vkCmdSetDiscardRectangleEXT-offset-00589</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetDiscardRectangleEXT</th><th>(VK_EXT_discard_rectangles)</th><th> Evaluation of (offset.y + extent.height) in each VkRect2D element of pDiscardRectangles must not cause a signed integer addition overflow</th></tr>
<tr><th>VUID-vkCmdSetDiscardRectangleEXT-pDiscardRectangles-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetDiscardRectangleEXT</th><th>(VK_EXT_discard_rectangles)</th><th> pDiscardRectangles must be a valid pointer to an array of discardRectangleCount VkRect2D structures</th></tr>
<tr><th>VUID-vkCmdSetDiscardRectangleEXT-x-00587</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetDiscardRectangleEXT</th><th>(VK_EXT_discard_rectangles)</th><th> The x and y member of offset in each VkRect2D element of pDiscardRectangles must be greater than or equal to 0</th></tr>
<tr><th>VUID-vkCmdSetEvent-commandBuffer-01152</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetEvent</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> commandBuffer's current device mask must include exactly one physical device.</th></tr>
<tr><th>VUID-vkCmdSetEvent-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetEvent</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdSetEvent-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetEvent</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetEvent-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetEvent</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetEvent-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetEvent</th><th>core</th><th> Both of commandBuffer, and event must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdSetEvent-event-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetEvent</th><th>core</th><th> event must be a valid VkEvent handle</th></tr>
<tr><th>VUID-vkCmdSetEvent-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetEvent</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdSetEvent-stageMask-01149</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetEvent</th><th>core</th><th> stageMask must not include VK_PIPELINE_STAGE_HOST_BIT</th></tr>
<tr><th>VUID-vkCmdSetEvent-stageMask-01150</th><th><span style="color:limegreen;">Y</span></th><th>StageMaskGsTsEnabled</th><th>explicit</th><th>vkCmdSetEvent</th><th>core</th><th> If the geometry shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdSetEvent-stageMask-01151</th><th><span style="color:limegreen;">Y</span></th><th>StageMaskGsTsEnabled</th><th>explicit</th><th>vkCmdSetEvent</th><th>core</th><th> If the tessellation shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdSetEvent-stageMask-02107</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdSetEvent</th><th>(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdSetEvent-stageMask-02108</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdSetEvent</th><th>(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdSetEvent-stageMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetEvent</th><th>core</th><th> stageMask must be a valid combination of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-vkCmdSetEvent-stageMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetEvent</th><th>core</th><th> stageMask must not be 0</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-None-02031</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> The exclusive scissor feature must be enabled.</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-None-02032</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-02036</th><th><span style="color:limegreen;">Y</span></th><th>ExclusiveScissorNV</th><th>explicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> If the multiple viewports feature is not enabled, exclusiveScissorCount must be 1</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> exclusiveScissorCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02033</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> firstExclusiveScissor must be less than VkPhysicalDeviceLimits::maxViewports</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02034</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> The sum of firstExclusiveScissor and exclusiveScissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02035</th><th><span style="color:limegreen;">Y</span></th><th>ExclusiveScissorNV</th><th>explicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> If the multiple viewports feature is not enabled, firstExclusiveScissor must be 0</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-offset-02038</th><th><span style="color:limegreen;">Y</span></th><th>ExclusiveScissorNV</th><th>explicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> Evaluation of (offset.x + extent.width) for each member of pExclusiveScissors must not cause a signed integer addition overflow</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-offset-02039</th><th><span style="color:limegreen;">Y</span></th><th>ExclusiveScissorNV</th><th>explicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> Evaluation of (offset.y + extent.height) for each member of pExclusiveScissors must not cause a signed integer addition overflow</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-pExclusiveScissors-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures</th></tr>
<tr><th>VUID-vkCmdSetExclusiveScissorNV-x-02037</th><th><span style="color:limegreen;">Y</span></th><th>ExclusiveScissorNV</th><th>explicit</th><th>vkCmdSetExclusiveScissorNV</th><th>(VK_NV_scissor_exclusive)</th><th> The x and y members of offset in each member of pExclusiveScissors must be greater than or equal to 0</th></tr>
<tr><th>VUID-vkCmdSetLineWidth-None-00787</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetLineWidth</th><th>core</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_LINE_WIDTH dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetLineWidth-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetLineWidth</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetLineWidth-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetLineWidth</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetLineWidth-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetLineWidth</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetLineWidth-lineWidth-00788</th><th><span style="color:limegreen;">Y</span></th><th>PSOLineWidthInvalid</th><th>explicit</th><th>vkCmdSetLineWidth</th><th>core</th><th> If the wide lines feature is not enabled, lineWidth must be 1.0</th></tr>
<tr><th>VUID-vkCmdSetSampleLocationsEXT-None-01528</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetSampleLocationsEXT-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetSampleLocationsEXT-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetSampleLocationsEXT-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetSampleLocationsEXT-pSampleLocationsInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> pSampleLocationsInfo must be a valid pointer to a valid VkSampleLocationsInfoEXT structure</th></tr>
<tr><th>VUID-vkCmdSetSampleLocationsEXT-sampleLocationsPerPixel-01529</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> The sampleLocationsPerPixel member of pSampleLocationsInfo must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with</th></tr>
<tr><th>VUID-vkCmdSetSampleLocationsEXT-variableSampleLocations-01530</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetSampleLocationsEXT</th><th>(VK_EXT_sample_locations)</th><th> If VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_FALSE then the current render pass must have been begun by specifying a VkRenderPassSampleLocationsBeginInfoEXT structure whose pPostSubpassSampleLocations member contains an element with a subpassIndex matching the current subpass index and the sampleLocationsInfo member of that element must match the sample locations state pointed to by pSampleLocationsInfo</th></tr>
<tr><th>VUID-vkCmdSetScissor-None-00590</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetScissor</th><th>core</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_SCISSOR dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetScissor-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetScissor</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetScissor-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetScissor</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetScissor-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetScissor</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetScissor-firstScissor-00591</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetScissor</th><th>core</th><th> firstScissor must be less than VkPhysicalDeviceLimits::maxViewports</th></tr>
<tr><th>VUID-vkCmdSetScissor-firstScissor-00592</th><th><span style="color:limegreen;">Y</span></th><th>SetDynScissorParamMultiviewportTests</th><th>explicit</th><th>vkCmdSetScissor</th><th>core</th><th> The sum of firstScissor and scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive</th></tr>
<tr><th>VUID-vkCmdSetScissor-firstScissor-00593</th><th><span style="color:limegreen;">Y</span></th><th>SetDynScissorParamTests</th><th>explicit</th><th>vkCmdSetScissor</th><th>core</th><th> If the multiple viewports feature is not enabled, firstScissor must be 0</th></tr>
<tr><th>VUID-vkCmdSetScissor-offset-00596</th><th><span style="color:limegreen;">Y</span></th><th>SetDynScissorParamTests</th><th>explicit</th><th>vkCmdSetScissor</th><th>core</th><th> Evaluation of (offset.x + extent.width) must not cause a signed integer addition overflow</th></tr>
<tr><th>VUID-vkCmdSetScissor-offset-00597</th><th><span style="color:limegreen;">Y</span></th><th>SetDynScissorParamTests</th><th>explicit</th><th>vkCmdSetScissor</th><th>core</th><th> Evaluation of (offset.y + extent.height) must not cause a signed integer addition overflow</th></tr>
<tr><th>VUID-vkCmdSetScissor-pScissors-parameter</th><th><span style="color:limegreen;">Y</span></th><th>SetDynScissorParamTests, SetDynScissorParamMultiviewportTests</th><th>implicit</th><th>vkCmdSetScissor</th><th>core</th><th> pScissors must be a valid pointer to an array of scissorCount VkRect2D structures</th></tr>
<tr><th>VUID-vkCmdSetScissor-scissorCount-00594</th><th><span style="color:limegreen;">Y</span></th><th>SetDynScissorParamTests</th><th>explicit</th><th>vkCmdSetScissor</th><th>core</th><th> If the multiple viewports feature is not enabled, scissorCount must be 1</th></tr>
<tr><th>VUID-vkCmdSetScissor-scissorCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>SetDynScissorParamTests, SetDynScissorParamMultiviewportTests</th><th>implicit</th><th>vkCmdSetScissor</th><th>core</th><th> scissorCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdSetScissor-x-00595</th><th><span style="color:limegreen;">Y</span></th><th>SetDynScissorParamTests</th><th>explicit</th><th>vkCmdSetScissor</th><th>core</th><th> The x and y members of offset must be greater than or equal to 0</th></tr>
<tr><th>VUID-vkCmdSetStencilCompareMask-None-00602</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetStencilCompareMask</th><th>core</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetStencilCompareMask-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilCompareMask</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetStencilCompareMask-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilCompareMask</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetStencilCompareMask-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilCompareMask</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetStencilCompareMask-faceMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilCompareMask</th><th>core</th><th> faceMask must be a valid combination of VkStencilFaceFlagBits values</th></tr>
<tr><th>VUID-vkCmdSetStencilCompareMask-faceMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilCompareMask</th><th>core</th><th> faceMask must not be 0</th></tr>
<tr><th>VUID-vkCmdSetStencilReference-None-00604</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetStencilReference</th><th>core</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_STENCIL_REFERENCE dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetStencilReference-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilReference</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetStencilReference-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilReference</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetStencilReference-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilReference</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetStencilReference-faceMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilReference</th><th>core</th><th> faceMask must be a valid combination of VkStencilFaceFlagBits values</th></tr>
<tr><th>VUID-vkCmdSetStencilReference-faceMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilReference</th><th>core</th><th> faceMask must not be 0</th></tr>
<tr><th>VUID-vkCmdSetStencilWriteMask-None-00603</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetStencilWriteMask</th><th>core</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_STENCIL_WRITE_MASK dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetStencilWriteMask-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilWriteMask</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetStencilWriteMask-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilWriteMask</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetStencilWriteMask-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilWriteMask</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetStencilWriteMask-faceMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilWriteMask</th><th>core</th><th> faceMask must be a valid combination of VkStencilFaceFlagBits values</th></tr>
<tr><th>VUID-vkCmdSetStencilWriteMask-faceMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetStencilWriteMask</th><th>core</th><th> faceMask must not be 0</th></tr>
<tr><th>VUID-vkCmdSetViewport-None-01221</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetViewport</th><th>core</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_VIEWPORT dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetViewport-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>CommandQueueFlags</th><th>implicit</th><th>vkCmdSetViewport</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetViewport-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewport</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetViewport-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewport</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetViewport-firstViewport-01222</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetViewport</th><th>core</th><th> firstViewport must be less than VkPhysicalDeviceLimits::maxViewports</th></tr>
<tr><th>VUID-vkCmdSetViewport-firstViewport-01223</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamMultiviewportTests</th><th>explicit</th><th>vkCmdSetViewport</th><th>core</th><th> The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive</th></tr>
<tr><th>VUID-vkCmdSetViewport-firstViewport-01224</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>vkCmdSetViewport</th><th>core</th><th> If the multiple viewports feature is not enabled, firstViewport must be 0</th></tr>
<tr><th>VUID-vkCmdSetViewport-pViewports-parameter</th><th><span style="color:limegreen;">Y</span></th><th>RequiredParameter, SetDynViewportParamMultiviewportTests, SetDynViewportParamTests</th><th>implicit</th><th>vkCmdSetViewport</th><th>core</th><th> pViewports must be a valid pointer to an array of viewportCount valid VkViewport structures</th></tr>
<tr><th>VUID-vkCmdSetViewport-viewportCount-01225</th><th><span style="color:limegreen;">Y</span></th><th>SetDynViewportParamTests</th><th>explicit</th><th>vkCmdSetViewport</th><th>core</th><th> If the multiple viewports feature is not enabled, viewportCount must be 1</th></tr>
<tr><th>VUID-vkCmdSetViewport-viewportCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>RequiredParameter, SetDynViewportParamMultiviewportTests, SetDynViewportParamTests</th><th>implicit</th><th>vkCmdSetViewport</th><th>core</th><th> viewportCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-None-02064</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> The shading rate image feature must be enabled.</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-None-02065</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02066</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> firstViewport must be less than VkPhysicalDeviceLimits::maxViewports</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02067</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02068</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> If the multiple viewports feature is not enabled, firstViewport must be 0</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-pShadingRatePalettes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> pShadingRatePalettes must be a valid pointer to an array of viewportCount valid VkShadingRatePaletteNV structures</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-02069</th><th><span style="color:limegreen;">Y</span></th><th>ShadingRateImageNV</th><th>explicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> If the multiple viewports feature is not enabled, viewportCount must be 1</th></tr>
<tr><th>VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewportShadingRatePaletteNV</th><th>(VK_NV_shading_rate_image)</th><th> viewportCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdSetViewportWScalingNV-None-01322</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetViewportWScalingNV</th><th>(VK_NV_clip_space_w_scaling)</th><th> The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled</th></tr>
<tr><th>VUID-vkCmdSetViewportWScalingNV-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewportWScalingNV</th><th>(VK_NV_clip_space_w_scaling)</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics operations</th></tr>
<tr><th>VUID-vkCmdSetViewportWScalingNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewportWScalingNV</th><th>(VK_NV_clip_space_w_scaling)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdSetViewportWScalingNV-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewportWScalingNV</th><th>(VK_NV_clip_space_w_scaling)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdSetViewportWScalingNV-firstViewport-01323</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetViewportWScalingNV</th><th>(VK_NV_clip_space_w_scaling)</th><th> firstViewport must be less than VkPhysicalDeviceLimits::maxViewports</th></tr>
<tr><th>VUID-vkCmdSetViewportWScalingNV-firstViewport-01324</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdSetViewportWScalingNV</th><th>(VK_NV_clip_space_w_scaling)</th><th> The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive</th></tr>
<tr><th>VUID-vkCmdSetViewportWScalingNV-pViewportWScalings-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewportWScalingNV</th><th>(VK_NV_clip_space_w_scaling)</th><th> pViewportWScalings must be a valid pointer to an array of viewportCount VkViewportWScalingNV structures</th></tr>
<tr><th>VUID-vkCmdSetViewportWScalingNV-viewportCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdSetViewportWScalingNV</th><th>(VK_NV_clip_space_w_scaling)</th><th> viewportCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02472</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02473</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02474</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> A valid ray tracing pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_RAY_TRACING_NV</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02475</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, a push constant value must have been set for VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, with a VkPipelineLayout that is compatible for push constants with the one used to create the current VkPipeline, as described in Pipeline Layout Compatibility</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02476</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02477</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02478</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02479</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02480</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02481</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02482</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)+(VK_IMG_filter_cubic)</th><th> If a VkImageView is sampled with VK_FILTER_CUBIC_IMG as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-None-02483</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)+(VK_IMG_filter_cubic)</th><th> Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02461</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> callableShaderBindingOffset must be less than the size of callableShaderBindingTableBuffer</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02462</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> callableShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02465</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> callableShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02468</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> callableShaderBindingStride must be a less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-callableShaderBindingTableBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> If callableShaderBindingTableBuffer is not VK_NULL_HANDLE, callableShaderBindingTableBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-commandBuffer-02484</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)+(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-commandBuffer-02485</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)+(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-commandBuffer-02486</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)+(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, and any pipeline stage other than the ray tracing pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV reads from any image or buffer, the image or buffer must not be a protected image or protected buffer</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> The VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> Each of callableShaderBindingTableBuffer, commandBuffer, hitShaderBindingTableBuffer, missShaderBindingTableBuffer, and raygenShaderBindingTableBuffer that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-depth-02471</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> depth must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-flags-02487</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)+(VK_NV_corner_sampled_image)</th><th> Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-height-02470</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> height must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02459</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> hitShaderBindingOffset must be less than the size of hitShaderBindingTableBuffer</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02460</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> hitShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02464</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> hitShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02467</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> hitShaderBindingStride must be a less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-hitShaderBindingTableBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> If hitShaderBindingTableBuffer is not VK_NULL_HANDLE, hitShaderBindingTableBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02457</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> missShaderBindingOffset must be less than the size of missShaderBindingTableBuffer</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02458</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> missShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-missShaderBindingStride-02463</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> missShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-missShaderBindingStride-02466</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> missShaderBindingStride must be a less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-missShaderBindingTableBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> If missShaderBindingTableBuffer is not VK_NULL_HANDLE, missShaderBindingTableBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02455</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> raygenShaderBindingOffset must be less than the size of raygenShaderBindingTableBuffer</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02456</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> raygenShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-raygenShaderBindingTableBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> raygenShaderBindingTableBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdTraceRaysNV-width-02469</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdTraceRaysNV</th><th>(VK_NV_ray_tracing)</th><th> width must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-commandBuffer-01813</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdUpdateBuffer</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-commandBuffer-01814</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdUpdateBuffer</th><th>(VK_VERSION_1_1)</th><th> If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-dataSize-00033</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> dataSize must be less than or equal to the size of dstBuffer minus dstOffset</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-dataSize-00037</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> dataSize must be less than or equal to 65536</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-dataSize-00038</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> dataSize must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-dataSize-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> dataSize must be greater than 0</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-dstBuffer-00034</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-dstBuffer-00035</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-dstBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> dstBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-dstOffset-00032</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> dstOffset must be less than the size of dstBuffer</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-dstOffset-00036</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> dstOffset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-pData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> pData must be a valid pointer to an array of dataSize bytes</th></tr>
<tr><th>VUID-vkCmdUpdateBuffer-renderpass</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdUpdateBuffer</th><th>core</th><th> This command must only be called outside of a render pass instance</th></tr>
<tr><th>VUID-vkCmdWaitEvents-commandBuffer-01167</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWaitEvents</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> commandBuffer's current device mask must include exactly one physical device.</th></tr>
<tr><th>VUID-vkCmdWaitEvents-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdWaitEvents-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdWaitEvents-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdWaitEvents-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> Both of commandBuffer, and the elements of pEvents must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdWaitEvents-dstStageMask-01160</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdWaitEvents</th><th>core</th><th> If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdWaitEvents-dstStageMask-01162</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdWaitEvents</th><th>core</th><th> If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdWaitEvents-dstStageMask-02113</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdWaitEvents</th><th>(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdWaitEvents-dstStageMask-02114</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdWaitEvents</th><th>(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdWaitEvents-dstStageMask-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> dstStageMask must be a valid combination of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-vkCmdWaitEvents-dstStageMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> dstStageMask must not be 0</th></tr>
<tr><th>VUID-vkCmdWaitEvents-eventCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> eventCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdWaitEvents-pBufferMemoryBarriers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> If bufferMemoryBarrierCount is not 0, pBufferMemoryBarriers must be a valid pointer to an array of bufferMemoryBarrierCount valid VkBufferMemoryBarrier structures</th></tr>
<tr><th>VUID-vkCmdWaitEvents-pEvents-01163</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWaitEvents</th><th>core</th><th> If pEvents includes one or more events that will be signaled by vkSetEvent after commandBuffer has been submitted to a queue, then vkCmdWaitEvents must not be called inside a render pass instance</th></tr>
<tr><th>VUID-vkCmdWaitEvents-pEvents-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> pEvents must be a valid pointer to an array of eventCount valid VkEvent handles</th></tr>
<tr><th>VUID-vkCmdWaitEvents-pImageMemoryBarriers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> If imageMemoryBarrierCount is not 0, pImageMemoryBarriers must be a valid pointer to an array of imageMemoryBarrierCount valid VkImageMemoryBarrier structures</th></tr>
<tr><th>VUID-vkCmdWaitEvents-pMemoryBarriers-01165</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWaitEvents</th><th>core</th><th> Each element of pMemoryBarriers, pBufferMemoryBarriers or pImageMemoryBarriers must not have any access flag included in its srcAccessMask member if that bit is not supported by any of the pipeline stages in srcStageMask, as specified in the table of supported access types.</th></tr>
<tr><th>VUID-vkCmdWaitEvents-pMemoryBarriers-01166</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWaitEvents</th><th>core</th><th> Each element of pMemoryBarriers, pBufferMemoryBarriers or pImageMemoryBarriers must not have any access flag included in its dstAccessMask member if that bit is not supported by any of the pipeline stages in dstStageMask, as specified in the table of supported access types.</th></tr>
<tr><th>VUID-vkCmdWaitEvents-pMemoryBarriers-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> If memoryBarrierCount is not 0, pMemoryBarriers must be a valid pointer to an array of memoryBarrierCount valid VkMemoryBarrier structures</th></tr>
<tr><th>VUID-vkCmdWaitEvents-srcStageMask-01158</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWaitEvents</th><th>core</th><th> srcStageMask must be the bitwise OR of the stageMask parameter used in previous calls to vkCmdSetEvent with any of the members of pEvents and VK_PIPELINE_STAGE_HOST_BIT if any of the members of pEvents was set using vkSetEvent</th></tr>
<tr><th>VUID-vkCmdWaitEvents-srcStageMask-01159</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdWaitEvents</th><th>core</th><th> If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdWaitEvents-srcStageMask-01161</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCmdWaitEvents</th><th>core</th><th> If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</th></tr>
<tr><th>VUID-vkCmdWaitEvents-srcStageMask-01164</th><th><span style="color:limegreen;">Y</span></th><th>InvalidBarriers</th><th>explicit</th><th>vkCmdWaitEvents</th><th>core</th><th> Any pipeline stage included in srcStageMask or dstStageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages.</th></tr>
<tr><th>VUID-vkCmdWaitEvents-srcStageMask-02111</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdWaitEvents</th><th>(VK_NV_mesh_shader)</th><th> If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdWaitEvents-srcStageMask-02112</th><th><span style="color:limegreen;">Y</span></th><th>MeshShaderDisabledNV</th><th>explicit</th><th>vkCmdWaitEvents</th><th>(VK_NV_mesh_shader)</th><th> If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</th></tr>
<tr><th>VUID-vkCmdWaitEvents-srcStageMask-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> srcStageMask must be a valid combination of VkPipelineStageFlagBits values</th></tr>
<tr><th>VUID-vkCmdWaitEvents-srcStageMask-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWaitEvents</th><th>core</th><th> srcStageMask must not be 0</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-accelerationStructureCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> accelerationStructureCount must be greater than 0</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-accelerationStructures-02495</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> All acceleration structures in accelerationStructures must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV if queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> The VkCommandPool that commandBuffer was allocated from must support compute operations</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> Each of commandBuffer, queryPool, and the elements of pAccelerationStructures must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-pAccelerationStructures-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid VkAccelerationStructureNV handles</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-02493</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> queryPool must have been created with a queryType matching queryType</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-02494</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> The queries identified by queryPool and firstQuery must be unavailable</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryType-02242</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> queryType must be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV</th></tr>
<tr><th>VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteAccelerationStructuresPropertiesNV</th><th>(VK_NV_ray_tracing)</th><th> queryType must be a valid VkQueryType value</th></tr>
<tr><th>VUID-vkCmdWriteBufferMarkerAMD-commandBuffer-cmdpool</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdWriteBufferMarkerAMD</th><th>(VK_AMD_buffer_marker)</th><th> The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdWriteBufferMarkerAMD-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteBufferMarkerAMD</th><th>(VK_AMD_buffer_marker)</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdWriteBufferMarkerAMD-commandBuffer-recording</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCmdWriteBufferMarkerAMD</th><th>(VK_AMD_buffer_marker)</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdWriteBufferMarkerAMD-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteBufferMarkerAMD</th><th>(VK_AMD_buffer_marker)</th><th> Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-01799</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteBufferMarkerAMD</th><th>(VK_AMD_buffer_marker)</th><th> dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</th></tr>
<tr><th>VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-01800</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteBufferMarkerAMD</th><th>(VK_AMD_buffer_marker)</th><th> If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object</th></tr>
<tr><th>VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteBufferMarkerAMD</th><th>(VK_AMD_buffer_marker)</th><th> dstBuffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkCmdWriteBufferMarkerAMD-dstOffset-01798</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteBufferMarkerAMD</th><th>(VK_AMD_buffer_marker)</th><th> dstOffset must be less than or equal to the size of dstBuffer minus 4.</th></tr>
<tr><th>VUID-vkCmdWriteBufferMarkerAMD-dstOffset-01801</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteBufferMarkerAMD</th><th>(VK_AMD_buffer_marker)</th><th> dstOffset must be a multiple of 4</th></tr>
<tr><th>VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteBufferMarkerAMD</th><th>(VK_AMD_buffer_marker)</th><th> pipelineStage must be a valid VkPipelineStageFlagBits value</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-None-00830</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteTimestamp</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> All queries used by the command must be unavailable</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-commandBuffer-cmdpool</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteTimestamp</th><th>core</th><th> The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteTimestamp</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-commandBuffer-recording</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteTimestamp</th><th>core</th><th> commandBuffer must be in the recording state</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteTimestamp</th><th>core</th><th> Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-pipelineStage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteTimestamp</th><th>core</th><th> pipelineStage must be a valid VkPipelineStageFlagBits value</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-query-00831</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteTimestamp</th><th>(VK_VERSION_1_1,VK_KHR_multiview)</th><th> If vkCmdWriteTimestamp is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-queryPool-00828</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteTimestamp</th><th>core</th><th> The query identified by queryPool and query must be unavailable</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-queryPool-01416</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteTimestamp</th><th>core</th><th> queryPool must have been created with a queryType of VK_QUERY_TYPE_TIMESTAMP</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCmdWriteTimestamp</th><th>core</th><th> queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkCmdWriteTimestamp-timestampValidBits-00829</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCmdWriteTimestamp</th><th>core</th><th> The command pool's queue family must support a non-zero timestampValidBits</th></tr>
<tr><th>VUID-vkCompileDeferredNV-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCompileDeferredNV</th><th>(VK_NV_ray_tracing)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCompileDeferredNV-pipeline-02237</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCompileDeferredNV</th><th>(VK_NV_ray_tracing)</th><th> pipeline must have been created with VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV</th></tr>
<tr><th>VUID-vkCompileDeferredNV-pipeline-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCompileDeferredNV</th><th>(VK_NV_ray_tracing)</th><th> pipeline must be a valid VkPipeline handle</th></tr>
<tr><th>VUID-vkCompileDeferredNV-pipeline-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCompileDeferredNV</th><th>(VK_NV_ray_tracing)</th><th> pipeline must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkCompileDeferredNV-shader-02238</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCompileDeferredNV</th><th>(VK_NV_ray_tracing)</th><th> shader must not have been called as a deferred compile before</th></tr>
<tr><th>VUID-vkCreateAccelerationStructureNV-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateAccelerationStructureNV-pAccelerationStructure-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> pAccelerationStructure must be a valid pointer to a VkAccelerationStructureNV handle</th></tr>
<tr><th>VUID-vkCreateAccelerationStructureNV-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateAccelerationStructureNV-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> pCreateInfo must be a valid pointer to a valid VkAccelerationStructureCreateInfoNV structure</th></tr>
<tr><th>VUID-vkCreateAndroidSurfaceKHR-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateAndroidSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_android_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateAndroidSurfaceKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateAndroidSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_android_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateAndroidSurfaceKHR-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateAndroidSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_android_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkAndroidSurfaceCreateInfoKHR structure</th></tr>
<tr><th>VUID-vkCreateAndroidSurfaceKHR-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateAndroidSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_android_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateBuffer-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateBuffer</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateBuffer-flags-00911</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCreateBuffer</th><th>core</th><th> If the flags member of pCreateInfo includes VK_BUFFER_CREATE_SPARSE_BINDING_BIT, creating this VkBuffer must not cause the total required sparse memory for all currently valid sparse resources on the device to exceed VkPhysicalDeviceLimits::sparseAddressSpaceSize</th></tr>
<tr><th>VUID-vkCreateBuffer-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateBuffer</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateBuffer-pBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateBuffer</th><th>core</th><th> pBuffer must be a valid pointer to a VkBuffer handle</th></tr>
<tr><th>VUID-vkCreateBuffer-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateBuffer</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkBufferCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateBufferView-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateBufferView</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateBufferView-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateBufferView</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateBufferView-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateBufferView</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkBufferViewCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateBufferView-pView-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateBufferView</th><th>core</th><th> pView must be a valid pointer to a VkBufferView handle</th></tr>
<tr><th>VUID-vkCreateCommandPool-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateCommandPool</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateCommandPool-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateCommandPool</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateCommandPool-pCommandPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateCommandPool</th><th>core</th><th> pCommandPool must be a valid pointer to a VkCommandPool handle</th></tr>
<tr><th>VUID-vkCreateCommandPool-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateCommandPool</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkCommandPoolCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateCommandPool-queueFamilyIndex-01937</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCreateCommandPool</th><th>core</th><th> pCreateInfo::queueFamilyIndex must be the index of a queue family available in the logical device device.</th></tr>
<tr><th>VUID-vkCreateComputePipelines-createInfoCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateComputePipelines</th><th>core</th><th> createInfoCount must be greater than 0</th></tr>
<tr><th>VUID-vkCreateComputePipelines-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateComputePipelines</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateComputePipelines-flags-00695</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCreateComputePipelines</th><th>core</th><th> If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element</th></tr>
<tr><th>VUID-vkCreateComputePipelines-flags-00696</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCreateComputePipelines</th><th>core</th><th> If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set</th></tr>
<tr><th>VUID-vkCreateComputePipelines-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateComputePipelines</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateComputePipelines-pCreateInfos-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateComputePipelines</th><th>core</th><th> pCreateInfos must be a valid pointer to an array of createInfoCount valid VkComputePipelineCreateInfo structures</th></tr>
<tr><th>VUID-vkCreateComputePipelines-pPipelines-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateComputePipelines</th><th>core</th><th> pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles</th></tr>
<tr><th>VUID-vkCreateComputePipelines-pipelineCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateComputePipelines</th><th>core</th><th> If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle</th></tr>
<tr><th>VUID-vkCreateComputePipelines-pipelineCache-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateComputePipelines</th><th>core</th><th> If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkCreateDebugReportCallbackEXT-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDebugReportCallbackEXT</th><th>(VK_EXT_debug_report)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateDebugReportCallbackEXT-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateDebugReportCallbackEXT</th><th>(VK_EXT_debug_report)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateDebugReportCallbackEXT-pCallback-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDebugReportCallbackEXT</th><th>(VK_EXT_debug_report)</th><th> pCallback must be a valid pointer to a VkDebugReportCallbackEXT handle</th></tr>
<tr><th>VUID-vkCreateDebugReportCallbackEXT-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDebugReportCallbackEXT</th><th>(VK_EXT_debug_report)</th><th> pCreateInfo must be a valid pointer to a valid VkDebugReportCallbackCreateInfoEXT structure</th></tr>
<tr><th>VUID-vkCreateDebugUtilsMessengerEXT-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDebugUtilsMessengerEXT</th><th>(VK_EXT_debug_utils)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateDebugUtilsMessengerEXT-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateDebugUtilsMessengerEXT</th><th>(VK_EXT_debug_utils)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateDebugUtilsMessengerEXT-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDebugUtilsMessengerEXT</th><th>(VK_EXT_debug_utils)</th><th> pCreateInfo must be a valid pointer to a valid VkDebugUtilsMessengerCreateInfoEXT structure</th></tr>
<tr><th>VUID-vkCreateDebugUtilsMessengerEXT-pMessenger-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDebugUtilsMessengerEXT</th><th>(VK_EXT_debug_utils)</th><th> pMessenger must be a valid pointer to a VkDebugUtilsMessengerEXT handle</th></tr>
<tr><th>VUID-vkCreateDescriptorPool-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorPool</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateDescriptorPool-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorPool</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateDescriptorPool-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorPool</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkDescriptorPoolCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateDescriptorPool-pDescriptorPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorPool</th><th>core</th><th> pDescriptorPool must be a valid pointer to a VkDescriptorPool handle</th></tr>
<tr><th>VUID-vkCreateDescriptorSetLayout-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorSetLayout</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateDescriptorSetLayout-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorSetLayout</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorSetLayout</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkDescriptorSetLayoutCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorSetLayout</th><th>core</th><th> pSetLayout must be a valid pointer to a VkDescriptorSetLayout handle</th></tr>
<tr><th>VUID-vkCreateDescriptorUpdateTemplate-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorUpdateTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateDescriptorUpdateTemplate-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorUpdateTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorUpdateTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> pCreateInfo must be a valid pointer to a valid VkDescriptorUpdateTemplateCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDescriptorUpdateTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> pDescriptorUpdateTemplate must be a valid pointer to a VkDescriptorUpdateTemplate handle</th></tr>
<tr><th>VUID-vkCreateDevice-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateDevice</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateDevice-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDevice</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkDeviceCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateDevice-pDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDevice</th><th>core</th><th> pDevice must be a valid pointer to a VkDevice handle</th></tr>
<tr><th>VUID-vkCreateDevice-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDevice</th><th>core</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkCreateDevice-ppEnabledExtensionNames-01387</th><th><span style="color:limegreen;">Y</span></th><th>ExtensionNotEnabled</th><th>explicit</th><th>vkCreateDevice</th><th>core</th><th> All required extensions for each extension in the VkDeviceCreateInfo::ppEnabledExtensionNames list must also be present in that list.</th></tr>
<tr><th>VUID-vkCreateDisplayModeKHR-display-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDisplayModeKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> display must be a valid VkDisplayKHR handle</th></tr>
<tr><th>VUID-vkCreateDisplayModeKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateDisplayModeKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateDisplayModeKHR-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDisplayModeKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pCreateInfo must be a valid pointer to a valid VkDisplayModeCreateInfoKHR structure</th></tr>
<tr><th>VUID-vkCreateDisplayModeKHR-pMode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDisplayModeKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pMode must be a valid pointer to a VkDisplayModeKHR handle</th></tr>
<tr><th>VUID-vkCreateDisplayModeKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDisplayModeKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkCreateDisplayPlaneSurfaceKHR-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDisplayPlaneSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateDisplayPlaneSurfaceKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateDisplayPlaneSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateDisplayPlaneSurfaceKHR-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDisplayPlaneSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pCreateInfo must be a valid pointer to a valid VkDisplaySurfaceCreateInfoKHR structure</th></tr>
<tr><th>VUID-vkCreateDisplayPlaneSurfaceKHR-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateDisplayPlaneSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateEvent-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateEvent</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateEvent-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateEvent</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateEvent-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateEvent</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkEventCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateEvent-pEvent-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateEvent</th><th>core</th><th> pEvent must be a valid pointer to a VkEvent handle</th></tr>
<tr><th>VUID-vkCreateFence-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateFence</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateFence-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateFence</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateFence-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateFence</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkFenceCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateFence-pFence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateFence</th><th>core</th><th> pFence must be a valid pointer to a VkFence handle</th></tr>
<tr><th>VUID-vkCreateFramebuffer-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateFramebuffer</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateFramebuffer-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateFramebuffer</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateFramebuffer-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateFramebuffer</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkFramebufferCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateFramebuffer-pFramebuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateFramebuffer</th><th>core</th><th> pFramebuffer must be a valid pointer to a VkFramebuffer handle</th></tr>
<tr><th>VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateGraphicsPipelines</th><th>core</th><th> createInfoCount must be greater than 0</th></tr>
<tr><th>VUID-vkCreateGraphicsPipelines-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateGraphicsPipelines</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateGraphicsPipelines-flags-00720</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCreateGraphicsPipelines</th><th>core</th><th> If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element</th></tr>
<tr><th>VUID-vkCreateGraphicsPipelines-flags-00721</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCreateGraphicsPipelines</th><th>core</th><th> If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set</th></tr>
<tr><th>VUID-vkCreateGraphicsPipelines-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateGraphicsPipelines</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateGraphicsPipelines-pCreateInfos-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateGraphicsPipelines</th><th>core</th><th> pCreateInfos must be a valid pointer to an array of createInfoCount valid VkGraphicsPipelineCreateInfo structures</th></tr>
<tr><th>VUID-vkCreateGraphicsPipelines-pPipelines-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateGraphicsPipelines</th><th>core</th><th> pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles</th></tr>
<tr><th>VUID-vkCreateGraphicsPipelines-pipelineCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateGraphicsPipelines</th><th>core</th><th> If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle</th></tr>
<tr><th>VUID-vkCreateGraphicsPipelines-pipelineCache-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateGraphicsPipelines</th><th>core</th><th> If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkCreateIOSSurfaceMVK-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateIOSSurfaceMVK</th><th>(VK_KHR_surface)+(VK_MVK_ios_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateIOSSurfaceMVK-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateIOSSurfaceMVK</th><th>(VK_KHR_surface)+(VK_MVK_ios_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateIOSSurfaceMVK-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateIOSSurfaceMVK</th><th>(VK_KHR_surface)+(VK_MVK_ios_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkIOSSurfaceCreateInfoMVK structure</th></tr>
<tr><th>VUID-vkCreateIOSSurfaceMVK-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateIOSSurfaceMVK</th><th>(VK_KHR_surface)+(VK_MVK_ios_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateImage-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateImage</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateImage-flags-00939</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCreateImage</th><th>core</th><th> If the flags member of pCreateInfo includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT, creating this VkImage must not cause the total required sparse memory for all currently valid sparse resources on the device to exceed VkPhysicalDeviceLimits::sparseAddressSpaceSize</th></tr>
<tr><th>VUID-vkCreateImage-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateImage</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateImage-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>RequiredParameter</th><th>implicit</th><th>vkCreateImage</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkImageCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateImage-pImage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateImage</th><th>core</th><th> pImage must be a valid pointer to a VkImage handle</th></tr>
<tr><th>VUID-vkCreateImagePipeSurfaceFUCHSIA-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateImagePipeSurfaceFUCHSIA</th><th>(VK_KHR_surface)+(VK_FUCHSIA_imagepipe_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateImagePipeSurfaceFUCHSIA-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateImagePipeSurfaceFUCHSIA</th><th>(VK_KHR_surface)+(VK_FUCHSIA_imagepipe_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateImagePipeSurfaceFUCHSIA-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateImagePipeSurfaceFUCHSIA</th><th>(VK_KHR_surface)+(VK_FUCHSIA_imagepipe_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkImagePipeSurfaceCreateInfoFUCHSIA structure</th></tr>
<tr><th>VUID-vkCreateImagePipeSurfaceFUCHSIA-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateImagePipeSurfaceFUCHSIA</th><th>(VK_KHR_surface)+(VK_FUCHSIA_imagepipe_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateImageView-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateImageView</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateImageView-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateImageView</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateImageView-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateImageView</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkImageViewCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateImageView-pView-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateImageView</th><th>core</th><th> pView must be a valid pointer to a VkImageView handle</th></tr>
<tr><th>VUID-vkCreateIndirectCommandsLayoutNVX-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateIndirectCommandsLayoutNVX-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateIndirectCommandsLayoutNVX-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pCreateInfo must be a valid pointer to a valid VkIndirectCommandsLayoutCreateInfoNVX structure</th></tr>
<tr><th>VUID-vkCreateIndirectCommandsLayoutNVX-pIndirectCommandsLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pIndirectCommandsLayout must be a valid pointer to a VkIndirectCommandsLayoutNVX handle</th></tr>
<tr><th>VUID-vkCreateInstance-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateInstance</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateInstance-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateInstance</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkInstanceCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateInstance-pInstance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateInstance</th><th>core</th><th> pInstance must be a valid pointer to a VkInstance handle</th></tr>
<tr><th>VUID-vkCreateInstance-ppEnabledExtensionNames-01388</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkCreateInstance</th><th>core</th><th> All required extensions for each extension in the VkInstanceCreateInfo::ppEnabledExtensionNames list must also be present in that list.</th></tr>
<tr><th>VUID-vkCreateMacOSSurfaceMVK-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateMacOSSurfaceMVK</th><th>(VK_KHR_surface)+(VK_MVK_macos_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateMacOSSurfaceMVK-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateMacOSSurfaceMVK</th><th>(VK_KHR_surface)+(VK_MVK_macos_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateMacOSSurfaceMVK-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateMacOSSurfaceMVK</th><th>(VK_KHR_surface)+(VK_MVK_macos_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkMacOSSurfaceCreateInfoMVK structure</th></tr>
<tr><th>VUID-vkCreateMacOSSurfaceMVK-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateMacOSSurfaceMVK</th><th>(VK_KHR_surface)+(VK_MVK_macos_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateMetalSurfaceEXT-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateMetalSurfaceEXT</th><th>(VK_KHR_surface)+(VK_EXT_metal_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateMetalSurfaceEXT-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateMetalSurfaceEXT</th><th>(VK_KHR_surface)+(VK_EXT_metal_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateMetalSurfaceEXT-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateMetalSurfaceEXT</th><th>(VK_KHR_surface)+(VK_EXT_metal_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkMetalSurfaceCreateInfoEXT structure</th></tr>
<tr><th>VUID-vkCreateMetalSurfaceEXT-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateMetalSurfaceEXT</th><th>(VK_KHR_surface)+(VK_EXT_metal_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateObjectTableNVX-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateObjectTableNVX-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateObjectTableNVX-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pCreateInfo must be a valid pointer to a valid VkObjectTableCreateInfoNVX structure</th></tr>
<tr><th>VUID-vkCreateObjectTableNVX-pObjectTable-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pObjectTable must be a valid pointer to a VkObjectTableNVX handle</th></tr>
<tr><th>VUID-vkCreatePipelineCache-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreatePipelineCache</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreatePipelineCache-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreatePipelineCache</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreatePipelineCache-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreatePipelineCache</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkPipelineCacheCreateInfo structure</th></tr>
<tr><th>VUID-vkCreatePipelineCache-pPipelineCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreatePipelineCache</th><th>core</th><th> pPipelineCache must be a valid pointer to a VkPipelineCache handle</th></tr>
<tr><th>VUID-vkCreatePipelineLayout-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreatePipelineLayout</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreatePipelineLayout-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreatePipelineLayout</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreatePipelineLayout-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreatePipelineLayout</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkPipelineLayoutCreateInfo structure</th></tr>
<tr><th>VUID-vkCreatePipelineLayout-pPipelineLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreatePipelineLayout</th><th>core</th><th> pPipelineLayout must be a valid pointer to a VkPipelineLayout handle</th></tr>
<tr><th>VUID-vkCreateQueryPool-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateQueryPool</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateQueryPool-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateQueryPool</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateQueryPool-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateQueryPool</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkQueryPoolCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateQueryPool-pQueryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateQueryPool</th><th>core</th><th> pQueryPool must be a valid pointer to a VkQueryPool handle</th></tr>
<tr><th>VUID-vkCreateRayTracingPipelinesNV-createInfoCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRayTracingPipelinesNV</th><th>(VK_NV_ray_tracing)</th><th> createInfoCount must be greater than 0</th></tr>
<tr><th>VUID-vkCreateRayTracingPipelinesNV-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRayTracingPipelinesNV</th><th>(VK_NV_ray_tracing)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateRayTracingPipelinesNV-flags-02402</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCreateRayTracingPipelinesNV</th><th>(VK_NV_ray_tracing)</th><th> If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element</th></tr>
<tr><th>VUID-vkCreateRayTracingPipelinesNV-flags-02403</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCreateRayTracingPipelinesNV</th><th>(VK_NV_ray_tracing)</th><th> If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set</th></tr>
<tr><th>VUID-vkCreateRayTracingPipelinesNV-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateRayTracingPipelinesNV</th><th>(VK_NV_ray_tracing)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateRayTracingPipelinesNV-pCreateInfos-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRayTracingPipelinesNV</th><th>(VK_NV_ray_tracing)</th><th> pCreateInfos must be a valid pointer to an array of createInfoCount valid VkRayTracingPipelineCreateInfoNV structures</th></tr>
<tr><th>VUID-vkCreateRayTracingPipelinesNV-pPipelines-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRayTracingPipelinesNV</th><th>(VK_NV_ray_tracing)</th><th> pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles</th></tr>
<tr><th>VUID-vkCreateRayTracingPipelinesNV-pipelineCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRayTracingPipelinesNV</th><th>(VK_NV_ray_tracing)</th><th> If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle</th></tr>
<tr><th>VUID-vkCreateRayTracingPipelinesNV-pipelineCache-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRayTracingPipelinesNV</th><th>(VK_NV_ray_tracing)</th><th> If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkCreateRenderPass-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRenderPass</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateRenderPass-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateRenderPass</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateRenderPass-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRenderPass</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkRenderPassCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateRenderPass-pRenderPass-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRenderPass</th><th>core</th><th> pRenderPass must be a valid pointer to a VkRenderPass handle</th></tr>
<tr><th>VUID-vkCreateRenderPass2KHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateRenderPass2KHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateRenderPass2KHR-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pCreateInfo must be a valid pointer to a valid VkRenderPassCreateInfo2KHR structure</th></tr>
<tr><th>VUID-vkCreateRenderPass2KHR-pRenderPass-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateRenderPass2KHR</th><th>(VK_KHR_create_renderpass2)</th><th> pRenderPass must be a valid pointer to a VkRenderPass handle</th></tr>
<tr><th>VUID-vkCreateSampler-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSampler</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateSampler-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateSampler</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateSampler-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSampler</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkSamplerCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateSampler-pSampler-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSampler</th><th>core</th><th> pSampler must be a valid pointer to a VkSampler handle</th></tr>
<tr><th>VUID-vkCreateSamplerYcbcrConversion-None-01648</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkCreateSamplerYcbcrConversion</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> The sampler Y'CBCR conversion feature must be enabled</th></tr>
<tr><th>VUID-vkCreateSamplerYcbcrConversion-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSamplerYcbcrConversion</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateSamplerYcbcrConversion-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateSamplerYcbcrConversion</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateSamplerYcbcrConversion-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSamplerYcbcrConversion</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> pCreateInfo must be a valid pointer to a valid VkSamplerYcbcrConversionCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateSamplerYcbcrConversion-pYcbcrConversion-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSamplerYcbcrConversion</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> pYcbcrConversion must be a valid pointer to a VkSamplerYcbcrConversion handle</th></tr>
<tr><th>VUID-vkCreateSemaphore-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSemaphore</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateSemaphore-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateSemaphore</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateSemaphore-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSemaphore</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkSemaphoreCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateSemaphore-pSemaphore-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSemaphore</th><th>core</th><th> pSemaphore must be a valid pointer to a VkSemaphore handle</th></tr>
<tr><th>VUID-vkCreateShaderModule-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateShaderModule</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateShaderModule-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateShaderModule</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateShaderModule-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateShaderModule</th><th>core</th><th> pCreateInfo must be a valid pointer to a valid VkShaderModuleCreateInfo structure</th></tr>
<tr><th>VUID-vkCreateShaderModule-pShaderModule-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateShaderModule</th><th>core</th><th> pShaderModule must be a valid pointer to a VkShaderModule handle</th></tr>
<tr><th>VUID-vkCreateSharedSwapchainsKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSharedSwapchainsKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateSharedSwapchainsKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateSharedSwapchainsKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateSharedSwapchainsKHR-pCreateInfos-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSharedSwapchainsKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)</th><th> pCreateInfos must be a valid pointer to an array of swapchainCount valid VkSwapchainCreateInfoKHR structures</th></tr>
<tr><th>VUID-vkCreateSharedSwapchainsKHR-pSwapchains-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSharedSwapchainsKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)</th><th> pSwapchains must be a valid pointer to an array of swapchainCount VkSwapchainKHR handles</th></tr>
<tr><th>VUID-vkCreateSharedSwapchainsKHR-swapchainCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSharedSwapchainsKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)</th><th> swapchainCount must be greater than 0</th></tr>
<tr><th>VUID-vkCreateStreamDescriptorSurfaceGGP-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateStreamDescriptorSurfaceGGP</th><th>(VK_KHR_surface)+(VK_GGP_stream_descriptor_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateStreamDescriptorSurfaceGGP-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateStreamDescriptorSurfaceGGP</th><th>(VK_KHR_surface)+(VK_GGP_stream_descriptor_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateStreamDescriptorSurfaceGGP-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateStreamDescriptorSurfaceGGP</th><th>(VK_KHR_surface)+(VK_GGP_stream_descriptor_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkStreamDescriptorSurfaceCreateInfoGGP structure</th></tr>
<tr><th>VUID-vkCreateStreamDescriptorSurfaceGGP-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateStreamDescriptorSurfaceGGP</th><th>(VK_KHR_surface)+(VK_GGP_stream_descriptor_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateSwapchainKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateSwapchainKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateSwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateSwapchainKHR-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> pCreateInfo must be a valid pointer to a valid VkSwapchainCreateInfoKHR structure</th></tr>
<tr><th>VUID-vkCreateSwapchainKHR-pSwapchain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateSwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> pSwapchain must be a valid pointer to a VkSwapchainKHR handle</th></tr>
<tr><th>VUID-vkCreateValidationCacheEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateValidationCacheEXT</th><th>(VK_EXT_validation_cache)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkCreateValidationCacheEXT-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateValidationCacheEXT</th><th>(VK_EXT_validation_cache)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateValidationCacheEXT-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateValidationCacheEXT</th><th>(VK_EXT_validation_cache)</th><th> pCreateInfo must be a valid pointer to a valid VkValidationCacheCreateInfoEXT structure</th></tr>
<tr><th>VUID-vkCreateValidationCacheEXT-pValidationCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateValidationCacheEXT</th><th>(VK_EXT_validation_cache)</th><th> pValidationCache must be a valid pointer to a VkValidationCacheEXT handle</th></tr>
<tr><th>VUID-vkCreateViSurfaceNN-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateViSurfaceNN</th><th>(VK_KHR_surface)+(VK_NN_vi_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateViSurfaceNN-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateViSurfaceNN</th><th>(VK_KHR_surface)+(VK_NN_vi_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateViSurfaceNN-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateViSurfaceNN</th><th>(VK_KHR_surface)+(VK_NN_vi_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkViSurfaceCreateInfoNN structure</th></tr>
<tr><th>VUID-vkCreateViSurfaceNN-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateViSurfaceNN</th><th>(VK_KHR_surface)+(VK_NN_vi_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateWaylandSurfaceKHR-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateWaylandSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateWaylandSurfaceKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateWaylandSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateWaylandSurfaceKHR-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateWaylandSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkWaylandSurfaceCreateInfoKHR structure</th></tr>
<tr><th>VUID-vkCreateWaylandSurfaceKHR-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateWaylandSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateWin32SurfaceKHR-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateWin32SurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateWin32SurfaceKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateWin32SurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateWin32SurfaceKHR-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateWin32SurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkWin32SurfaceCreateInfoKHR structure</th></tr>
<tr><th>VUID-vkCreateWin32SurfaceKHR-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateWin32SurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateXcbSurfaceKHR-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateXcbSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateXcbSurfaceKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateXcbSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateXcbSurfaceKHR-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateXcbSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkXcbSurfaceCreateInfoKHR structure</th></tr>
<tr><th>VUID-vkCreateXcbSurfaceKHR-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateXcbSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkCreateXlibSurfaceKHR-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateXlibSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkCreateXlibSurfaceKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkCreateXlibSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkCreateXlibSurfaceKHR-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateXlibSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> pCreateInfo must be a valid pointer to a valid VkXlibSurfaceCreateInfoKHR structure</th></tr>
<tr><th>VUID-vkCreateXlibSurfaceKHR-pSurface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkCreateXlibSurfaceKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> pSurface must be a valid pointer to a VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkDebugMarkerSetObjectNameEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDebugMarkerSetObjectNameEXT</th><th>(VK_EXT_debug_marker)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDebugMarkerSetObjectNameEXT-pNameInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDebugMarkerSetObjectNameEXT</th><th>(VK_EXT_debug_marker)</th><th> pNameInfo must be a valid pointer to a valid VkDebugMarkerObjectNameInfoEXT structure</th></tr>
<tr><th>VUID-vkDebugMarkerSetObjectTagEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDebugMarkerSetObjectTagEXT</th><th>(VK_EXT_debug_marker)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDebugMarkerSetObjectTagEXT-pTagInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDebugMarkerSetObjectTagEXT</th><th>(VK_EXT_debug_marker)</th><th> pTagInfo must be a valid pointer to a valid VkDebugMarkerObjectTagInfoEXT structure</th></tr>
<tr><th>VUID-vkDebugReportMessageEXT-flags-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDebugReportMessageEXT</th><th>(VK_EXT_debug_report)</th><th> flags must be a valid combination of VkDebugReportFlagBitsEXT values</th></tr>
<tr><th>VUID-vkDebugReportMessageEXT-flags-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDebugReportMessageEXT</th><th>(VK_EXT_debug_report)</th><th> flags must not be 0</th></tr>
<tr><th>VUID-vkDebugReportMessageEXT-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDebugReportMessageEXT</th><th>(VK_EXT_debug_report)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkDebugReportMessageEXT-object-01241</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDebugReportMessageEXT</th><th>(VK_EXT_debug_report)</th><th> object must be a Vulkan object or VK_NULL_HANDLE</th></tr>
<tr><th>VUID-vkDebugReportMessageEXT-objectType-01498</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDebugReportMessageEXT</th><th>(VK_EXT_debug_report)</th><th> If objectType is not VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT and object is not VK_NULL_HANDLE, object must be a Vulkan object of the corresponding type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship.</th></tr>
<tr><th>VUID-vkDebugReportMessageEXT-objectType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDebugReportMessageEXT</th><th>(VK_EXT_debug_report)</th><th> objectType must be a valid VkDebugReportObjectTypeEXT value</th></tr>
<tr><th>VUID-vkDebugReportMessageEXT-pLayerPrefix-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDebugReportMessageEXT</th><th>(VK_EXT_debug_report)</th><th> pLayerPrefix must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-vkDebugReportMessageEXT-pMessage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDebugReportMessageEXT</th><th>(VK_EXT_debug_report)</th><th> pMessage must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-vkDestroyAccelerationStructureNV-accelerationStructure-02442</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> All submitted commands that refer to accelerationStructure must have completed execution</th></tr>
<tr><th>VUID-vkDestroyAccelerationStructureNV-accelerationStructure-02443</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> If VkAllocationCallbacks were provided when accelerationStructure was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyAccelerationStructureNV-accelerationStructure-02444</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> If no VkAllocationCallbacks were provided when accelerationStructure was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyAccelerationStructureNV-accelerationStructure-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> accelerationStructure must be a valid VkAccelerationStructureNV handle</th></tr>
<tr><th>VUID-vkDestroyAccelerationStructureNV-accelerationStructure-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> accelerationStructure must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyAccelerationStructureNV-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyAccelerationStructureNV-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyAccelerationStructureNV</th><th>(VK_NV_ray_tracing)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyBuffer-buffer-00922</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyBuffer</th><th>core</th><th> All submitted commands that refer to buffer, either directly or via a VkBufferView, must have completed execution</th></tr>
<tr><th>VUID-vkDestroyBuffer-buffer-00923</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyBuffer</th><th>core</th><th> If VkAllocationCallbacks were provided when buffer was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyBuffer-buffer-00924</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyBuffer</th><th>core</th><th> If no VkAllocationCallbacks were provided when buffer was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyBuffer-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>VertexBufferInvalid</th><th>implicit</th><th>vkDestroyBuffer</th><th>core</th><th> If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkDestroyBuffer-buffer-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyBuffer</th><th>core</th><th> If buffer is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyBuffer-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyBuffer</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyBuffer-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyBuffer</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyBufferView-bufferView-00936</th><th><span style="color:limegreen;">Y</span></th><th>BufferViewInUseDestroyedSignaled</th><th>explicit</th><th>vkDestroyBufferView</th><th>core</th><th> All submitted commands that refer to bufferView must have completed execution</th></tr>
<tr><th>VUID-vkDestroyBufferView-bufferView-00937</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyBufferView</th><th>core</th><th> If VkAllocationCallbacks were provided when bufferView was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyBufferView-bufferView-00938</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyBufferView</th><th>core</th><th> If no VkAllocationCallbacks were provided when bufferView was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyBufferView-bufferView-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyBufferView</th><th>core</th><th> If bufferView is not VK_NULL_HANDLE, bufferView must be a valid VkBufferView handle</th></tr>
<tr><th>VUID-vkDestroyBufferView-bufferView-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyBufferView</th><th>core</th><th> If bufferView is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyBufferView-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyBufferView</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyBufferView-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyBufferView</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyCommandPool-commandPool-00041</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyCommandPool</th><th>core</th><th> All VkCommandBuffer objects allocated from commandPool must not be in the pending state.</th></tr>
<tr><th>VUID-vkDestroyCommandPool-commandPool-00042</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyCommandPool</th><th>core</th><th> If VkAllocationCallbacks were provided when commandPool was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyCommandPool-commandPool-00043</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyCommandPool</th><th>core</th><th> If no VkAllocationCallbacks were provided when commandPool was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyCommandPool-commandPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyCommandPool</th><th>core</th><th> If commandPool is not VK_NULL_HANDLE, commandPool must be a valid VkCommandPool handle</th></tr>
<tr><th>VUID-vkDestroyCommandPool-commandPool-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyCommandPool</th><th>core</th><th> If commandPool is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyCommandPool-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyCommandPool</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyCommandPool-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyCommandPool</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyDebugReportCallbackEXT-callback-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDebugReportCallbackEXT</th><th>(VK_EXT_debug_report)</th><th> callback must be a valid VkDebugReportCallbackEXT handle</th></tr>
<tr><th>VUID-vkDestroyDebugReportCallbackEXT-callback-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDebugReportCallbackEXT</th><th>(VK_EXT_debug_report)</th><th> callback must have been created, allocated, or retrieved from instance</th></tr>
<tr><th>VUID-vkDestroyDebugReportCallbackEXT-instance-01242</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyDebugReportCallbackEXT</th><th>(VK_EXT_debug_report)</th><th> If VkAllocationCallbacks were provided when callback was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyDebugReportCallbackEXT-instance-01243</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyDebugReportCallbackEXT</th><th>(VK_EXT_debug_report)</th><th> If no VkAllocationCallbacks were provided when callback was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyDebugReportCallbackEXT-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDebugReportCallbackEXT</th><th>(VK_EXT_debug_report)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkDestroyDebugReportCallbackEXT-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyDebugReportCallbackEXT</th><th>(VK_EXT_debug_report)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyDebugUtilsMessengerEXT-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDebugUtilsMessengerEXT</th><th>(VK_EXT_debug_utils)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkDestroyDebugUtilsMessengerEXT-messenger-01915</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyDebugUtilsMessengerEXT</th><th>(VK_EXT_debug_utils)</th><th> If VkAllocationCallbacks were provided when messenger was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyDebugUtilsMessengerEXT-messenger-01916</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyDebugUtilsMessengerEXT</th><th>(VK_EXT_debug_utils)</th><th> If no VkAllocationCallbacks were provided when messenger was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyDebugUtilsMessengerEXT-messenger-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDebugUtilsMessengerEXT</th><th>(VK_EXT_debug_utils)</th><th> messenger must be a valid VkDebugUtilsMessengerEXT handle</th></tr>
<tr><th>VUID-vkDestroyDebugUtilsMessengerEXT-messenger-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDebugUtilsMessengerEXT</th><th>(VK_EXT_debug_utils)</th><th> messenger must have been created, allocated, or retrieved from instance</th></tr>
<tr><th>VUID-vkDestroyDebugUtilsMessengerEXT-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyDebugUtilsMessengerEXT</th><th>(VK_EXT_debug_utils)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyDescriptorPool-descriptorPool-00303</th><th><span style="color:limegreen;">Y</span></th><th>DescriptorPoolInUseDestroyedSignaled</th><th>explicit</th><th>vkDestroyDescriptorPool</th><th>core</th><th> All submitted commands that refer to descriptorPool (via any allocated descriptor sets) must have completed execution</th></tr>
<tr><th>VUID-vkDestroyDescriptorPool-descriptorPool-00304</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyDescriptorPool</th><th>core</th><th> If VkAllocationCallbacks were provided when descriptorPool was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyDescriptorPool-descriptorPool-00305</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyDescriptorPool</th><th>core</th><th> If no VkAllocationCallbacks were provided when descriptorPool was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyDescriptorPool-descriptorPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorPool</th><th>core</th><th> If descriptorPool is not VK_NULL_HANDLE, descriptorPool must be a valid VkDescriptorPool handle</th></tr>
<tr><th>VUID-vkDestroyDescriptorPool-descriptorPool-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorPool</th><th>core</th><th> If descriptorPool is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyDescriptorPool-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorPool</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyDescriptorPool-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorPool</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00284</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyDescriptorSetLayout</th><th>core</th><th> If VkAllocationCallbacks were provided when descriptorSetLayout was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00285</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyDescriptorSetLayout</th><th>core</th><th> If no VkAllocationCallbacks were provided when descriptorSetLayout was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorSetLayout</th><th>core</th><th> If descriptorSetLayout is not VK_NULL_HANDLE, descriptorSetLayout must be a valid VkDescriptorSetLayout handle</th></tr>
<tr><th>VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorSetLayout</th><th>core</th><th> If descriptorSetLayout is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyDescriptorSetLayout-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorSetLayout</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyDescriptorSetLayout-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorSetLayout</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00356</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyDescriptorUpdateTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> If VkAllocationCallbacks were provided when descriptorSetLayout was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00357</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyDescriptorUpdateTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> If no VkAllocationCallbacks were provided when descriptorSetLayout was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorUpdateTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> If descriptorUpdateTemplate is not VK_NULL_HANDLE, descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle</th></tr>
<tr><th>VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorUpdateTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> If descriptorUpdateTemplate is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyDescriptorUpdateTemplate-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorUpdateTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyDescriptorUpdateTemplate-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyDescriptorUpdateTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyDevice-device-00378</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyDevice</th><th>core</th><th> All child objects created on device must have been destroyed prior to destroying device</th></tr>
<tr><th>VUID-vkDestroyDevice-device-00379</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyDevice</th><th>core</th><th> If VkAllocationCallbacks were provided when device was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyDevice-device-00380</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyDevice</th><th>core</th><th> If no VkAllocationCallbacks were provided when device was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyDevice-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyDevice</th><th>core</th><th> If device is not NULL, device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyDevice-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyDevice</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyEvent-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyEvent</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyEvent-event-01145</th><th><span style="color:limegreen;">Y</span></th><th>InUseDestroyedSignaled</th><th>explicit</th><th>vkDestroyEvent</th><th>core</th><th> All submitted commands that refer to event must have completed execution</th></tr>
<tr><th>VUID-vkDestroyEvent-event-01146</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyEvent</th><th>core</th><th> If VkAllocationCallbacks were provided when event was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyEvent-event-01147</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyEvent</th><th>core</th><th> If no VkAllocationCallbacks were provided when event was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyEvent-event-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyEvent</th><th>core</th><th> If event is not VK_NULL_HANDLE, event must be a valid VkEvent handle</th></tr>
<tr><th>VUID-vkDestroyEvent-event-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyEvent</th><th>core</th><th> If event is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyEvent-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyEvent</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyFence-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyFence</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyFence-fence-01120</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyFence</th><th>core</th><th> All queue submission commands that refer to fence must have completed execution</th></tr>
<tr><th>VUID-vkDestroyFence-fence-01121</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyFence</th><th>core</th><th> If VkAllocationCallbacks were provided when fence was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyFence-fence-01122</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyFence</th><th>core</th><th> If no VkAllocationCallbacks were provided when fence was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyFence-fence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyFence</th><th>core</th><th> If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle</th></tr>
<tr><th>VUID-vkDestroyFence-fence-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyFence</th><th>core</th><th> If fence is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyFence-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyFence</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyFramebuffer-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyFramebuffer</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyFramebuffer-framebuffer-00892</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferInUseDestroyedSignaled</th><th>explicit</th><th>vkDestroyFramebuffer</th><th>core</th><th> All submitted commands that refer to framebuffer must have completed execution</th></tr>
<tr><th>VUID-vkDestroyFramebuffer-framebuffer-00893</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyFramebuffer</th><th>core</th><th> If VkAllocationCallbacks were provided when framebuffer was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyFramebuffer-framebuffer-00894</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyFramebuffer</th><th>core</th><th> If no VkAllocationCallbacks were provided when framebuffer was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyFramebuffer-framebuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyFramebuffer</th><th>core</th><th> If framebuffer is not VK_NULL_HANDLE, framebuffer must be a valid VkFramebuffer handle</th></tr>
<tr><th>VUID-vkDestroyFramebuffer-framebuffer-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyFramebuffer</th><th>core</th><th> If framebuffer is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyFramebuffer-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyFramebuffer</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyImage-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyImage</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyImage-image-01000</th><th><span style="color:limegreen;">Y</span></th><th>FramebufferImageInUseDestroyedSignaled</th><th>explicit</th><th>vkDestroyImage</th><th>core</th><th> All submitted commands that refer to image, either directly or via a VkImageView, must have completed execution</th></tr>
<tr><th>VUID-vkDestroyImage-image-01001</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyImage</th><th>core</th><th> If VkAllocationCallbacks were provided when image was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyImage-image-01002</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyImage</th><th>core</th><th> If no VkAllocationCallbacks were provided when image was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyImage-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyImage</th><th>core</th><th> If image is not VK_NULL_HANDLE, image must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkDestroyImage-image-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyImage</th><th>core</th><th> If image is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyImage-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyImage</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyImageView-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyImageView</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyImageView-imageView-01026</th><th><span style="color:limegreen;">Y</span></th><th>ImageViewInUseDestroyedSignaled</th><th>explicit</th><th>vkDestroyImageView</th><th>core</th><th> All submitted commands that refer to imageView must have completed execution</th></tr>
<tr><th>VUID-vkDestroyImageView-imageView-01027</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyImageView</th><th>core</th><th> If VkAllocationCallbacks were provided when imageView was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyImageView-imageView-01028</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyImageView</th><th>core</th><th> If no VkAllocationCallbacks were provided when imageView was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyImageView-imageView-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyImageView</th><th>core</th><th> If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle</th></tr>
<tr><th>VUID-vkDestroyImageView-imageView-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyImageView</th><th>core</th><th> If imageView is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyImageView-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyImageView</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyIndirectCommandsLayoutNVX-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyIndirectCommandsLayoutNVX-indirectCommandsLayout-01352</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> All submitted commands that refer to indirectCommandsLayout must have completed execution</th></tr>
<tr><th>VUID-vkDestroyIndirectCommandsLayoutNVX-indirectCommandsLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle</th></tr>
<tr><th>VUID-vkDestroyIndirectCommandsLayoutNVX-indirectCommandsLayout-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> indirectCommandsLayout must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyIndirectCommandsLayoutNVX-objectTable-01353</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If VkAllocationCallbacks were provided when objectTable was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyIndirectCommandsLayoutNVX-objectTable-01354</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If no VkAllocationCallbacks were provided when objectTable was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyIndirectCommandsLayoutNVX-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyIndirectCommandsLayoutNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyInstance-instance-00629</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyInstance</th><th>core</th><th> All child objects created using instance must have been destroyed prior to destroying instance</th></tr>
<tr><th>VUID-vkDestroyInstance-instance-00630</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyInstance</th><th>core</th><th> If VkAllocationCallbacks were provided when instance was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyInstance-instance-00631</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyInstance</th><th>core</th><th> If no VkAllocationCallbacks were provided when instance was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyInstance-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyInstance</th><th>core</th><th> If instance is not NULL, instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkDestroyInstance-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyInstance</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyObjectTableNVX-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyObjectTableNVX-objectTable-01361</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> All submitted commands that refer to objectTable must have completed execution.</th></tr>
<tr><th>VUID-vkDestroyObjectTableNVX-objectTable-01362</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If VkAllocationCallbacks were provided when objectTable was created, a compatible set of callbacks must be provided here.</th></tr>
<tr><th>VUID-vkDestroyObjectTableNVX-objectTable-01363</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If no VkAllocationCallbacks were provided when objectTable was created, pAllocator must be NULL.</th></tr>
<tr><th>VUID-vkDestroyObjectTableNVX-objectTable-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectTable must be a valid VkObjectTableNVX handle</th></tr>
<tr><th>VUID-vkDestroyObjectTableNVX-objectTable-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectTable must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyObjectTableNVX-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyObjectTableNVX</th><th>(VK_NVX_device_generated_commands)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyPipeline-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyPipeline</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyPipeline-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyPipeline</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyPipeline-pipeline-00765</th><th><span style="color:limegreen;">Y</span></th><th>PipelineInUseDestroyedSignaled</th><th>explicit</th><th>vkDestroyPipeline</th><th>core</th><th> All submitted commands that refer to pipeline must have completed execution</th></tr>
<tr><th>VUID-vkDestroyPipeline-pipeline-00766</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyPipeline</th><th>core</th><th> If VkAllocationCallbacks were provided when pipeline was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyPipeline-pipeline-00767</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyPipeline</th><th>core</th><th> If no VkAllocationCallbacks were provided when pipeline was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyPipeline-pipeline-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyPipeline</th><th>core</th><th> If pipeline is not VK_NULL_HANDLE, pipeline must be a valid VkPipeline handle</th></tr>
<tr><th>VUID-vkDestroyPipeline-pipeline-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyPipeline</th><th>core</th><th> If pipeline is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyPipelineCache-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyPipelineCache</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyPipelineCache-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyPipelineCache</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyPipelineCache-pipelineCache-00771</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyPipelineCache</th><th>core</th><th> If VkAllocationCallbacks were provided when pipelineCache was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyPipelineCache-pipelineCache-00772</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyPipelineCache</th><th>core</th><th> If no VkAllocationCallbacks were provided when pipelineCache was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyPipelineCache-pipelineCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyPipelineCache</th><th>core</th><th> If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle</th></tr>
<tr><th>VUID-vkDestroyPipelineCache-pipelineCache-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyPipelineCache</th><th>core</th><th> If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyPipelineLayout-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyPipelineLayout</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyPipelineLayout-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyPipelineLayout</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyPipelineLayout-pipelineLayout-00299</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyPipelineLayout</th><th>core</th><th> If VkAllocationCallbacks were provided when pipelineLayout was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyPipelineLayout-pipelineLayout-00300</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyPipelineLayout</th><th>core</th><th> If no VkAllocationCallbacks were provided when pipelineLayout was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyPipelineLayout-pipelineLayout-02004</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyPipelineLayout</th><th>core</th><th> pipelineLayout must not have been passed to any vkCmd* command for any command buffers that are still in the recording state when vkDestroyPipelineLayout is called</th></tr>
<tr><th>VUID-vkDestroyPipelineLayout-pipelineLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyPipelineLayout</th><th>core</th><th> If pipelineLayout is not VK_NULL_HANDLE, pipelineLayout must be a valid VkPipelineLayout handle</th></tr>
<tr><th>VUID-vkDestroyPipelineLayout-pipelineLayout-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyPipelineLayout</th><th>core</th><th> If pipelineLayout is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyQueryPool-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyQueryPool</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyQueryPool-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyQueryPool</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyQueryPool-queryPool-00793</th><th><span style="color:limegreen;">Y</span></th><th>QueryPoolInUseDestroyedSignaled</th><th>explicit</th><th>vkDestroyQueryPool</th><th>core</th><th> All submitted commands that refer to queryPool must have completed execution</th></tr>
<tr><th>VUID-vkDestroyQueryPool-queryPool-00794</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyQueryPool</th><th>core</th><th> If VkAllocationCallbacks were provided when queryPool was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyQueryPool-queryPool-00795</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyQueryPool</th><th>core</th><th> If no VkAllocationCallbacks were provided when queryPool was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyQueryPool-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyQueryPool</th><th>core</th><th> If queryPool is not VK_NULL_HANDLE, queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkDestroyQueryPool-queryPool-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyQueryPool</th><th>core</th><th> If queryPool is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyRenderPass-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyRenderPass</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyRenderPass-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyRenderPass</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyRenderPass-renderPass-00873</th><th><span style="color:limegreen;">Y</span></th><th>RenderPassDestroyWhileInUse</th><th>explicit</th><th>vkDestroyRenderPass</th><th>core</th><th> All submitted commands that refer to renderPass must have completed execution</th></tr>
<tr><th>VUID-vkDestroyRenderPass-renderPass-00874</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyRenderPass</th><th>core</th><th> If VkAllocationCallbacks were provided when renderPass was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyRenderPass-renderPass-00875</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyRenderPass</th><th>core</th><th> If no VkAllocationCallbacks were provided when renderPass was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyRenderPass-renderPass-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyRenderPass</th><th>core</th><th> If renderPass is not VK_NULL_HANDLE, renderPass must be a valid VkRenderPass handle</th></tr>
<tr><th>VUID-vkDestroyRenderPass-renderPass-parent</th><th><span style="color:limegreen;">Y</span></th><th>UseObjectWithWrongDevice</th><th>implicit</th><th>vkDestroyRenderPass</th><th>core</th><th> If renderPass is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroySampler-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySampler</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroySampler-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroySampler</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroySampler-sampler-01082</th><th><span style="color:limegreen;">Y</span></th><th>SamplerInUseDestroyedSignaled</th><th>explicit</th><th>vkDestroySampler</th><th>core</th><th> All submitted commands that refer to sampler must have completed execution</th></tr>
<tr><th>VUID-vkDestroySampler-sampler-01083</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroySampler</th><th>core</th><th> If VkAllocationCallbacks were provided when sampler was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroySampler-sampler-01084</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroySampler</th><th>core</th><th> If no VkAllocationCallbacks were provided when sampler was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroySampler-sampler-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySampler</th><th>core</th><th> If sampler is not VK_NULL_HANDLE, sampler must be a valid VkSampler handle</th></tr>
<tr><th>VUID-vkDestroySampler-sampler-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySampler</th><th>core</th><th> If sampler is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroySamplerYcbcrConversion-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySamplerYcbcrConversion</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroySamplerYcbcrConversion-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroySamplerYcbcrConversion</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroySamplerYcbcrConversion-ycbcrConversion-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySamplerYcbcrConversion</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If ycbcrConversion is not VK_NULL_HANDLE, ycbcrConversion must be a valid VkSamplerYcbcrConversion handle</th></tr>
<tr><th>VUID-vkDestroySamplerYcbcrConversion-ycbcrConversion-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySamplerYcbcrConversion</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If ycbcrConversion is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroySemaphore-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySemaphore</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroySemaphore-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroySemaphore</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroySemaphore-semaphore-01137</th><th><span style="color:limegreen;">Y</span></th><th>InUseDestroyedSignaled</th><th>explicit</th><th>vkDestroySemaphore</th><th>core</th><th> All submitted batches that refer to semaphore must have completed execution</th></tr>
<tr><th>VUID-vkDestroySemaphore-semaphore-01138</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroySemaphore</th><th>core</th><th> If VkAllocationCallbacks were provided when semaphore was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroySemaphore-semaphore-01139</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroySemaphore</th><th>core</th><th> If no VkAllocationCallbacks were provided when semaphore was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroySemaphore-semaphore-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySemaphore</th><th>core</th><th> If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle</th></tr>
<tr><th>VUID-vkDestroySemaphore-semaphore-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySemaphore</th><th>core</th><th> If semaphore is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroyShaderModule-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyShaderModule</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyShaderModule-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyShaderModule</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyShaderModule-shaderModule-01092</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyShaderModule</th><th>core</th><th> If VkAllocationCallbacks were provided when shaderModule was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyShaderModule-shaderModule-01093</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroyShaderModule</th><th>core</th><th> If no VkAllocationCallbacks were provided when shaderModule was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyShaderModule-shaderModule-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyShaderModule</th><th>core</th><th> If shaderModule is not VK_NULL_HANDLE, shaderModule must be a valid VkShaderModule handle</th></tr>
<tr><th>VUID-vkDestroyShaderModule-shaderModule-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyShaderModule</th><th>core</th><th> If shaderModule is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDestroySurfaceKHR-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySurfaceKHR</th><th>(VK_KHR_surface)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkDestroySurfaceKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroySurfaceKHR</th><th>(VK_KHR_surface)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroySurfaceKHR-surface-01266</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroySurfaceKHR</th><th>(VK_KHR_surface)</th><th> All VkSwapchainKHR objects created for surface must have been destroyed prior to destroying surface</th></tr>
<tr><th>VUID-vkDestroySurfaceKHR-surface-01267</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroySurfaceKHR</th><th>(VK_KHR_surface)</th><th> If VkAllocationCallbacks were provided when surface was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroySurfaceKHR-surface-01268</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroySurfaceKHR</th><th>(VK_KHR_surface)</th><th> If no VkAllocationCallbacks were provided when surface was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroySurfaceKHR-surface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySurfaceKHR</th><th>(VK_KHR_surface)</th><th> If surface is not VK_NULL_HANDLE, surface must be a valid VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkDestroySurfaceKHR-surface-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroySurfaceKHR</th><th>(VK_KHR_surface)</th><th> If surface is a valid handle, it must have been created, allocated, or retrieved from instance</th></tr>
<tr><th>VUID-vkDestroySwapchainKHR-commonparent</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroySwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> Both of device, and swapchain that are valid handles must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkDestroySwapchainKHR-device-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroySwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroySwapchainKHR-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroySwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroySwapchainKHR-swapchain-01282</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroySwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> All uses of presentable images acquired from swapchain must have completed execution</th></tr>
<tr><th>VUID-vkDestroySwapchainKHR-swapchain-01283</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroySwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If VkAllocationCallbacks were provided when swapchain was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroySwapchainKHR-swapchain-01284</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkDestroySwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If no VkAllocationCallbacks were provided when swapchain was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroySwapchainKHR-swapchain-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroySwapchainKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If swapchain is not VK_NULL_HANDLE, swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-vkDestroyValidationCacheEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyValidationCacheEXT</th><th>(VK_EXT_validation_cache)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDestroyValidationCacheEXT-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkDestroyValidationCacheEXT</th><th>(VK_EXT_validation_cache)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkDestroyValidationCacheEXT-validationCache-01537</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyValidationCacheEXT</th><th>(VK_EXT_validation_cache)</th><th> If VkAllocationCallbacks were provided when validationCache was created, a compatible set of callbacks must be provided here</th></tr>
<tr><th>VUID-vkDestroyValidationCacheEXT-validationCache-01538</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkDestroyValidationCacheEXT</th><th>(VK_EXT_validation_cache)</th><th> If no VkAllocationCallbacks were provided when validationCache was created, pAllocator must be NULL</th></tr>
<tr><th>VUID-vkDestroyValidationCacheEXT-validationCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyValidationCacheEXT</th><th>(VK_EXT_validation_cache)</th><th> If validationCache is not VK_NULL_HANDLE, validationCache must be a valid VkValidationCacheEXT handle</th></tr>
<tr><th>VUID-vkDestroyValidationCacheEXT-validationCache-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDestroyValidationCacheEXT</th><th>(VK_EXT_validation_cache)</th><th> If validationCache is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkDeviceWaitIdle-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDeviceWaitIdle</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDisplayPowerControlEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDisplayPowerControlEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkDisplayPowerControlEXT-display-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDisplayPowerControlEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control)</th><th> display must be a valid VkDisplayKHR handle</th></tr>
<tr><th>VUID-vkDisplayPowerControlEXT-pDisplayPowerInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkDisplayPowerControlEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control)</th><th> pDisplayPowerInfo must be a valid pointer to a valid VkDisplayPowerInfoEXT structure</th></tr>
<tr><th>VUID-vkEndCommandBuffer-None-01978</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkEndCommandBuffer</th><th>(VK_EXT_conditional_rendering)</th><th> Conditional rendering must not be active</th></tr>
<tr><th>VUID-vkEndCommandBuffer-commandBuffer-00059</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkEndCommandBuffer</th><th>core</th><th> commandBuffer must be in the recording state.</th></tr>
<tr><th>VUID-vkEndCommandBuffer-commandBuffer-00060</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkEndCommandBuffer</th><th>core</th><th> If commandBuffer is a primary command buffer, there must not be an active render pass instance</th></tr>
<tr><th>VUID-vkEndCommandBuffer-commandBuffer-00061</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkEndCommandBuffer</th><th>core</th><th> All queries made active during the recording of commandBuffer must have been made inactive</th></tr>
<tr><th>VUID-vkEndCommandBuffer-commandBuffer-00062</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkEndCommandBuffer</th><th>(VK_EXT_debug_marker)</th><th> If commandBuffer is a secondary command buffer, there must not be an outstanding vkCmdDebugMarkerBeginEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdDebugMarkerEndEXT.</th></tr>
<tr><th>VUID-vkEndCommandBuffer-commandBuffer-01815</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkEndCommandBuffer</th><th>(VK_EXT_debug_utils)</th><th> If commandBuffer is a secondary command buffer, there must not be an outstanding vkCmdBeginDebugUtilsLabelEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdEndDebugUtilsLabelEXT.</th></tr>
<tr><th>VUID-vkEndCommandBuffer-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkEndCommandBuffer</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkEnumerateDeviceExtensionProperties-pLayerName-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumerateDeviceExtensionProperties</th><th>core</th><th> If pLayerName is not NULL, pLayerName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-vkEnumerateDeviceExtensionProperties-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkEnumerateDeviceExtensionProperties</th><th>core</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkExtensionProperties structures</th></tr>
<tr><th>VUID-vkEnumerateDeviceExtensionProperties-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumerateDeviceExtensionProperties</th><th>core</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkEnumerateDeviceExtensionProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkEnumerateDeviceExtensionProperties</th><th>core</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkEnumerateDeviceLayerProperties-pProperties-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumerateDeviceLayerProperties</th><th>core</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkLayerProperties structures</th></tr>
<tr><th>VUID-vkEnumerateDeviceLayerProperties-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumerateDeviceLayerProperties</th><th>core</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkEnumerateDeviceLayerProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkEnumerateDeviceLayerProperties</th><th>core</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkEnumerateInstanceExtensionProperties-pLayerName-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumerateInstanceExtensionProperties</th><th>core</th><th> If pLayerName is not NULL, pLayerName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-vkEnumerateInstanceExtensionProperties-pProperties-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumerateInstanceExtensionProperties</th><th>core</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkExtensionProperties structures</th></tr>
<tr><th>VUID-vkEnumerateInstanceExtensionProperties-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumerateInstanceExtensionProperties</th><th>core</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkEnumerateInstanceLayerProperties-pProperties-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumerateInstanceLayerProperties</th><th>core</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkLayerProperties structures</th></tr>
<tr><th>VUID-vkEnumerateInstanceLayerProperties-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumerateInstanceLayerProperties</th><th>core</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkEnumerateInstanceVersion-pApiVersion-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumerateInstanceVersion</th><th>(VK_VERSION_1_1)</th><th> pApiVersion must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkEnumeratePhysicalDeviceGroups-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkEnumeratePhysicalDeviceGroups</th><th>(VK_VERSION_1_1,VK_KHR_device_group_creation)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumeratePhysicalDeviceGroups</th><th>(VK_VERSION_1_1,VK_KHR_device_group_creation)</th><th> pPhysicalDeviceGroupCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkEnumeratePhysicalDeviceGroups</th><th>(VK_VERSION_1_1,VK_KHR_device_group_creation)</th><th> If the value referenced by pPhysicalDeviceGroupCount is not 0, and pPhysicalDeviceGroupProperties is not NULL, pPhysicalDeviceGroupProperties must be a valid pointer to an array of pPhysicalDeviceGroupCount VkPhysicalDeviceGroupProperties structures</th></tr>
<tr><th>VUID-vkEnumeratePhysicalDevices-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkEnumeratePhysicalDevices</th><th>core</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkEnumeratePhysicalDevices-pPhysicalDeviceCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkEnumeratePhysicalDevices</th><th>core</th><th> pPhysicalDeviceCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkEnumeratePhysicalDevices-pPhysicalDevices-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkEnumeratePhysicalDevices</th><th>core</th><th> If the value referenced by pPhysicalDeviceCount is not 0, and pPhysicalDevices is not NULL, pPhysicalDevices must be a valid pointer to an array of pPhysicalDeviceCount VkPhysicalDevice handles</th></tr>
<tr><th>VUID-vkFlushMappedMemoryRanges-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFlushMappedMemoryRanges</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkFlushMappedMemoryRanges-memoryRangeCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFlushMappedMemoryRanges</th><th>core</th><th> memoryRangeCount must be greater than 0</th></tr>
<tr><th>VUID-vkFlushMappedMemoryRanges-pMemoryRanges-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFlushMappedMemoryRanges</th><th>core</th><th> pMemoryRanges must be a valid pointer to an array of memoryRangeCount valid VkMappedMemoryRange structures</th></tr>
<tr><th>VUID-vkFreeCommandBuffers-commandBufferCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkFreeCommandBuffers</th><th>core</th><th> commandBufferCount must be greater than 0</th></tr>
<tr><th>VUID-vkFreeCommandBuffers-commandPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFreeCommandBuffers</th><th>core</th><th> commandPool must be a valid VkCommandPool handle</th></tr>
<tr><th>VUID-vkFreeCommandBuffers-commandPool-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFreeCommandBuffers</th><th>core</th><th> commandPool must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkFreeCommandBuffers-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFreeCommandBuffers</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkFreeCommandBuffers-pCommandBuffers-00047</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkFreeCommandBuffers</th><th>core</th><th> All elements of pCommandBuffers must not be in the pending state</th></tr>
<tr><th>VUID-vkFreeCommandBuffers-pCommandBuffers-00048</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkFreeCommandBuffers</th><th>core</th><th> pCommandBuffers must be a valid pointer to an array of commandBufferCount VkCommandBuffer handles, each element of which must either be a valid handle or NULL</th></tr>
<tr><th>VUID-vkFreeCommandBuffers-pCommandBuffers-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFreeCommandBuffers</th><th>core</th><th> Each element of pCommandBuffers that is a valid handle must have been created, allocated, or retrieved from commandPool</th></tr>
<tr><th>VUID-vkFreeDescriptorSets-descriptorPool-00312</th><th><span style="color:limegreen;">Y</span></th><th>FreeDescriptorFromOneShotPool</th><th>explicit</th><th>vkFreeDescriptorSets</th><th>core</th><th> descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT flag</th></tr>
<tr><th>VUID-vkFreeDescriptorSets-descriptorPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFreeDescriptorSets</th><th>core</th><th> descriptorPool must be a valid VkDescriptorPool handle</th></tr>
<tr><th>VUID-vkFreeDescriptorSets-descriptorPool-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFreeDescriptorSets</th><th>core</th><th> descriptorPool must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkFreeDescriptorSets</th><th>core</th><th> descriptorSetCount must be greater than 0</th></tr>
<tr><th>VUID-vkFreeDescriptorSets-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFreeDescriptorSets</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkFreeDescriptorSets-pDescriptorSets-00309</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkFreeDescriptorSets</th><th>core</th><th> All submitted commands that refer to any element of pDescriptorSets must have completed execution</th></tr>
<tr><th>VUID-vkFreeDescriptorSets-pDescriptorSets-00310</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkFreeDescriptorSets</th><th>core</th><th> pDescriptorSets must be a valid pointer to an array of descriptorSetCount VkDescriptorSet handles, each element of which must either be a valid handle or VK_NULL_HANDLE</th></tr>
<tr><th>VUID-vkFreeDescriptorSets-pDescriptorSets-00311</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkFreeDescriptorSets</th><th>core</th><th> Each valid handle in pDescriptorSets must have been allocated from descriptorPool</th></tr>
<tr><th>VUID-vkFreeDescriptorSets-pDescriptorSets-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFreeDescriptorSets</th><th>core</th><th> Each element of pDescriptorSets that is a valid handle must have been created, allocated, or retrieved from descriptorPool</th></tr>
<tr><th>VUID-vkFreeMemory-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFreeMemory</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkFreeMemory-memory-00677</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkFreeMemory</th><th>core</th><th> All submitted commands that refer to memory (via images or buffers) must have completed execution</th></tr>
<tr><th>VUID-vkFreeMemory-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>VertexBufferInvalid</th><th>implicit</th><th>vkFreeMemory</th><th>core</th><th> If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-vkFreeMemory-memory-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkFreeMemory</th><th>core</th><th> If memory is a valid handle, it must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkFreeMemory-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkFreeMemory</th><th>core</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkGetAccelerationStructureHandleNV-accelerationStructure-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAccelerationStructureHandleNV</th><th>(VK_NV_ray_tracing)</th><th> accelerationStructure must be a valid VkAccelerationStructureNV handle</th></tr>
<tr><th>VUID-vkGetAccelerationStructureHandleNV-accelerationStructure-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAccelerationStructureHandleNV</th><th>(VK_NV_ray_tracing)</th><th> accelerationStructure must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetAccelerationStructureHandleNV-dataSize-02240</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetAccelerationStructureHandleNV</th><th>(VK_NV_ray_tracing)</th><th> dataSize must be large enough to contain the result of the query, as described above</th></tr>
<tr><th>VUID-vkGetAccelerationStructureHandleNV-dataSize-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAccelerationStructureHandleNV</th><th>(VK_NV_ray_tracing)</th><th> dataSize must be greater than 0</th></tr>
<tr><th>VUID-vkGetAccelerationStructureHandleNV-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAccelerationStructureHandleNV</th><th>(VK_NV_ray_tracing)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetAccelerationStructureHandleNV-pData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAccelerationStructureHandleNV</th><th>(VK_NV_ray_tracing)</th><th> pData must be a valid pointer to an array of dataSize bytes</th></tr>
<tr><th>VUID-vkGetAccelerationStructureMemoryRequirementsNV-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAccelerationStructureMemoryRequirementsNV</th><th>(VK_NV_ray_tracing)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetAccelerationStructureMemoryRequirementsNV-pInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAccelerationStructureMemoryRequirementsNV</th><th>(VK_NV_ray_tracing)</th><th> pInfo must be a valid pointer to a valid VkAccelerationStructureMemoryRequirementsInfoNV structure</th></tr>
<tr><th>VUID-vkGetAccelerationStructureMemoryRequirementsNV-pMemoryRequirements-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAccelerationStructureMemoryRequirementsNV</th><th>(VK_NV_ray_tracing)</th><th> pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2KHR structure</th></tr>
<tr><th>VUID-vkGetAndroidHardwareBufferPropertiesANDROID-buffer-01884</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferMemoryAllocation</th><th>explicit</th><th>vkGetAndroidHardwareBufferPropertiesANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> buffer must be a valid Android hardware buffer object with at least one of the AHARDWAREBUFFER_USAGE_GPU_* flags in its AHardwareBuffer_Desc::usage</th></tr>
<tr><th>VUID-vkGetAndroidHardwareBufferPropertiesANDROID-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAndroidHardwareBufferPropertiesANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> buffer must be a valid pointer to a valid AHardwareBuffer value</th></tr>
<tr><th>VUID-vkGetAndroidHardwareBufferPropertiesANDROID-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAndroidHardwareBufferPropertiesANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetAndroidHardwareBufferPropertiesANDROID-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetAndroidHardwareBufferPropertiesANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> pProperties must be a valid pointer to a VkAndroidHardwareBufferPropertiesANDROID structure</th></tr>
<tr><th>VUID-vkGetBufferDeviceAddressEXT-None-02598</th><th><span style="color:limegreen;">Y</span></th><th>BufferDeviceAddressEXTDisabled</th><th>explicit</th><th>vkGetBufferDeviceAddressEXT</th><th>(VK_EXT_buffer_device_address)</th><th> The bufferDeviceAddress feature must be enabled</th></tr>
<tr><th>VUID-vkGetBufferDeviceAddressEXT-device-02599</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkGetBufferDeviceAddressEXT</th><th>(VK_EXT_buffer_device_address)</th><th> If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled</th></tr>
<tr><th>VUID-vkGetBufferDeviceAddressEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetBufferDeviceAddressEXT</th><th>(VK_EXT_buffer_device_address)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetBufferDeviceAddressEXT-pInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetBufferDeviceAddressEXT</th><th>(VK_EXT_buffer_device_address)</th><th> pInfo must be a valid pointer to a valid VkBufferDeviceAddressInfoEXT structure</th></tr>
<tr><th>VUID-vkGetBufferMemoryRequirements-buffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetBufferMemoryRequirements</th><th>core</th><th> buffer must be a valid VkBuffer handle</th></tr>
<tr><th>VUID-vkGetBufferMemoryRequirements-buffer-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetBufferMemoryRequirements</th><th>core</th><th> buffer must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetBufferMemoryRequirements-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetBufferMemoryRequirements</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetBufferMemoryRequirements-pMemoryRequirements-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetBufferMemoryRequirements</th><th>core</th><th> pMemoryRequirements must be a valid pointer to a VkMemoryRequirements structure</th></tr>
<tr><th>VUID-vkGetBufferMemoryRequirements2-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetBufferMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetBufferMemoryRequirements2-pInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetBufferMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pInfo must be a valid pointer to a valid VkBufferMemoryRequirementsInfo2 structure</th></tr>
<tr><th>VUID-vkGetBufferMemoryRequirements2-pMemoryRequirements-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetBufferMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure</th></tr>
<tr><th>VUID-vkGetCalibratedTimestampsEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetCalibratedTimestampsEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetCalibratedTimestampsEXT-pMaxDeviation-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetCalibratedTimestampsEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> pMaxDeviation must be a valid pointer to a uint64_t value</th></tr>
<tr><th>VUID-vkGetCalibratedTimestampsEXT-pTimestampInfos-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetCalibratedTimestampsEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> pTimestampInfos must be a valid pointer to an array of timestampCount valid VkCalibratedTimestampInfoEXT structures</th></tr>
<tr><th>VUID-vkGetCalibratedTimestampsEXT-pTimestamps-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetCalibratedTimestampsEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> pTimestamps must be a valid pointer to an array of timestampCount uint64_t values</th></tr>
<tr><th>VUID-vkGetCalibratedTimestampsEXT-timestampCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetCalibratedTimestampsEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> timestampCount must be greater than 0</th></tr>
<tr><th>VUID-vkGetDescriptorSetLayoutSupport-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDescriptorSetLayoutSupport</th><th>(VK_VERSION_1_1,VK_KHR_maintenance3)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDescriptorSetLayoutSupport</th><th>(VK_VERSION_1_1,VK_KHR_maintenance3)</th><th> pCreateInfo must be a valid pointer to a valid VkDescriptorSetLayoutCreateInfo structure</th></tr>
<tr><th>VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDescriptorSetLayoutSupport</th><th>(VK_VERSION_1_1,VK_KHR_maintenance3)</th><th> pSupport must be a valid pointer to a VkDescriptorSetLayoutSupport structure</th></tr>
<tr><th>VUID-vkGetDeviceGroupPeerMemoryFeatures-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupPeerMemoryFeatures</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetDeviceGroupPeerMemoryFeatures-heapIndex-00691</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetDeviceGroupPeerMemoryFeatures</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> heapIndex must be less than memoryHeapCount</th></tr>
<tr><th>VUID-vkGetDeviceGroupPeerMemoryFeatures-localDeviceIndex-00692</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetDeviceGroupPeerMemoryFeatures</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> localDeviceIndex must be a valid device index</th></tr>
<tr><th>VUID-vkGetDeviceGroupPeerMemoryFeatures-localDeviceIndex-00694</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetDeviceGroupPeerMemoryFeatures</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> localDeviceIndex must not equal remoteDeviceIndex</th></tr>
<tr><th>VUID-vkGetDeviceGroupPeerMemoryFeatures-pPeerMemoryFeatures-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupPeerMemoryFeatures</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> pPeerMemoryFeatures must be a valid pointer to a VkPeerMemoryFeatureFlags value</th></tr>
<tr><th>VUID-vkGetDeviceGroupPeerMemoryFeatures-remoteDeviceIndex-00693</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetDeviceGroupPeerMemoryFeatures</th><th>(VK_VERSION_1_1,VK_KHR_device_group)</th><th> remoteDeviceIndex must be a valid device index</th></tr>
<tr><th>VUID-vkGetDeviceGroupPresentCapabilitiesKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupPresentCapabilitiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetDeviceGroupPresentCapabilitiesKHR-pDeviceGroupPresentCapabilities-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupPresentCapabilitiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> pDeviceGroupPresentCapabilities must be a valid pointer to a VkDeviceGroupPresentCapabilitiesKHR structure</th></tr>
<tr><th>VUID-vkGetDeviceGroupSurfacePresentModes2EXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupSurfacePresentModes2EXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_EXT_full_screen_exclusive)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetDeviceGroupSurfacePresentModes2EXT-pModes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupSurfacePresentModes2EXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_EXT_full_screen_exclusive)</th><th> pModes must be a valid pointer to a VkDeviceGroupPresentModeFlagsKHR value</th></tr>
<tr><th>VUID-vkGetDeviceGroupSurfacePresentModes2EXT-pSurfaceInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupSurfacePresentModes2EXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_EXT_full_screen_exclusive)</th><th> pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure</th></tr>
<tr><th>VUID-vkGetDeviceGroupSurfacePresentModesKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupSurfacePresentModesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> Both of device, and surface must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetDeviceGroupSurfacePresentModesKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupSurfacePresentModesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetDeviceGroupSurfacePresentModesKHR-pModes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupSurfacePresentModesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> pModes must be a valid pointer to a VkDeviceGroupPresentModeFlagsKHR value</th></tr>
<tr><th>VUID-vkGetDeviceGroupSurfacePresentModesKHR-surface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceGroupSurfacePresentModesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> surface must be a valid VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkGetDeviceMemoryCommitment-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceMemoryCommitment</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetDeviceMemoryCommitment-memory-00690</th><th><span style="color:limegreen;">Y</span></th><th>QueryMemoryCommitmentWithoutLazyProperty</th><th>explicit</th><th>vkGetDeviceMemoryCommitment</th><th>core</th><th> memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</th></tr>
<tr><th>VUID-vkGetDeviceMemoryCommitment-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceMemoryCommitment</th><th>core</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-vkGetDeviceMemoryCommitment-memory-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceMemoryCommitment</th><th>core</th><th> memory must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetDeviceMemoryCommitment-pCommittedMemoryInBytes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceMemoryCommitment</th><th>core</th><th> pCommittedMemoryInBytes must be a valid pointer to a VkDeviceSize value</th></tr>
<tr><th>VUID-vkGetDeviceProcAddr-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceProcAddr</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetDeviceProcAddr-pName-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetDeviceProcAddr</th><th>core</th><th> pName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-vkGetDeviceQueue-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceQueue</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetDeviceQueue-flags-01841</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetDeviceQueue</th><th>core</th><th> VkDeviceQueueCreateInfo::flags must have been set to zero when device was created</th></tr>
<tr><th>VUID-vkGetDeviceQueue-pQueue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceQueue</th><th>core</th><th> pQueue must be a valid pointer to a VkQueue handle</th></tr>
<tr><th>VUID-vkGetDeviceQueue-queueFamilyIndex-00384</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkGetDeviceQueue</th><th>core</th><th> queueFamilyIndex must be one of the queue family indices specified when device was created, via the VkDeviceQueueCreateInfo structure</th></tr>
<tr><th>VUID-vkGetDeviceQueue-queueIndex-00385</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkGetDeviceQueue</th><th>core</th><th> queueIndex must be less than the number of queues created for the specified queue family index when device was created, via the queueCount member of the VkDeviceQueueCreateInfo structure</th></tr>
<tr><th>VUID-vkGetDeviceQueue2-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceQueue2</th><th>(VK_VERSION_1_1)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetDeviceQueue2-pQueue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceQueue2</th><th>(VK_VERSION_1_1)</th><th> pQueue must be a valid pointer to a VkQueue handle</th></tr>
<tr><th>VUID-vkGetDeviceQueue2-pQueueInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDeviceQueue2</th><th>(VK_VERSION_1_1)</th><th> pQueueInfo must be a valid pointer to a valid VkDeviceQueueInfo2 structure</th></tr>
<tr><th>VUID-vkGetDisplayModeProperties2KHR-display-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayModeProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> display must be a valid VkDisplayKHR handle</th></tr>
<tr><th>VUID-vkGetDisplayModeProperties2KHR-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayModeProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayModeProperties2KHR structures</th></tr>
<tr><th>VUID-vkGetDisplayModeProperties2KHR-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetDisplayModeProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetDisplayModeProperties2KHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayModeProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetDisplayModePropertiesKHR-display-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayModePropertiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> display must be a valid VkDisplayKHR handle</th></tr>
<tr><th>VUID-vkGetDisplayModePropertiesKHR-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayModePropertiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayModePropertiesKHR structures</th></tr>
<tr><th>VUID-vkGetDisplayModePropertiesKHR-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetDisplayModePropertiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetDisplayModePropertiesKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayModePropertiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetDisplayPlaneCapabilities2KHR-pCapabilities-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayPlaneCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> pCapabilities must be a valid pointer to a VkDisplayPlaneCapabilities2KHR structure</th></tr>
<tr><th>VUID-vkGetDisplayPlaneCapabilities2KHR-pDisplayPlaneInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayPlaneCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> pDisplayPlaneInfo must be a valid pointer to a valid VkDisplayPlaneInfo2KHR structure</th></tr>
<tr><th>VUID-vkGetDisplayPlaneCapabilities2KHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayPlaneCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetDisplayPlaneCapabilitiesKHR-mode-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayPlaneCapabilitiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> mode must be a valid VkDisplayModeKHR handle</th></tr>
<tr><th>VUID-vkGetDisplayPlaneCapabilitiesKHR-pCapabilities-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayPlaneCapabilitiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pCapabilities must be a valid pointer to a VkDisplayPlaneCapabilitiesKHR structure</th></tr>
<tr><th>VUID-vkGetDisplayPlaneCapabilitiesKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayPlaneCapabilitiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplayCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetDisplayPlaneSupportedDisplaysKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pDisplayCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplays-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayPlaneSupportedDisplaysKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> If the value referenced by pDisplayCount is not 0, and pDisplays is not NULL, pDisplays must be a valid pointer to an array of pDisplayCount VkDisplayKHR handles</th></tr>
<tr><th>VUID-vkGetDisplayPlaneSupportedDisplaysKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetDisplayPlaneSupportedDisplaysKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetDisplayPlaneSupportedDisplaysKHR-planeIndex-01249</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkGetDisplayPlaneSupportedDisplaysKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> planeIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR</th></tr>
<tr><th>VUID-vkGetEventStatus-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetEventStatus</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetEventStatus-event-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetEventStatus</th><th>core</th><th> event must be a valid VkEvent handle</th></tr>
<tr><th>VUID-vkGetEventStatus-event-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetEventStatus</th><th>core</th><th> event must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetFenceFdKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetFenceFdKHR</th><th>(VK_KHR_external_fence_fd)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetFenceFdKHR-pFd-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetFenceFdKHR</th><th>(VK_KHR_external_fence_fd)</th><th> pFd must be a valid pointer to a int value</th></tr>
<tr><th>VUID-vkGetFenceFdKHR-pGetFdInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetFenceFdKHR</th><th>(VK_KHR_external_fence_fd)</th><th> pGetFdInfo must be a valid pointer to a valid VkFenceGetFdInfoKHR structure</th></tr>
<tr><th>VUID-vkGetFenceStatus-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetFenceStatus</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetFenceStatus-fence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetFenceStatus</th><th>core</th><th> fence must be a valid VkFence handle</th></tr>
<tr><th>VUID-vkGetFenceStatus-fence-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetFenceStatus</th><th>core</th><th> fence must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetFenceWin32HandleKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetFenceWin32HandleKHR</th><th>(VK_KHR_external_fence_win32)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetFenceWin32HandleKHR-pGetWin32HandleInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetFenceWin32HandleKHR</th><th>(VK_KHR_external_fence_win32)</th><th> pGetWin32HandleInfo must be a valid pointer to a valid VkFenceGetWin32HandleInfoKHR structure</th></tr>
<tr><th>VUID-vkGetFenceWin32HandleKHR-pHandle-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetFenceWin32HandleKHR</th><th>(VK_KHR_external_fence_win32)</th><th> pHandle must be a valid pointer to a HANDLE value</th></tr>
<tr><th>VUID-vkGetImageDrmFormatModifierPropertiesEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageDrmFormatModifierPropertiesEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetImageDrmFormatModifierPropertiesEXT-image-02272</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetImageDrmFormatModifierPropertiesEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> image must have been created with tiling equal to VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT.</th></tr>
<tr><th>VUID-vkGetImageDrmFormatModifierPropertiesEXT-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageDrmFormatModifierPropertiesEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkGetImageDrmFormatModifierPropertiesEXT-image-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageDrmFormatModifierPropertiesEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> image must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetImageDrmFormatModifierPropertiesEXT-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageDrmFormatModifierPropertiesEXT</th><th>(VK_EXT_image_drm_format_modifier)</th><th> pProperties must be a valid pointer to a VkImageDrmFormatModifierPropertiesEXT structure</th></tr>
<tr><th>VUID-vkGetImageMemoryRequirements-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageMemoryRequirements</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetImageMemoryRequirements-image-01588</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetImageMemoryRequirements</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> image must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT flag set</th></tr>
<tr><th>VUID-vkGetImageMemoryRequirements-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>CreateUnknownObject</th><th>implicit</th><th>vkGetImageMemoryRequirements</th><th>core</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkGetImageMemoryRequirements-image-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageMemoryRequirements</th><th>core</th><th> image must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetImageMemoryRequirements-pMemoryRequirements-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageMemoryRequirements</th><th>core</th><th> pMemoryRequirements must be a valid pointer to a VkMemoryRequirements structure</th></tr>
<tr><th>VUID-vkGetImageMemoryRequirements2-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetImageMemoryRequirements2-pInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pInfo must be a valid pointer to a valid VkImageMemoryRequirementsInfo2 structure</th></tr>
<tr><th>VUID-vkGetImageMemoryRequirements2-pMemoryRequirements-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure</th></tr>
<tr><th>VUID-vkGetImageSparseMemoryRequirements-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSparseMemoryRequirements</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetImageSparseMemoryRequirements-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSparseMemoryRequirements</th><th>core</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkGetImageSparseMemoryRequirements-image-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSparseMemoryRequirements</th><th>core</th><th> image must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirementCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetImageSparseMemoryRequirements</th><th>core</th><th> pSparseMemoryRequirementCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSparseMemoryRequirements</th><th>core</th><th> If the value referenced by pSparseMemoryRequirementCount is not 0, and pSparseMemoryRequirements is not NULL, pSparseMemoryRequirements must be a valid pointer to an array of pSparseMemoryRequirementCount VkSparseImageMemoryRequirements structures</th></tr>
<tr><th>VUID-vkGetImageSparseMemoryRequirements2-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSparseMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetImageSparseMemoryRequirements2-pInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSparseMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pInfo must be a valid pointer to a valid VkImageSparseMemoryRequirementsInfo2 structure</th></tr>
<tr><th>VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirementCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetImageSparseMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> pSparseMemoryRequirementCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirements-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSparseMemoryRequirements2</th><th>(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)</th><th> If the value referenced by pSparseMemoryRequirementCount is not 0, and pSparseMemoryRequirements is not NULL, pSparseMemoryRequirements must be a valid pointer to an array of pSparseMemoryRequirementCount VkSparseImageMemoryRequirements2 structures</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-arrayLayer-01717</th><th><span style="color:limegreen;">Y</span></th><th>ExerciseGetImageSubresourceLayout</th><th>explicit</th><th>vkGetImageSubresourceLayout</th><th>core</th><th> The arrayLayer member of pSubresource must be less than the arrayLayers specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-aspectMask-00997</th><th><span style="color:limegreen;">Y</span></th><th>ExerciseGetImageSubresourceLayout</th><th>explicit</th><th>vkGetImageSubresourceLayout</th><th>core</th><th> The aspectMask member of pSubresource must only have a single bit set</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSubresourceLayout</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-format-01581</th><th><span style="color:limegreen;">Y</span></th><th>MultiplaneImageLayoutBadAspectFlags</th><th>explicit</th><th>vkGetImageSubresourceLayout</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the tiling of the image is VK_IMAGE_TILING_LINEAR and its format is a multi-planar format with two planes, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-format-01582</th><th><span style="color:limegreen;">Y</span></th><th>MultiplaneImageLayoutBadAspectFlags</th><th>explicit</th><th>vkGetImageSubresourceLayout</th><th>(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)</th><th> If the tiling of the image is VK_IMAGE_TILING_LINEAR and its format is a multi-planar format with three planes, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-image-00996</th><th><span style="color:limegreen;">Y</span></th><th>ExerciseGetImageSubresourceLayout</th><th>explicit</th><th>vkGetImageSubresourceLayout</th><th>!(VK_EXT_image_drm_format_modifier)</th><th> image must have been created with tiling equal to VK_IMAGE_TILING_LINEAR</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-image-01895</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferFetchUnboundImageInfo</th><th>explicit</th><th>vkGetImageSubresourceLayout</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If image was created with the VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then image must be bound to memory.</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-image-02270</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetImageSubresourceLayout</th><th>(VK_EXT_image_drm_format_modifier)</th><th> image must have been created with tiling equal to VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-image-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSubresourceLayout</th><th>core</th><th> image must be a valid VkImage handle</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-image-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSubresourceLayout</th><th>core</th><th> image must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-mipLevel-01716</th><th><span style="color:limegreen;">Y</span></th><th>ExerciseGetImageSubresourceLayout</th><th>explicit</th><th>vkGetImageSubresourceLayout</th><th>core</th><th> The mipLevel member of pSubresource must be less than the mipLevels specified in VkImageCreateInfo when image was created</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-pLayout-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSubresourceLayout</th><th>core</th><th> pLayout must be a valid pointer to a VkSubresourceLayout structure</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-pSubresource-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageSubresourceLayout</th><th>core</th><th> pSubresource must be a valid pointer to a valid VkImageSubresource structure</th></tr>
<tr><th>VUID-vkGetImageSubresourceLayout-tiling-02271</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetImageSubresourceLayout</th><th>(VK_EXT_image_drm_format_modifier)</th><th>  If the tiling of the image is  VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the aspectMask  member of pSubresource must be  VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT and the index i must  be less than the  drmFormatModifierPlaneCount  associated with the image's format and drmFormatModifier.</th></tr>
<tr><th>VUID-vkGetImageViewHandleNVX-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageViewHandleNVX</th><th>(VK_NVX_image_view_handle)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetImageViewHandleNVX-pInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetImageViewHandleNVX</th><th>(VK_NVX_image_view_handle)</th><th> pInfo must be a valid pointer to a valid VkImageViewHandleInfoNVX structure</th></tr>
<tr><th>VUID-vkGetInstanceProcAddr-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetInstanceProcAddr</th><th>core</th><th> If instance is not NULL, instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkGetInstanceProcAddr-pName-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetInstanceProcAddr</th><th>core</th><th> pName must be a null-terminated UTF-8 string</th></tr>
<tr><th>VUID-vkGetMemoryAndroidHardwareBufferANDROID-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryAndroidHardwareBufferANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetMemoryAndroidHardwareBufferANDROID-pBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryAndroidHardwareBufferANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> pBuffer must be a valid pointer to a valid pointer to a AHardwareBuffer value</th></tr>
<tr><th>VUID-vkGetMemoryAndroidHardwareBufferANDROID-pInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryAndroidHardwareBufferANDROID</th><th>(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> pInfo must be a valid pointer to a valid VkMemoryGetAndroidHardwareBufferInfoANDROID structure</th></tr>
<tr><th>VUID-vkGetMemoryFdKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryFdKHR</th><th>(VK_KHR_external_memory_fd)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetMemoryFdKHR-pFd-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryFdKHR</th><th>(VK_KHR_external_memory_fd)</th><th> pFd must be a valid pointer to a int value</th></tr>
<tr><th>VUID-vkGetMemoryFdKHR-pGetFdInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryFdKHR</th><th>(VK_KHR_external_memory_fd)</th><th> pGetFdInfo must be a valid pointer to a valid VkMemoryGetFdInfoKHR structure</th></tr>
<tr><th>VUID-vkGetMemoryFdPropertiesKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryFdPropertiesKHR</th><th>(VK_KHR_external_memory_fd)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetMemoryFdPropertiesKHR-fd-00673</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetMemoryFdPropertiesKHR</th><th>(VK_KHR_external_memory_fd)</th><th> fd must be an external memory handle created outside of the Vulkan API.</th></tr>
<tr><th>VUID-vkGetMemoryFdPropertiesKHR-handleType-00674</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetMemoryFdPropertiesKHR</th><th>(VK_KHR_external_memory_fd)</th><th> handleType must not be VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR.</th></tr>
<tr><th>VUID-vkGetMemoryFdPropertiesKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryFdPropertiesKHR</th><th>(VK_KHR_external_memory_fd)</th><th> handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</th></tr>
<tr><th>VUID-vkGetMemoryFdPropertiesKHR-pMemoryFdProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryFdPropertiesKHR</th><th>(VK_KHR_external_memory_fd)</th><th> pMemoryFdProperties must be a valid pointer to a VkMemoryFdPropertiesKHR structure</th></tr>
<tr><th>VUID-vkGetMemoryHostPointerPropertiesEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryHostPointerPropertiesEXT</th><th>(VK_EXT_external_memory_host)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-01752</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetMemoryHostPointerPropertiesEXT</th><th>(VK_EXT_external_memory_host)</th><th> handleType must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT</th></tr>
<tr><th>VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-01754</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetMemoryHostPointerPropertiesEXT</th><th>(VK_EXT_external_memory_host)</th><th> If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, pHostPointer must be a pointer to host memory</th></tr>
<tr><th>VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-01755</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetMemoryHostPointerPropertiesEXT</th><th>(VK_EXT_external_memory_host)</th><th> If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT, pHostPointer must be a pointer to host mapped foreign memory</th></tr>
<tr><th>VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryHostPointerPropertiesEXT</th><th>(VK_EXT_external_memory_host)</th><th> handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</th></tr>
<tr><th>VUID-vkGetMemoryHostPointerPropertiesEXT-pHostPointer-01753</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetMemoryHostPointerPropertiesEXT</th><th>(VK_EXT_external_memory_host)</th><th> pHostPointer must be a pointer aligned to an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment</th></tr>
<tr><th>VUID-vkGetMemoryHostPointerPropertiesEXT-pMemoryHostPointerProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryHostPointerPropertiesEXT</th><th>(VK_EXT_external_memory_host)</th><th> pMemoryHostPointerProperties must be a valid pointer to a VkMemoryHostPointerPropertiesEXT structure</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandleKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandleKHR</th><th>(VK_KHR_external_memory_win32)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandleKHR-pGetWin32HandleInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandleKHR</th><th>(VK_KHR_external_memory_win32)</th><th> pGetWin32HandleInfo must be a valid pointer to a valid VkMemoryGetWin32HandleInfoKHR structure</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandleKHR-pHandle-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandleKHR</th><th>(VK_KHR_external_memory_win32)</th><th> pHandle must be a valid pointer to a HANDLE value</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandleNV-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandleNV</th><th>(VK_NV_external_memory_win32)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandleNV-handleType-01326</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetMemoryWin32HandleNV</th><th>(VK_NV_external_memory_win32)</th><th> handleType must be a flag specified in VkExportMemoryAllocateInfoNV::handleTypes when allocating memory</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandleNV-handleType-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandleNV</th><th>(VK_NV_external_memory_win32)</th><th> handleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandleNV-handleType-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandleNV</th><th>(VK_NV_external_memory_win32)</th><th> handleType must not be 0</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandleNV-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandleNV</th><th>(VK_NV_external_memory_win32)</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandleNV-memory-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandleNV</th><th>(VK_NV_external_memory_win32)</th><th> memory must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandleNV-pHandle-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandleNV</th><th>(VK_NV_external_memory_win32)</th><th> pHandle must be a valid pointer to a HANDLE value</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandlePropertiesKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandlePropertiesKHR</th><th>(VK_KHR_external_memory_win32)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandlePropertiesKHR-handle-00665</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetMemoryWin32HandlePropertiesKHR</th><th>(VK_KHR_external_memory_win32)</th><th> handle must be an external memory handle created outside of the Vulkan API.</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-00666</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetMemoryWin32HandlePropertiesKHR</th><th>(VK_KHR_external_memory_win32)</th><th> handleType must not be one of the handle types defined as opaque.</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandlePropertiesKHR</th><th>(VK_KHR_external_memory_win32)</th><th> handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</th></tr>
<tr><th>VUID-vkGetMemoryWin32HandlePropertiesKHR-pMemoryWin32HandleProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetMemoryWin32HandlePropertiesKHR</th><th>(VK_KHR_external_memory_win32)</th><th> pMemoryWin32HandleProperties must be a valid pointer to a VkMemoryWin32HandlePropertiesKHR structure</th></tr>
<tr><th>VUID-vkGetPastPresentationTimingGOOGLE-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPastPresentationTimingGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetPastPresentationTimingGOOGLE-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPastPresentationTimingGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimingCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPastPresentationTimingGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> pPresentationTimingCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimings-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPastPresentationTimingGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> If the value referenced by pPresentationTimingCount is not 0, and pPresentationTimings is not NULL, pPresentationTimings must be a valid pointer to an array of pPresentationTimingCount VkPastPresentationTimingGOOGLE structures</th></tr>
<tr><th>VUID-vkGetPastPresentationTimingGOOGLE-swapchain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPastPresentationTimingGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsEXT-pTimeDomainCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceCalibrateableTimeDomainsEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> pTimeDomainCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsEXT-pTimeDomains-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceCalibrateableTimeDomainsEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> If the value referenced by pTimeDomainCount is not 0, and pTimeDomains is not NULL, pTimeDomains must be a valid pointer to an array of pTimeDomainCount VkTimeDomainEXT values</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsEXT-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceCalibrateableTimeDomainsEXT</th><th>(VK_EXT_calibrated_timestamps)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesNV-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkCooperativeMatrixPropertiesNV structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesNV-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesNV-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceCooperativeMatrixPropertiesNV</th><th>(VK_NV_cooperative_matrix)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayPlaneProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPlaneProperties2KHR structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayPlaneProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayPlaneProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPlanePropertiesKHR structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayProperties2KHR structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayProperties2KHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayProperties2KHR</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayPropertiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPropertiesKHR structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayPropertiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceDisplayPropertiesKHR</th><th>(VK_KHR_surface)+(VK_KHR_display)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalBufferProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> pExternalBufferInfo must be a valid pointer to a valid VkPhysicalDeviceExternalBufferInfo structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalBufferProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> pExternalBufferProperties must be a valid pointer to a VkExternalBufferProperties structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalBufferProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalBufferProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalFenceProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)</th><th> pExternalFenceInfo must be a valid pointer to a valid VkPhysicalDeviceExternalFenceInfo structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalFenceProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)</th><th> pExternalFenceProperties must be a valid pointer to a VkExternalFenceProperties structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalFenceProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalFenceProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-externalHandleType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</th><th>(VK_NV_external_memory_capabilities)</th><th> externalHandleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</th><th>(VK_NV_external_memory_capabilities)</th><th> flags must be a valid combination of VkImageCreateFlagBits values</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</th><th>(VK_NV_external_memory_capabilities)</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-pExternalImageFormatProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</th><th>(VK_NV_external_memory_capabilities)</th><th> pExternalImageFormatProperties must be a valid pointer to a VkExternalImageFormatPropertiesNV structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</th><th>(VK_NV_external_memory_capabilities)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-tiling-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</th><th>(VK_NV_external_memory_capabilities)</th><th> tiling must be a valid VkImageTiling value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-type-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</th><th>(VK_NV_external_memory_capabilities)</th><th> type must be a valid VkImageType value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</th><th>(VK_NV_external_memory_capabilities)</th><th> usage must be a valid combination of VkImageUsageFlagBits values</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</th><th>(VK_NV_external_memory_capabilities)</th><th> usage must not be 0</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalSemaphoreProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)</th><th> pExternalSemaphoreInfo must be a valid pointer to a valid VkPhysicalDeviceExternalSemaphoreInfo structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalSemaphoreProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)</th><th> pExternalSemaphoreProperties must be a valid pointer to a VkExternalSemaphoreProperties structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceExternalSemaphoreProperties</th><th>(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceFeatures-pFeatures-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceFeatures</th><th>core</th><th> pFeatures must be a valid pointer to a VkPhysicalDeviceFeatures structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceFeatures-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceFeatures</th><th>core</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceFeatures2-pFeatures-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceFeatures2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pFeatures must be a valid pointer to a VkPhysicalDeviceFeatures2 structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceFeatures2-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceFeatures2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceFormatProperties-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceFormatProperties</th><th>core</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceFormatProperties-pFormatProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceFormatProperties</th><th>core</th><th> pFormatProperties must be a valid pointer to a VkFormatProperties structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceFormatProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceFormatProperties</th><th>core</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceFormatProperties2-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceFormatProperties2-pFormatProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pFormatProperties must be a valid pointer to a VkFormatProperties2 structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceFormatProperties2-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX-pFeatures-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pFeatures must be a valid pointer to a VkDeviceGeneratedCommandsFeaturesNVX structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX-pLimits-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pLimits must be a valid pointer to a VkDeviceGeneratedCommandsLimitsNVX structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX</th><th>(VK_NVX_device_generated_commands)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties</th><th>core</th><th> flags must be a valid combination of VkImageCreateFlagBits values</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties</th><th>core</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties-pImageFormatProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties</th><th>core</th><th> pImageFormatProperties must be a valid pointer to a VkImageFormatProperties structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties</th><th>core</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-02248</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetPhysicalDeviceImageFormatProperties</th><th>(VK_EXT_image_drm_format_modifier)</th><th> tiling must not be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT. (Use vkGetPhysicalDeviceImageFormatProperties2 instead).</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties</th><th>core</th><th> tiling must be a valid VkImageTiling value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties-type-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties</th><th>core</th><th> type must be a valid VkImageType value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties-usage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties</th><th>core</th><th> usage must be a valid combination of VkImageUsageFlagBits values</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties-usage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties</th><th>core</th><th> usage must not be 0</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pImageFormatInfo must be a valid pointer to a valid VkPhysicalDeviceImageFormatInfo2 structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pImageFormatProperties must be a valid pointer to a VkImageFormatProperties2 structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties2-pNext-01868</th><th><span style="color:limegreen;">Y</span></th><th>AndroidHardwareBufferPhysDevImageFormatProp2</th><th>explicit</th><th>vkGetPhysicalDeviceImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_ANDROID_external_memory_android_hardware_buffer)</th><th> If the pNext chain of pImageFormatProperties contains an instance of VkAndroidHardwareBufferUsageANDROID, the pNext chain of pImageFormatInfo must contain an instance of VkPhysicalDeviceExternalImageFormatInfo with handleType set to VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID.</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceImageFormatProperties2-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceMemoryProperties-pMemoryProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceMemoryProperties</th><th>core</th><th> pMemoryProperties must be a valid pointer to a VkPhysicalDeviceMemoryProperties structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceMemoryProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceMemoryProperties</th><th>core</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceMemoryProperties2-pMemoryProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceMemoryProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pMemoryProperties must be a valid pointer to a VkPhysicalDeviceMemoryProperties2 structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceMemoryProperties2-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceMemoryProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-pMultisampleProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceMultisamplePropertiesEXT</th><th>(VK_EXT_sample_locations)</th><th> pMultisampleProperties must be a valid pointer to a VkMultisamplePropertiesEXT structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceMultisamplePropertiesEXT</th><th>(VK_EXT_sample_locations)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-samples-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceMultisamplePropertiesEXT</th><th>(VK_EXT_sample_locations)</th><th> samples must be a valid VkSampleCountFlagBits value</th></tr>
<tr><th>VUID-vkGetPhysicalDevicePresentRectanglesKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDevicePresentRectanglesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRectCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDevicePresentRectanglesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> pRectCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRects-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDevicePresentRectanglesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> If the value referenced by pRectCount is not 0, and pRects is not NULL, pRects must be a valid pointer to an array of pRectCount VkRect2D structures</th></tr>
<tr><th>VUID-vkGetPhysicalDevicePresentRectanglesKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDevicePresentRectanglesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDevicePresentRectanglesKHR-surface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDevicePresentRectanglesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)</th><th> surface must be a valid VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceProperties-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceProperties</th><th>core</th><th> pProperties must be a valid pointer to a VkPhysicalDeviceProperties structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceProperties</th><th>core</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceProperties2-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pProperties must be a valid pointer to a VkPhysicalDeviceProperties2 structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceProperties2-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceQueueFamilyProperties</th><th>core</th><th> If the value referenced by pQueueFamilyPropertyCount is not 0, and pQueueFamilyProperties is not NULL, pQueueFamilyProperties must be a valid pointer to an array of pQueueFamilyPropertyCount VkQueueFamilyProperties structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceQueueFamilyProperties</th><th>core</th><th> pQueueFamilyPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceQueueFamilyProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceQueueFamilyProperties</th><th>core</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceQueueFamilyProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> If the value referenced by pQueueFamilyPropertyCount is not 0, and pQueueFamilyProperties is not NULL, pQueueFamilyProperties must be a valid pointer to an array of pQueueFamilyPropertyCount VkQueueFamilyProperties2 structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceQueueFamilyProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pQueueFamilyPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceQueueFamilyProperties2-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceQueueFamilyProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties-format-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties</th><th>core</th><th> format must be a valid VkFormat value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties</th><th>core</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkSparseImageFormatProperties structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties</th><th>core</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties</th><th>core</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-01094</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties</th><th>core</th><th> samples must be a bit value that is set in VkImageFormatProperties::sampleCounts returned by vkGetPhysicalDeviceImageFormatProperties with format, type, tiling, and usage equal to those in this command and flags equal to the value that is set in VkImageCreateInfo::flags when the image is created</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties</th><th>core</th><th> samples must be a valid VkSampleCountFlagBits value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties-tiling-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties</th><th>core</th><th> tiling must be a valid VkImageTiling value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties-type-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties</th><th>core</th><th> type must be a valid VkImageType value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties</th><th>core</th><th> usage must be a valid combination of VkImageUsageFlagBits values</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties</th><th>core</th><th> usage must not be 0</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pFormatInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pFormatInfo must be a valid pointer to a valid VkPhysicalDeviceSparseImageFormatInfo2 structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkSparseImageFormatProperties2 structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pPropertyCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> pPropertyCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSparseImageFormatProperties2</th><th>(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilities2EXT</th><th>(VK_KHR_surface)+(VK_EXT_display_surface_counter)</th><th> Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-pSurfaceCapabilities-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilities2EXT</th><th>(VK_KHR_surface)+(VK_EXT_display_surface_counter)</th><th> pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilities2EXT structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilities2EXT</th><th>(VK_KHR_surface)+(VK_EXT_display_surface_counter)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-surface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilities2EXT</th><th>(VK_KHR_surface)+(VK_EXT_display_surface_counter)</th><th> surface must be a valid VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-02671</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetPhysicalDeviceSurfaceCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_EXT_full_screen_exclusive,VK_KHR_win32_surface)</th><th> If an instance of VkSurfaceCapabilitiesFullScreenExclusiveEXT is included in the pNext chain of pSurfaceCapabilities, an instance of VkSurfaceFullScreenExclusiveWin32InfoEXT must be included in the pNext chain of pSurfaceInfo.</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceCapabilities-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilities2KHR structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilities2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</th><th>(VK_KHR_surface)</th><th> Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-pSurfaceCapabilities-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</th><th>(VK_KHR_surface)</th><th> pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilitiesKHR structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</th><th>(VK_KHR_surface)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-surface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</th><th>(VK_KHR_surface)</th><th> surface must be a valid VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormatCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceFormats2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> pSurfaceFormatCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormats-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceFormats2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> If the value referenced by pSurfaceFormatCount is not 0, and pSurfaceFormats is not NULL, pSurfaceFormats must be a valid pointer to an array of pSurfaceFormatCount VkSurfaceFormat2KHR structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceFormats2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceFormats2KHR</th><th>(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceFormatsKHR</th><th>(VK_KHR_surface)</th><th> Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormatCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceFormatsKHR</th><th>(VK_KHR_surface)</th><th> pSurfaceFormatCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormats-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceFormatsKHR</th><th>(VK_KHR_surface)</th><th> If the value referenced by pSurfaceFormatCount is not 0, and pSurfaceFormats is not NULL, pSurfaceFormats must be a valid pointer to an array of pSurfaceFormatCount VkSurfaceFormatKHR structures</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceFormatsKHR</th><th>(VK_KHR_surface)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-surface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceFormatsKHR</th><th>(VK_KHR_surface)</th><th> surface must be a valid VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pPresentModeCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfacePresentModes2EXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> pPresentModeCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pPresentModes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfacePresentModes2EXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> If the value referenced by pPresentModeCount is not 0, and pPresentModes is not NULL, pPresentModes must be a valid pointer to an array of pPresentModeCount VkPresentModeKHR values</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfacePresentModes2EXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfacePresentModes2EXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfacePresentModesKHR</th><th>(VK_KHR_surface)</th><th> Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModeCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfacePresentModesKHR</th><th>(VK_KHR_surface)</th><th> pPresentModeCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModes-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfacePresentModesKHR</th><th>(VK_KHR_surface)</th><th> If the value referenced by pPresentModeCount is not 0, and pPresentModes is not NULL, pPresentModes must be a valid pointer to an array of pPresentModeCount VkPresentModeKHR values</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfacePresentModesKHR</th><th>(VK_KHR_surface)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-surface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfacePresentModesKHR</th><th>(VK_KHR_surface)</th><th> surface must be a valid VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceSupportKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceSupportKHR</th><th>(VK_KHR_surface)</th><th> Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceSupportKHR-pSupported-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceSupportKHR</th><th>(VK_KHR_surface)</th><th> pSupported must be a valid pointer to a VkBool32 value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceSupportKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceSupportKHR</th><th>(VK_KHR_surface)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceSupportKHR-queueFamilyIndex-01269</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkGetPhysicalDeviceSurfaceSupportKHR</th><th>(VK_KHR_surface)</th><th> queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceSurfaceSupportKHR-surface-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceSurfaceSupportKHR</th><th>(VK_KHR_surface)</th><th> surface must be a valid VkSurfaceKHR handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-display-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceWaylandPresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> display must be a valid pointer to a wl_display value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceWaylandPresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-queueFamilyIndex-01306</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkGetPhysicalDeviceWaylandPresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_wayland_surface)</th><th> queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceWin32PresentationSupportKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceWin32PresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceWin32PresentationSupportKHR-queueFamilyIndex-01309</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkGetPhysicalDeviceWin32PresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_win32_surface)</th><th> queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-connection-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceXcbPresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> connection must be a valid pointer to a xcb_connection_t value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceXcbPresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-queueFamilyIndex-01312</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkGetPhysicalDeviceXcbPresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_xcb_surface)</th><th> queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-dpy-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceXlibPresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> dpy must be a valid pointer to a Display value</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPhysicalDeviceXlibPresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-queueFamilyIndex-01315</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkGetPhysicalDeviceXlibPresentationSupportKHR</th><th>(VK_KHR_surface)+(VK_KHR_xlib_surface)</th><th> queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice</th></tr>
<tr><th>VUID-vkGetPipelineCacheData-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPipelineCacheData</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetPipelineCacheData-pData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPipelineCacheData</th><th>core</th><th> If the value referenced by pDataSize is not 0, and pData is not NULL, pData must be a valid pointer to an array of pDataSize bytes</th></tr>
<tr><th>VUID-vkGetPipelineCacheData-pDataSize-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetPipelineCacheData</th><th>core</th><th> pDataSize must be a valid pointer to a size_t value</th></tr>
<tr><th>VUID-vkGetPipelineCacheData-pipelineCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPipelineCacheData</th><th>core</th><th> pipelineCache must be a valid VkPipelineCache handle</th></tr>
<tr><th>VUID-vkGetPipelineCacheData-pipelineCache-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetPipelineCacheData</th><th>core</th><th> pipelineCache must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-dataSize-00817</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> dataSize must be large enough to contain the result of each query, as described here</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-dataSize-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> dataSize must be greater than 0</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-firstQuery-00813</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> firstQuery must be less than the number of queries in queryPool</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-firstQuery-00816</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-flags-00814</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> If VK_QUERY_RESULT_64_BIT is not set in flags then pData and stride must be multiples of 4</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-flags-00815</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> If VK_QUERY_RESULT_64_BIT is set in flags then pData and stride must be multiples of 8</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> flags must be a valid combination of VkQueryResultFlagBits values</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-pData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> pData must be a valid pointer to an array of dataSize bytes</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-queryPool-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> queryPool must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetQueryPoolResults-queryType-00818</th><th><span style="color:limegreen;">Y</span></th><th>QueryPoolInUseDestroyedSignaled</th><th>explicit</th><th>vkGetQueryPoolResults</th><th>core</th><th> If the queryType used to create queryPool was VK_QUERY_TYPE_TIMESTAMP, flags must not contain VK_QUERY_RESULT_PARTIAL_BIT</th></tr>
<tr><th>VUID-vkGetQueueCheckpointDataNV-pCheckpointData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetQueueCheckpointDataNV</th><th>(VK_NV_device_diagnostic_checkpoints)</th><th> If the value referenced by pCheckpointDataCount is not 0, and pCheckpointData is not NULL, pCheckpointData must be a valid pointer to an array of pCheckpointDataCount VkCheckpointDataNV structures</th></tr>
<tr><th>VUID-vkGetQueueCheckpointDataNV-pCheckpointDataCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetQueueCheckpointDataNV</th><th>(VK_NV_device_diagnostic_checkpoints)</th><th> pCheckpointDataCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetQueueCheckpointDataNV-queue-02025</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetQueueCheckpointDataNV</th><th>(VK_NV_device_diagnostic_checkpoints)</th><th> The device that queue belongs to must be in the lost state</th></tr>
<tr><th>VUID-vkGetQueueCheckpointDataNV-queue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetQueueCheckpointDataNV</th><th>(VK_NV_device_diagnostic_checkpoints)</th><th> queue must be a valid VkQueue handle</th></tr>
<tr><th>VUID-vkGetRandROutputDisplayEXT-dpy-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRandROutputDisplayEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display)</th><th> dpy must be a valid pointer to a Display value</th></tr>
<tr><th>VUID-vkGetRandROutputDisplayEXT-pDisplay-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRandROutputDisplayEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display)</th><th> pDisplay must be a valid pointer to a VkDisplayKHR handle</th></tr>
<tr><th>VUID-vkGetRandROutputDisplayEXT-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRandROutputDisplayEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkGetRayTracingShaderGroupHandlesNV-dataSize-02420</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetRayTracingShaderGroupHandlesNV</th><th>(VK_NV_ray_tracing)</th><th> dataSize must be at least VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize {times} groupCount</th></tr>
<tr><th>VUID-vkGetRayTracingShaderGroupHandlesNV-dataSize-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRayTracingShaderGroupHandlesNV</th><th>(VK_NV_ray_tracing)</th><th> dataSize must be greater than 0</th></tr>
<tr><th>VUID-vkGetRayTracingShaderGroupHandlesNV-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRayTracingShaderGroupHandlesNV</th><th>(VK_NV_ray_tracing)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetRayTracingShaderGroupHandlesNV-firstGroup-02419</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetRayTracingShaderGroupHandlesNV</th><th>(VK_NV_ray_tracing)</th><th> The sum of firstGroup and groupCount must be less than the number of shader groups in pipeline.</th></tr>
<tr><th>VUID-vkGetRayTracingShaderGroupHandlesNV-pData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRayTracingShaderGroupHandlesNV</th><th>(VK_NV_ray_tracing)</th><th> pData must be a valid pointer to an array of dataSize bytes</th></tr>
<tr><th>VUID-vkGetRayTracingShaderGroupHandlesNV-pipeline-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRayTracingShaderGroupHandlesNV</th><th>(VK_NV_ray_tracing)</th><th> pipeline must be a valid VkPipeline handle</th></tr>
<tr><th>VUID-vkGetRayTracingShaderGroupHandlesNV-pipeline-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRayTracingShaderGroupHandlesNV</th><th>(VK_NV_ray_tracing)</th><th> pipeline must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetRefreshCycleDurationGOOGLE-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRefreshCycleDurationGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetRefreshCycleDurationGOOGLE-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRefreshCycleDurationGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetRefreshCycleDurationGOOGLE-pDisplayTimingProperties-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRefreshCycleDurationGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> pDisplayTimingProperties must be a valid pointer to a VkRefreshCycleDurationGOOGLE structure</th></tr>
<tr><th>VUID-vkGetRefreshCycleDurationGOOGLE-swapchain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRefreshCycleDurationGOOGLE</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)</th><th> swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-vkGetRenderAreaGranularity-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRenderAreaGranularity</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetRenderAreaGranularity-pGranularity-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRenderAreaGranularity</th><th>core</th><th> pGranularity must be a valid pointer to a VkExtent2D structure</th></tr>
<tr><th>VUID-vkGetRenderAreaGranularity-renderPass-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRenderAreaGranularity</th><th>core</th><th> renderPass must be a valid VkRenderPass handle</th></tr>
<tr><th>VUID-vkGetRenderAreaGranularity-renderPass-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetRenderAreaGranularity</th><th>core</th><th> renderPass must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetSemaphoreFdKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSemaphoreFdKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetSemaphoreFdKHR-pFd-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSemaphoreFdKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> pFd must be a valid pointer to a int value</th></tr>
<tr><th>VUID-vkGetSemaphoreFdKHR-pGetFdInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSemaphoreFdKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> pGetFdInfo must be a valid pointer to a valid VkSemaphoreGetFdInfoKHR structure</th></tr>
<tr><th>VUID-vkGetSemaphoreWin32HandleKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSemaphoreWin32HandleKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetSemaphoreWin32HandleKHR-pGetWin32HandleInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSemaphoreWin32HandleKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> pGetWin32HandleInfo must be a valid pointer to a valid VkSemaphoreGetWin32HandleInfoKHR structure</th></tr>
<tr><th>VUID-vkGetSemaphoreWin32HandleKHR-pHandle-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSemaphoreWin32HandleKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> pHandle must be a valid pointer to a HANDLE value</th></tr>
<tr><th>VUID-vkGetShaderInfoAMD-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetShaderInfoAMD</th><th>(VK_AMD_shader_info)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetShaderInfoAMD-infoType-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetShaderInfoAMD</th><th>(VK_AMD_shader_info)</th><th> infoType must be a valid VkShaderInfoTypeAMD value</th></tr>
<tr><th>VUID-vkGetShaderInfoAMD-pInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetShaderInfoAMD</th><th>(VK_AMD_shader_info)</th><th> If the value referenced by pInfoSize is not 0, and pInfo is not NULL, pInfo must be a valid pointer to an array of pInfoSize bytes</th></tr>
<tr><th>VUID-vkGetShaderInfoAMD-pInfoSize-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetShaderInfoAMD</th><th>(VK_AMD_shader_info)</th><th> pInfoSize must be a valid pointer to a size_t value</th></tr>
<tr><th>VUID-vkGetShaderInfoAMD-pipeline-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetShaderInfoAMD</th><th>(VK_AMD_shader_info)</th><th> pipeline must be a valid VkPipeline handle</th></tr>
<tr><th>VUID-vkGetShaderInfoAMD-pipeline-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetShaderInfoAMD</th><th>(VK_AMD_shader_info)</th><th> pipeline must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkGetShaderInfoAMD-shaderStage-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetShaderInfoAMD</th><th>(VK_AMD_shader_info)</th><th> shaderStage must be a valid VkShaderStageFlagBits value</th></tr>
<tr><th>VUID-vkGetSwapchainCounterEXT-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainCounterEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)</th><th> Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetSwapchainCounterEXT-counter-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainCounterEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)</th><th> counter must be a valid VkSurfaceCounterFlagBitsEXT value</th></tr>
<tr><th>VUID-vkGetSwapchainCounterEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainCounterEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetSwapchainCounterEXT-pCounterValue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainCounterEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)</th><th> pCounterValue must be a valid pointer to a uint64_t value</th></tr>
<tr><th>VUID-vkGetSwapchainCounterEXT-swapchain-01245</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkGetSwapchainCounterEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)</th><th> One or more present commands on swapchain must have been processed by the presentation engine.</th></tr>
<tr><th>VUID-vkGetSwapchainCounterEXT-swapchain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainCounterEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)</th><th> swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-vkGetSwapchainImagesKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainImagesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetSwapchainImagesKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainImagesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetSwapchainImagesKHR-pSwapchainImageCount-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainImagesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> pSwapchainImageCount must be a valid pointer to a uint32_t value</th></tr>
<tr><th>VUID-vkGetSwapchainImagesKHR-pSwapchainImages-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainImagesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> If the value referenced by pSwapchainImageCount is not 0, and pSwapchainImages is not NULL, pSwapchainImages must be a valid pointer to an array of pSwapchainImageCount VkImage handles</th></tr>
<tr><th>VUID-vkGetSwapchainImagesKHR-swapchain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainImagesKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-vkGetSwapchainStatusKHR-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainStatusKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)</th><th> Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkGetSwapchainStatusKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainStatusKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetSwapchainStatusKHR-swapchain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetSwapchainStatusKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)</th><th> swapchain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-vkGetValidationCacheDataEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetValidationCacheDataEXT</th><th>(VK_EXT_validation_cache)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkGetValidationCacheDataEXT-pData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetValidationCacheDataEXT</th><th>(VK_EXT_validation_cache)</th><th> If the value referenced by pDataSize is not 0, and pData is not NULL, pData must be a valid pointer to an array of pDataSize bytes</th></tr>
<tr><th>VUID-vkGetValidationCacheDataEXT-pDataSize-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkGetValidationCacheDataEXT</th><th>(VK_EXT_validation_cache)</th><th> pDataSize must be a valid pointer to a size_t value</th></tr>
<tr><th>VUID-vkGetValidationCacheDataEXT-validationCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetValidationCacheDataEXT</th><th>(VK_EXT_validation_cache)</th><th> validationCache must be a valid VkValidationCacheEXT handle</th></tr>
<tr><th>VUID-vkGetValidationCacheDataEXT-validationCache-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkGetValidationCacheDataEXT</th><th>(VK_EXT_validation_cache)</th><th> validationCache must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkImportFenceFdKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkImportFenceFdKHR</th><th>(VK_KHR_external_fence_fd)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkImportFenceFdKHR-fence-01463</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkImportFenceFdKHR</th><th>(VK_KHR_external_fence_fd)</th><th> fence must not be associated with any queue command that has not yet completed execution on that queue</th></tr>
<tr><th>VUID-vkImportFenceFdKHR-pImportFenceFdInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkImportFenceFdKHR</th><th>(VK_KHR_external_fence_fd)</th><th> pImportFenceFdInfo must be a valid pointer to a valid VkImportFenceFdInfoKHR structure</th></tr>
<tr><th>VUID-vkImportFenceWin32HandleKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkImportFenceWin32HandleKHR</th><th>(VK_KHR_external_fence_win32)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkImportFenceWin32HandleKHR-pImportFenceWin32HandleInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkImportFenceWin32HandleKHR</th><th>(VK_KHR_external_fence_win32)</th><th> pImportFenceWin32HandleInfo must be a valid pointer to a valid VkImportFenceWin32HandleInfoKHR structure</th></tr>
<tr><th>VUID-vkImportSemaphoreFdKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkImportSemaphoreFdKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkImportSemaphoreFdKHR-pImportSemaphoreFdInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkImportSemaphoreFdKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> pImportSemaphoreFdInfo must be a valid pointer to a valid VkImportSemaphoreFdInfoKHR structure</th></tr>
<tr><th>VUID-vkImportSemaphoreFdKHR-semaphore-01142</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkImportSemaphoreFdKHR</th><th>(VK_KHR_external_semaphore_fd)</th><th> semaphore must not be associated with any queue command that has not yet completed execution on that queue</th></tr>
<tr><th>VUID-vkImportSemaphoreWin32HandleKHR-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkImportSemaphoreWin32HandleKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkImportSemaphoreWin32HandleKHR-pImportSemaphoreWin32HandleInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkImportSemaphoreWin32HandleKHR</th><th>(VK_KHR_external_semaphore_win32)</th><th> pImportSemaphoreWin32HandleInfo must be a valid pointer to a valid VkImportSemaphoreWin32HandleInfoKHR structure</th></tr>
<tr><th>VUID-vkInvalidateMappedMemoryRanges-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkInvalidateMappedMemoryRanges</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkInvalidateMappedMemoryRanges-memoryRangeCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkInvalidateMappedMemoryRanges</th><th>core</th><th> memoryRangeCount must be greater than 0</th></tr>
<tr><th>VUID-vkInvalidateMappedMemoryRanges-pMemoryRanges-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkInvalidateMappedMemoryRanges</th><th>core</th><th> pMemoryRanges must be a valid pointer to an array of memoryRangeCount valid VkMappedMemoryRange structures</th></tr>
<tr><th>VUID-vkMapMemory-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMapMemory</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkMapMemory-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMapMemory</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-vkMapMemory-memory-00678</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkMapMemory</th><th>core</th><th> memory must not be currently host mapped</th></tr>
<tr><th>VUID-vkMapMemory-memory-00682</th><th><span style="color:limegreen;">Y</span></th><th>MapMemWithoutHostVisibleBit</th><th>explicit</th><th>vkMapMemory</th><th>core</th><th> memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</th></tr>
<tr><th>VUID-vkMapMemory-memory-00683</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkMapMemory</th><th>(VK_KHR_device_group)</th><th> memory must not have been allocated with multiple instances.</th></tr>
<tr><th>VUID-vkMapMemory-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMapMemory</th><th>core</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-vkMapMemory-memory-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMapMemory</th><th>core</th><th> memory must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkMapMemory-offset-00679</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkMapMemory</th><th>core</th><th> offset must be less than the size of memory</th></tr>
<tr><th>VUID-vkMapMemory-ppData-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkMapMemory</th><th>core</th><th> ppData must be a valid pointer to a pointer value</th></tr>
<tr><th>VUID-vkMapMemory-size-00680</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkMapMemory</th><th>core</th><th> If size is not equal to VK_WHOLE_SIZE, size must be greater than 0</th></tr>
<tr><th>VUID-vkMapMemory-size-00681</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkMapMemory</th><th>core</th><th> If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to the size of the memory minus offset</th></tr>
<tr><th>VUID-vkMergePipelineCaches-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMergePipelineCaches</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkMergePipelineCaches-dstCache-00770</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkMergePipelineCaches</th><th>core</th><th> dstCache must not appear in the list of source caches</th></tr>
<tr><th>VUID-vkMergePipelineCaches-dstCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMergePipelineCaches</th><th>core</th><th> dstCache must be a valid VkPipelineCache handle</th></tr>
<tr><th>VUID-vkMergePipelineCaches-dstCache-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMergePipelineCaches</th><th>core</th><th> dstCache must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkMergePipelineCaches-pSrcCaches-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMergePipelineCaches</th><th>core</th><th> pSrcCaches must be a valid pointer to an array of srcCacheCount valid VkPipelineCache handles</th></tr>
<tr><th>VUID-vkMergePipelineCaches-pSrcCaches-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMergePipelineCaches</th><th>core</th><th> Each element of pSrcCaches must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkMergePipelineCaches-srcCacheCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkMergePipelineCaches</th><th>core</th><th> srcCacheCount must be greater than 0</th></tr>
<tr><th>VUID-vkMergeValidationCachesEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMergeValidationCachesEXT</th><th>(VK_EXT_validation_cache)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkMergeValidationCachesEXT-dstCache-01536</th><th><span style="color:limegreen;">Y</span></th><th>ValidationCacheTestBadMerge</th><th>explicit</th><th>vkMergeValidationCachesEXT</th><th>(VK_EXT_validation_cache)</th><th> dstCache must not appear in the list of source caches</th></tr>
<tr><th>VUID-vkMergeValidationCachesEXT-dstCache-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMergeValidationCachesEXT</th><th>(VK_EXT_validation_cache)</th><th> dstCache must be a valid VkValidationCacheEXT handle</th></tr>
<tr><th>VUID-vkMergeValidationCachesEXT-dstCache-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMergeValidationCachesEXT</th><th>(VK_EXT_validation_cache)</th><th> dstCache must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkMergeValidationCachesEXT-pSrcCaches-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMergeValidationCachesEXT</th><th>(VK_EXT_validation_cache)</th><th> pSrcCaches must be a valid pointer to an array of srcCacheCount valid VkValidationCacheEXT handles</th></tr>
<tr><th>VUID-vkMergeValidationCachesEXT-pSrcCaches-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkMergeValidationCachesEXT</th><th>(VK_EXT_validation_cache)</th><th> Each element of pSrcCaches must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkMergeValidationCachesEXT-srcCacheCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkMergeValidationCachesEXT</th><th>(VK_EXT_validation_cache)</th><th> srcCacheCount must be greater than 0</th></tr>
<tr><th>VUID-vkQueueBeginDebugUtilsLabelEXT-pLabelInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueBeginDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure</th></tr>
<tr><th>VUID-vkQueueBeginDebugUtilsLabelEXT-queue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueBeginDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> queue must be a valid VkQueue handle</th></tr>
<tr><th>VUID-vkQueueBindSparse-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueBindSparse</th><th>core</th><th> Both of fence, and queue that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkQueueBindSparse-fence-01113</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueBindSparse</th><th>core</th><th> If fence is not VK_NULL_HANDLE, fence must be unsignaled</th></tr>
<tr><th>VUID-vkQueueBindSparse-fence-01114</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueBindSparse</th><th>core</th><th> If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue</th></tr>
<tr><th>VUID-vkQueueBindSparse-fence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueBindSparse</th><th>core</th><th> If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle</th></tr>
<tr><th>VUID-vkQueueBindSparse-pBindInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueBindSparse</th><th>core</th><th> If bindInfoCount is not 0, pBindInfo must be a valid pointer to an array of bindInfoCount valid VkBindSparseInfo structures</th></tr>
<tr><th>VUID-vkQueueBindSparse-pSignalSemaphores-01115</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueBindSparse</th><th>core</th><th> Each element of the pSignalSemaphores member of each element of pBindInfo must be unsignaled when the semaphore signal operation it defines is executed on the device</th></tr>
<tr><th>VUID-vkQueueBindSparse-pWaitSemaphores-01116</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueBindSparse</th><th>core</th><th> When a semaphore unsignal operation defined by any element of the pWaitSemaphores member of any element of pBindInfo executes on queue, no other queue must be waiting on the same semaphore.</th></tr>
<tr><th>VUID-vkQueueBindSparse-pWaitSemaphores-01117</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueBindSparse</th><th>core</th><th> All elements of the pWaitSemaphores member of all elements of pBindInfo must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution.</th></tr>
<tr><th>VUID-vkQueueBindSparse-queue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueBindSparse</th><th>core</th><th> queue must be a valid VkQueue handle</th></tr>
<tr><th>VUID-vkQueueBindSparse-queuetype</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueBindSparse</th><th>core</th><th> The queue must support sparse binding operations</th></tr>
<tr><th>VUID-vkQueueEndDebugUtilsLabelEXT-None-01911</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueEndDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> There must be an outstanding vkQueueBeginDebugUtilsLabelEXT command prior to the vkQueueEndDebugUtilsLabelEXT on the queue</th></tr>
<tr><th>VUID-vkQueueEndDebugUtilsLabelEXT-queue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueEndDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> queue must be a valid VkQueue handle</th></tr>
<tr><th>VUID-vkQueueInsertDebugUtilsLabelEXT-pLabelInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueInsertDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure</th></tr>
<tr><th>VUID-vkQueueInsertDebugUtilsLabelEXT-queue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueInsertDebugUtilsLabelEXT</th><th>(VK_EXT_debug_utils)</th><th> queue must be a valid VkQueue handle</th></tr>
<tr><th>VUID-vkQueuePresentKHR-pPresentInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueuePresentKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> pPresentInfo must be a valid pointer to a valid VkPresentInfoKHR structure</th></tr>
<tr><th>VUID-vkQueuePresentKHR-pSwapchains-01292</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkQueuePresentKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> Each element of pSwapchains member of pPresentInfo must be a swapchain that is created for a surface for which presentation is supported from queue as determined using a call to vkGetPhysicalDeviceSurfaceSupportKHR</th></tr>
<tr><th>VUID-vkQueuePresentKHR-pSwapchains-01293</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueuePresentKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)</th><th> If more than one member of pSwapchains was created from a display surface, all display surfaces referenced that refer to the same display must use the same display mode</th></tr>
<tr><th>VUID-vkQueuePresentKHR-pWaitSemaphores-01294</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueuePresentKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> When a semaphore unsignal operation defined by the elements of the pWaitSemaphores member of pPresentInfo executes on queue, no other queue must be waiting on the same semaphore.</th></tr>
<tr><th>VUID-vkQueuePresentKHR-pWaitSemaphores-01295</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueuePresentKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> All elements of the pWaitSemaphores member of pPresentInfo must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution.</th></tr>
<tr><th>VUID-vkQueuePresentKHR-queue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueuePresentKHR</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)</th><th> queue must be a valid VkQueue handle</th></tr>
<tr><th>VUID-vkQueueSubmit-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueSubmit</th><th>core</th><th> Both of fence, and queue that are valid handles must have been created, allocated, or retrieved from the same VkDevice</th></tr>
<tr><th>VUID-vkQueueSubmit-fence-00063</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> If fence is not VK_NULL_HANDLE, fence must be unsignaled</th></tr>
<tr><th>VUID-vkQueueSubmit-fence-00064</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue</th></tr>
<tr><th>VUID-vkQueueSubmit-fence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueSubmit</th><th>core</th><th> If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle</th></tr>
<tr><th>VUID-vkQueueSubmit-pCommandBuffers-00065</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> Any calls to vkCmdSetEvent, vkCmdResetEvent or vkCmdWaitEvents that have been recorded into any of the command buffer elements of the pCommandBuffers member of any element of pSubmits, must not reference any VkEvent that is referenced by any of those commands in a command buffer that has been submitted to another queue and is still in the pending state.</th></tr>
<tr><th>VUID-vkQueueSubmit-pCommandBuffers-00070</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state.</th></tr>
<tr><th>VUID-vkQueueSubmit-pCommandBuffers-00071</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> If any element of the pCommandBuffers member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state.</th></tr>
<tr><th>VUID-vkQueueSubmit-pCommandBuffers-00072</th><th><span style="color:limegreen;">Y</span></th><th>ExecuteUnrecordedPrimaryCB</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> Any secondary command buffers recorded into any element of the pCommandBuffers member of any element of pSubmits must be in the pending or executable state.</th></tr>
<tr><th>VUID-vkQueueSubmit-pCommandBuffers-00073</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> If any secondary command buffers recorded into any element of the pCommandBuffers member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state.</th></tr>
<tr><th>VUID-vkQueueSubmit-pCommandBuffers-00074</th><th><span style="color:limegreen;">Y</span></th><th>MismatchedQueueFamiliesOnSubmit</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> Each element of the pCommandBuffers member of each element of pSubmits must have been allocated from a VkCommandPool that was created for the same queue family queue belongs to.</th></tr>
<tr><th>VUID-vkQueueSubmit-pSignalSemaphores-00067</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> Each element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device</th></tr>
<tr><th>VUID-vkQueueSubmit-pSubmits-02207</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> If any element of pSubmits->pCommandBuffers includes a Queue Family Transfer Acquire Operation, there must exist a previously submitted Queue Family Transfer Release Operation on a queue in the queue family identified by the acquire operation, with parameters matching the acquire operation as defined in the definition of such acquire operations, and which happens before the acquire operation.</th></tr>
<tr><th>VUID-vkQueueSubmit-pSubmits-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueSubmit</th><th>core</th><th> If submitCount is not 0, pSubmits must be a valid pointer to an array of submitCount valid VkSubmitInfo structures</th></tr>
<tr><th>VUID-vkQueueSubmit-pWaitDstStageMask-00066</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> Any stage flag included in any element of the pWaitDstStageMask member of any element of pSubmits must be a pipeline stage supported by one of the capabilities of queue, as specified in the table of supported pipeline stages.</th></tr>
<tr><th>VUID-vkQueueSubmit-pWaitSemaphores-00068</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> When a semaphore unsignal operation defined by any element of the pWaitSemaphores member of any element of pSubmits executes on queue, no other queue must be waiting on the same semaphore.</th></tr>
<tr><th>VUID-vkQueueSubmit-pWaitSemaphores-00069</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkQueueSubmit</th><th>core</th><th> All elements of the pWaitSemaphores member of all elements of pSubmits must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution.</th></tr>
<tr><th>VUID-vkQueueSubmit-queue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueSubmit</th><th>core</th><th> queue must be a valid VkQueue handle</th></tr>
<tr><th>VUID-vkQueueWaitIdle-queue-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkQueueWaitIdle</th><th>core</th><th> queue must be a valid VkQueue handle</th></tr>
<tr><th>VUID-vkRegisterDeviceEventEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterDeviceEventEXT</th><th>(VK_EXT_display_control)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkRegisterDeviceEventEXT-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkRegisterDeviceEventEXT</th><th>(VK_EXT_display_control)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkRegisterDeviceEventEXT-pDeviceEventInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterDeviceEventEXT</th><th>(VK_EXT_display_control)</th><th> pDeviceEventInfo must be a valid pointer to a valid VkDeviceEventInfoEXT structure</th></tr>
<tr><th>VUID-vkRegisterDeviceEventEXT-pFence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterDeviceEventEXT</th><th>(VK_EXT_display_control)</th><th> pFence must be a valid pointer to a VkFence handle</th></tr>
<tr><th>VUID-vkRegisterDisplayEventEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterDisplayEventEXT</th><th>(VK_EXT_display_control)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkRegisterDisplayEventEXT-display-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterDisplayEventEXT</th><th>(VK_EXT_display_control)</th><th> display must be a valid VkDisplayKHR handle</th></tr>
<tr><th>VUID-vkRegisterDisplayEventEXT-pAllocator-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkRegisterDisplayEventEXT</th><th>(VK_EXT_display_control)</th><th> If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure</th></tr>
<tr><th>VUID-vkRegisterDisplayEventEXT-pDisplayEventInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterDisplayEventEXT</th><th>(VK_EXT_display_control)</th><th> pDisplayEventInfo must be a valid pointer to a valid VkDisplayEventInfoEXT structure</th></tr>
<tr><th>VUID-vkRegisterDisplayEventEXT-pFence-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterDisplayEventEXT</th><th>(VK_EXT_display_control)</th><th> pFence must be a valid pointer to a VkFence handle</th></tr>
<tr><th>VUID-vkRegisterObjectsNVX-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkRegisterObjectsNVX-objectCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectCount must be greater than 0</th></tr>
<tr><th>VUID-vkRegisterObjectsNVX-objectTable-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectTable must be a valid VkObjectTableNVX handle</th></tr>
<tr><th>VUID-vkRegisterObjectsNVX-objectTable-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectTable must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkRegisterObjectsNVX-pObjectIndices-01365</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkRegisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> At any pObjectIndices there must not be a registered resource already.</th></tr>
<tr><th>VUID-vkRegisterObjectsNVX-pObjectIndices-01366</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkRegisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> Any value inside pObjectIndices must be below the appropriate VkObjectTableCreateInfoNVX::pObjectEntryCounts limits provided at objectTable creation time.</th></tr>
<tr><th>VUID-vkRegisterObjectsNVX-pObjectIndices-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pObjectIndices must be a valid pointer to an array of objectCount uint32_t values</th></tr>
<tr><th>VUID-vkRegisterObjectsNVX-pObjectTableEntry-01364</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkRegisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The contents of pObjectTableEntry must yield plausible bindings supported by the device.</th></tr>
<tr><th>VUID-vkRegisterObjectsNVX-ppObjectTableEntries-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkRegisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> ppObjectTableEntries must be a valid pointer to an array of objectCount valid VkObjectTableEntryNVX structures</th></tr>
<tr><th>VUID-vkReleaseDisplayEXT-display-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkReleaseDisplayEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)</th><th> display must be a valid VkDisplayKHR handle</th></tr>
<tr><th>VUID-vkReleaseDisplayEXT-physicalDevice-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkReleaseDisplayEXT</th><th>(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)</th><th> physicalDevice must be a valid VkPhysicalDevice handle</th></tr>
<tr><th>VUID-vkReleaseFullScreenExclusiveModeEXT-swapchain-02677</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkReleaseFullScreenExclusiveModeEXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> swapchain must not be in the retired state</th></tr>
<tr><th>VUID-vkReleaseFullScreenExclusiveModeEXT-swapchain-02678</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkReleaseFullScreenExclusiveModeEXT</th><th>(VK_KHR_surface)+(VK_EXT_full_screen_exclusive)</th><th> swapchain must be a swapchain created with an instance of VkSurfaceFullScreenExclusiveInfoEXT, with fullScreenExclusive set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT</th></tr>
<tr><th>VUID-vkResetCommandBuffer-commandBuffer-00045</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkResetCommandBuffer</th><th>core</th><th> commandBuffer must not be in the pending state</th></tr>
<tr><th>VUID-vkResetCommandBuffer-commandBuffer-00046</th><th><span style="color:limegreen;">Y</span></th><th>CommandBufferResetErrors</th><th>explicit</th><th>vkResetCommandBuffer</th><th>core</th><th> commandBuffer must have been allocated from a pool that was created with the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</th></tr>
<tr><th>VUID-vkResetCommandBuffer-commandBuffer-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetCommandBuffer</th><th>core</th><th> commandBuffer must be a valid VkCommandBuffer handle</th></tr>
<tr><th>VUID-vkResetCommandBuffer-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetCommandBuffer</th><th>core</th><th> flags must be a valid combination of VkCommandBufferResetFlagBits values</th></tr>
<tr><th>VUID-vkResetCommandPool-commandPool-00040</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkResetCommandPool</th><th>core</th><th> All VkCommandBuffer objects allocated from commandPool must not be in the pending state</th></tr>
<tr><th>VUID-vkResetCommandPool-commandPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetCommandPool</th><th>core</th><th> commandPool must be a valid VkCommandPool handle</th></tr>
<tr><th>VUID-vkResetCommandPool-commandPool-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetCommandPool</th><th>core</th><th> commandPool must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkResetCommandPool-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetCommandPool</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkResetCommandPool-flags-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetCommandPool</th><th>core</th><th> flags must be a valid combination of VkCommandPoolResetFlagBits values</th></tr>
<tr><th>VUID-vkResetDescriptorPool-descriptorPool-00313</th><th><span style="color:limegreen;">Y</span></th><th>DescriptorPoolInUseResetSignaled</th><th>explicit</th><th>vkResetDescriptorPool</th><th>core</th><th> All uses of descriptorPool (via any allocated descriptor sets) must have completed execution</th></tr>
<tr><th>VUID-vkResetDescriptorPool-descriptorPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>InvalidDescriptorPool</th><th>implicit</th><th>vkResetDescriptorPool</th><th>core</th><th> descriptorPool must be a valid VkDescriptorPool handle</th></tr>
<tr><th>VUID-vkResetDescriptorPool-descriptorPool-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetDescriptorPool</th><th>core</th><th> descriptorPool must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkResetDescriptorPool-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetDescriptorPool</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkResetDescriptorPool-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetDescriptorPool</th><th>core</th><th> flags must be 0</th></tr>
<tr><th>VUID-vkResetEvent-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetEvent</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkResetEvent-event-01148</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkResetEvent</th><th>core</th><th> event must not be waited on by a vkCmdWaitEvents command that is currently executing</th></tr>
<tr><th>VUID-vkResetEvent-event-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetEvent</th><th>core</th><th> event must be a valid VkEvent handle</th></tr>
<tr><th>VUID-vkResetEvent-event-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetEvent</th><th>core</th><th> event must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkResetFences-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetFences</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkResetFences-fenceCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkResetFences</th><th>core</th><th> fenceCount must be greater than 0</th></tr>
<tr><th>VUID-vkResetFences-pFences-01123</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkResetFences</th><th>core</th><th> Each element of pFences must not be currently associated with any queue command that has not yet completed execution on that queue</th></tr>
<tr><th>VUID-vkResetFences-pFences-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetFences</th><th>core</th><th> pFences must be a valid pointer to an array of fenceCount valid VkFence handles</th></tr>
<tr><th>VUID-vkResetFences-pFences-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetFences</th><th>core</th><th> Each element of pFences must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkResetQueryPoolEXT-None-02665</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkResetQueryPoolEXT</th><th>(VK_EXT_host_query_reset)</th><th> The hostQueryReset feature must be enabled</th></tr>
<tr><th>VUID-vkResetQueryPoolEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetQueryPoolEXT</th><th>(VK_EXT_host_query_reset)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkResetQueryPoolEXT-firstQuery-02666</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkResetQueryPoolEXT</th><th>(VK_EXT_host_query_reset)</th><th> firstQuery must be less than the number of queries in queryPool</th></tr>
<tr><th>VUID-vkResetQueryPoolEXT-firstQuery-02667</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkResetQueryPoolEXT</th><th>(VK_EXT_host_query_reset)</th><th> The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool</th></tr>
<tr><th>VUID-vkResetQueryPoolEXT-queryPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetQueryPoolEXT</th><th>(VK_EXT_host_query_reset)</th><th> queryPool must be a valid VkQueryPool handle</th></tr>
<tr><th>VUID-vkResetQueryPoolEXT-queryPool-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkResetQueryPoolEXT</th><th>(VK_EXT_host_query_reset)</th><th> queryPool must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkSetDebugUtilsObjectNameEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetDebugUtilsObjectNameEXT</th><th>(VK_EXT_debug_utils)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-02587</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkSetDebugUtilsObjectNameEXT</th><th>(VK_EXT_debug_utils)</th><th> pNameInfo->objectType must not be VK_OBJECT_TYPE_UNKNOWN</th></tr>
<tr><th>VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-02588</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkSetDebugUtilsObjectNameEXT</th><th>(VK_EXT_debug_utils)</th><th> pNameInfo->objectHandle must not be VK_NULL_HANDLE</th></tr>
<tr><th>VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetDebugUtilsObjectNameEXT</th><th>(VK_EXT_debug_utils)</th><th> pNameInfo must be a valid pointer to a valid VkDebugUtilsObjectNameInfoEXT structure</th></tr>
<tr><th>VUID-vkSetDebugUtilsObjectTagEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetDebugUtilsObjectTagEXT</th><th>(VK_EXT_debug_utils)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkSetDebugUtilsObjectTagEXT-pTagInfo-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetDebugUtilsObjectTagEXT</th><th>(VK_EXT_debug_utils)</th><th> pTagInfo must be a valid pointer to a valid VkDebugUtilsObjectTagInfoEXT structure</th></tr>
<tr><th>VUID-vkSetEvent-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetEvent</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkSetEvent-event-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetEvent</th><th>core</th><th> event must be a valid VkEvent handle</th></tr>
<tr><th>VUID-vkSetEvent-event-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetEvent</th><th>core</th><th> event must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkSetHdrMetadataEXT-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetHdrMetadataEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata)</th><th> Both of device, and the elements of pSwapchains must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkSetHdrMetadataEXT-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetHdrMetadataEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkSetHdrMetadataEXT-pMetadata-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetHdrMetadataEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata)</th><th> pMetadata must be a valid pointer to an array of swapchainCount valid VkHdrMetadataEXT structures</th></tr>
<tr><th>VUID-vkSetHdrMetadataEXT-pSwapchains-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetHdrMetadataEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata)</th><th> pSwapchains must be a valid pointer to an array of swapchainCount valid VkSwapchainKHR handles</th></tr>
<tr><th>VUID-vkSetHdrMetadataEXT-swapchainCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetHdrMetadataEXT</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata)</th><th> swapchainCount must be greater than 0</th></tr>
<tr><th>VUID-vkSetLocalDimmingAMD-XXXXX</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkSetLocalDimmingAMD</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_AMD_display_native_hdr)</th><th> It is only valid to call vkSetLocalDimmingAMD if VkDisplayNativeHdrSurfaceCapabilitiesAMD::localDimmingSupport is supported.</th></tr>
<tr><th>VUID-vkSetLocalDimmingAMD-commonparent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetLocalDimmingAMD</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_AMD_display_native_hdr)</th><th> Both of device, and swapChain must have been created, allocated, or retrieved from the same VkInstance</th></tr>
<tr><th>VUID-vkSetLocalDimmingAMD-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetLocalDimmingAMD</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_AMD_display_native_hdr)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkSetLocalDimmingAMD-swapChain-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSetLocalDimmingAMD</th><th>(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_AMD_display_native_hdr)</th><th> swapChain must be a valid VkSwapchainKHR handle</th></tr>
<tr><th>VUID-vkSubmitDebugUtilsMessageEXT-instance-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSubmitDebugUtilsMessageEXT</th><th>(VK_EXT_debug_utils)</th><th> instance must be a valid VkInstance handle</th></tr>
<tr><th>VUID-vkSubmitDebugUtilsMessageEXT-messageSeverity-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSubmitDebugUtilsMessageEXT</th><th>(VK_EXT_debug_utils)</th><th> messageSeverity must be a valid VkDebugUtilsMessageSeverityFlagBitsEXT value</th></tr>
<tr><th>VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkSubmitDebugUtilsMessageEXT</th><th>(VK_EXT_debug_utils)</th><th> messageTypes must be a valid combination of VkDebugUtilsMessageTypeFlagBitsEXT values</th></tr>
<tr><th>VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-requiredbitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSubmitDebugUtilsMessageEXT</th><th>(VK_EXT_debug_utils)</th><th> messageTypes must not be 0</th></tr>
<tr><th>VUID-vkSubmitDebugUtilsMessageEXT-objectType-02591</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkSubmitDebugUtilsMessageEXT</th><th>(VK_EXT_debug_utils)</th><th> objectType member of each element of pCallbackData->pObjects must not be VK_OBJECT_TYPE_UNKNOWN</th></tr>
<tr><th>VUID-vkSubmitDebugUtilsMessageEXT-pCallbackData-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkSubmitDebugUtilsMessageEXT</th><th>(VK_EXT_debug_utils)</th><th> pCallbackData must be a valid pointer to a valid VkDebugUtilsMessengerCallbackDataEXT structure</th></tr>
<tr><th>VUID-vkTrimCommandPool-commandPool-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkTrimCommandPool</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> commandPool must be a valid VkCommandPool handle</th></tr>
<tr><th>VUID-vkTrimCommandPool-commandPool-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkTrimCommandPool</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> commandPool must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkTrimCommandPool-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkTrimCommandPool</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkTrimCommandPool-flags-zerobitmask</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkTrimCommandPool</th><th>(VK_VERSION_1_1,VK_KHR_maintenance1)</th><th> flags must be 0</th></tr>
<tr><th>VUID-vkUnmapMemory-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUnmapMemory</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkUnmapMemory-memory-00689</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>explicit</th><th>vkUnmapMemory</th><th>core</th><th> memory must be currently host mapped</th></tr>
<tr><th>VUID-vkUnmapMemory-memory-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUnmapMemory</th><th>core</th><th> memory must be a valid VkDeviceMemory handle</th></tr>
<tr><th>VUID-vkUnmapMemory-memory-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUnmapMemory</th><th>core</th><th> memory must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkUnregisterObjectsNVX-None-01375</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkUnregisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> All operations on the device using the registered resource must have been completed.</th></tr>
<tr><th>VUID-vkUnregisterObjectsNVX-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUnregisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkUnregisterObjectsNVX-objectCount-arraylength</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUnregisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectCount must be greater than 0</th></tr>
<tr><th>VUID-vkUnregisterObjectsNVX-objectTable-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUnregisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectTable must be a valid VkObjectTableNVX handle</th></tr>
<tr><th>VUID-vkUnregisterObjectsNVX-objectTable-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUnregisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> objectTable must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkUnregisterObjectsNVX-pObjectEntryTypes-01374</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkUnregisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> The pObjectEntryTypes of the resource at pObjectIndices must match.</th></tr>
<tr><th>VUID-vkUnregisterObjectsNVX-pObjectEntryTypes-parameter</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkUnregisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pObjectEntryTypes must be a valid pointer to an array of objectCount valid VkObjectEntryTypeNVX values</th></tr>
<tr><th>VUID-vkUnregisterObjectsNVX-pObjectIndices-01373</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkUnregisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> At any pObjectIndices there must be a registered resource already.</th></tr>
<tr><th>VUID-vkUnregisterObjectsNVX-pObjectIndices-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUnregisterObjectsNVX</th><th>(VK_NVX_device_generated_commands)</th><th> pObjectIndices must be a valid pointer to an array of objectCount uint32_t values</th></tr>
<tr><th>VUID-vkUpdateDescriptorSetWithTemplate-descriptorSet-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUpdateDescriptorSetWithTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> descriptorSet must be a valid VkDescriptorSet handle</th></tr>
<tr><th>VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUpdateDescriptorSetWithTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle</th></tr>
<tr><th>VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUpdateDescriptorSetWithTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> descriptorUpdateTemplate must have been created, allocated, or retrieved from device</th></tr>
<tr><th>VUID-vkUpdateDescriptorSetWithTemplate-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUpdateDescriptorSetWithTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkUpdateDescriptorSetWithTemplate-pData-01685</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkUpdateDescriptorSetWithTemplate</th><th>(VK_VERSION_1_1,VK_KHR_descriptor_update_template)</th><th> pData must be a valid pointer to a memory that contains one or more valid instances of VkDescriptorImageInfo, VkDescriptorBufferInfo, or VkBufferView in a layout defined by descriptorUpdateTemplate when it was created with vkCreateDescriptorUpdateTemplate</th></tr>
<tr><th>VUID-vkUpdateDescriptorSets-None-03047</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkUpdateDescriptorSets</th><th>(VK_EXT_descriptor_indexing)</th><th> Descriptor bindings updated by this command which were created without the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT or VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT bits set must not be used by any command that was recorded to a command buffer which is in the pending state.</th></tr>
<tr><th>VUID-vkUpdateDescriptorSets-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUpdateDescriptorSets</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkUpdateDescriptorSets-dstSet-00314</th><th><span style="color:red;">N</span></th><th>None</th><th>explicit</th><th>vkUpdateDescriptorSets</th><th>!(VK_EXT_descriptor_indexing)</th><th> The dstSet member of each element of pDescriptorWrites or pDescriptorCopies must not be used by any command that was recorded to a command buffer which is in the pending state.</th></tr>
<tr><th>VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUpdateDescriptorSets</th><th>core</th><th> If descriptorCopyCount is not 0, pDescriptorCopies must be a valid pointer to an array of descriptorCopyCount valid VkCopyDescriptorSet structures</th></tr>
<tr><th>VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkUpdateDescriptorSets</th><th>core</th><th> If descriptorWriteCount is not 0, pDescriptorWrites must be a valid pointer to an array of descriptorWriteCount valid VkWriteDescriptorSet structures</th></tr>
<tr><th>VUID-vkWaitForFences-device-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkWaitForFences</th><th>core</th><th> device must be a valid VkDevice handle</th></tr>
<tr><th>VUID-vkWaitForFences-fenceCount-arraylength</th><th><span style="color:red;">N</span></th><th>None</th><th>implicit</th><th>vkWaitForFences</th><th>core</th><th> fenceCount must be greater than 0</th></tr>
<tr><th>VUID-vkWaitForFences-pFences-parameter</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkWaitForFences</th><th>core</th><th> pFences must be a valid pointer to an array of fenceCount valid VkFence handles</th></tr>
<tr><th>VUID-vkWaitForFences-pFences-parent</th><th><span style="color:limegreen;">Y</span></th><th>None</th><th>implicit</th><th>vkWaitForFences</th><th>core</th><th> Each element of pFences must have been created, allocated, or retrieved from device</th></tr>
</table>
</body>
</html>
