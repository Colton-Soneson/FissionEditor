<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link rel="icon" href="images/vulkan_lunarg_icon.png">
<link rel="stylesheet" href="github-markdown.css">
<style>
    body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
    }
</style>
</head>
<body>
<article class="markdown-body">


<p><a href="https://www.khronos.org/vulkan/" TARGET="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/16b56b2bf6d81f97a94bed0f0a4f89b24a2b8117/68747470733a2f2f76756c6b616e2e6c756e6172672e636f6d2f696d672f56756c6b616e5f31303070785f44656331362e706e67" alt="Khronos Vulkan" title="https://www.khronos.org/vulkan/" data-canonical-src="https://vulkan.lunarg.com/img/Vulkan_100px_Dec16.png" style="max-width:100%;"></a></p>
<h1>
<a id="user-content-gpu-assisted-validation" class="anchor" href="#user-content-gpu-assisted-validation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GPU-Assisted Validation</h1>
<p><a href="https://creativecommons.org/licenses/by-nd/4.0/" TARGET="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/769ad34d33c3c36b21baa4c4838b311433fcdcd3/68747470733a2f2f692e6372656174697665636f6d6d6f6e732e6f72672f6c2f62792d6e642f342e302f38387833312e706e67" alt="Creative Commons" title="Creative Commons License" data-canonical-src="https://i.creativecommons.org/l/by-nd/4.0/88x31.png" style="max-width:100%;"></a></p>
<p>GPU-Assisted validation is implemented in the SPIR-V Tools optimizer and the <code>VK_LAYER_KHRONOS_validation layer (or, in the soon-to-be-deprecated </code>VK_LAYER_LUNARG_core_validation` layer). This document covers the design of the layer portion of the
implementation.</p>
<h2>
<a id="user-content-basic-operation" class="anchor" href="#user-content-basic-operation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Basic Operation</h2>
<p>The basic operation of GPU-Assisted validation is comprised of instrumenting shader code to perform run-time checking in shaders and
reporting any error conditions to the layer.
The layer then reports the errors to the user via the same reporting mechanisms used by the rest of the validation system.</p>
<p>The layer instruments the shaders by passing the shader's SPIR-V bytecode to the SPIR-V optimizer component and
instructs the optimizer to perform an instrumentation pass to add the additional instructions to perform the run-time checking.
The layer then passes the resulting modified SPIR-V bytecode to the driver as part of the process of creating a ShaderModule.</p>
<p>As the shader is executed, the instrumented shader code performs the run-time checks.
If a check detects an error condition, the instrumentation code writes an error record into the GPU's device memory.
This record is small and is on the order of a dozen 32-bit words.
Since multiple shader stages and multiple invocations of a shader can all detect errors, the instrumentation code
writes error records into consecutive memory locations as long as there is space available in the pre-allocated block of device memory.</p>
<p>The layer inspects this device memory block after completion of a queue submission.
If the GPU had written an error record to this memory block,
the layer analyzes this error record and constructs a validation error message
which is then reported in the same manner as other validation messages.
If the shader was compiled with debug information (source code and SPIR-V instruction mapping to source code lines), the layer
also provides the line of shader source code that provoked the error as part of the validation error message.</p>
<h2>
<a id="user-content-gpu-assisted-validation-checks" class="anchor" href="#user-content-gpu-assisted-validation-checks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GPU-Assisted Validation Checks</h2>
<p>The initial release (Jan 2019) of GPU-Assisted Validation includes checking for out-of-bounds descriptor array indexing
for image/texel descriptor types.</p>
<p>Future releases are planned to add checking for other hazards such as proper population of descriptors when using the
<code>descriptorBindingPartiallyBound</code> feature of the <code>VK_EXT_descriptor_indexing</code> extension.</p>
<h3>
<a id="user-content-out-of-boundsoob-descriptor-array-indexing" class="anchor" href="#user-content-out-of-boundsoob-descriptor-array-indexing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Out-of-Bounds(OOB) Descriptor Array Indexing</h3>
<p>Checking for correct indexing of descriptor arrays is sometimes referred to as "bind-less validation".
It is called "bind-less" because a binding in a descriptor set may contain an array of like descriptors.
And unless there is a constant or compile-time indication of which descriptor in the array is selected,
the descriptor binding status is considered to be ambiguous, leaving the actual binding to be determined at run-time.</p>
<p>As an example, a fragment shader program may use a variable to index an array of combined image samplers.
Such a line might look like:</p>
<div class="highlight highlight-source-glsl"><pre>uFragColor <span class="pl-k">=</span> light <span class="pl-k">*</span> texture(tex[tex_ind], texcoord.xy);</pre></div>
<p>The array of combined image samplers is <code>tex</code> and has 6 samplers in the array.
The complete validation error message issued when <code>tex_ind</code> indexes past the array is:</p>
<pre lang="terminal"><code>ERROR : VALIDATION - Message Id Number: 0 | Message Id Name: UNASSIGNED-Image descriptor index out of bounds
        Index of 6 used to index descriptor array of length 6.  Command buffer (CubeDrawCommandBuf)(0xbc24b0).
        Pipeline (0x45). Shader Module (0x43). Shader Instruction Index = 108.  Stage = Fragment.
        Fragment coord (x,y) = (419.5, 254.5). Shader validation error occurred in file:
        /home/user/src/Vulkan-ValidationLayers/external/Vulkan-Tools/cube/cube.frag at line 45.
45:    uFragColor = light * texture(tex[tex_ind], texcoord.xy);
</code></pre>
<h2>
<a id="user-content-gpu-assisted-validation-options" class="anchor" href="#user-content-gpu-assisted-validation-options" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GPU-Assisted Validation Options</h2>
<p>Here are the options related to activating GPU-Assisted Validation:</p>
<ol>
<li>
<p>Enable GPU-Assisted Validation - GPU-Assisted Validation is off by default and must be enabled.</p>
<p>GPU-Assisted Validation is disabled by default because the shader instrumentation may introduce significant
shader performance degradation and additional resource consumption.
GPU-Assisted Validation requires additional resources such as device memory and descriptors.
It is desirable for the user to opt-in to this feature because of these requirements.
In addition, there are several limitations that may adversely affect application behavior,
as described later in this document.</p>
</li>
<li>
<p>Reserve a Descriptor Set Binding Slot - Modifies the value of the <code>VkPhysicalDeviceLimits::maxBoundDescriptorSets</code>
property to return a value one less than the actual device's value to "reserve" a descriptor set binding slot for use by GPU validation.</p>
<p>This option is likely only of interest to applications that dynamically adjust their descriptor set bindings to adjust for
the limits of the device.</p>
</li>
</ol>
<h3>
<a id="user-content-enabling-and-specifying-options-with-a-configuration-file" class="anchor" href="#user-content-enabling-and-specifying-options-with-a-configuration-file" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Enabling and Specifying Options with a Configuration File</h3>
<p>The existing layer configuration file mechanism can be used to enable GPU-Assisted Validation.
This mechanism is described on the
<a href="https://vulkan.lunarg.com/doc/sdk/latest/windows/layer_configuration.html" TARGET="_blank" rel="nofollow">LunarXchange website</a>,
in the "Layers Overview and Configuration" document.</p>
<p>To turn on GPU validation, add the following to your layer settings file, which is often
named <code>vk_layer_settings.txt</code>.</p>
<pre lang="code"><code>khronos_validation.gpu_validation = all
</code></pre>
<p>To turn on GPU validation and request to reserve a binding slot:</p>
<pre lang="code"><code>khronos_validation.gpu_validation = all,reserve_binding_slot
</code></pre>
<p>Note: When using the core_validation layer, the above settings should use <code>lunarg_core_validation</code> in place of
<code>khronos_validation</code>.</p>
<p>Some platforms do not support configuration of the validation layers with this configuration file.
Programs running on these platforms must then use the programmatic interface.</p>
<h3>
<a id="user-content-enabling-and-specifying-options-with-the-programmatic-interface" class="anchor" href="#user-content-enabling-and-specifying-options-with-the-programmatic-interface" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Enabling and Specifying Options with the Programmatic Interface</h3>
<p>The <code>VK_EXT_validation_features</code> extension can be used to enable GPU-Assisted Validation at CreateInstance time.</p>
<p>Here is sample code illustrating how to enable it:</p>
<div class="highlight highlight-source-c"><pre>VkValidationFeatureEnableEXT enables[] = {VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT};
VkValidationFeaturesEXT features = {};
features.<span class="pl-smi">sType</span> = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
features.enabledValidationFeatureCount = <span class="pl-c1">1</span>;
features.pEnabledValidationFeatures = enables;

VkInstanceCreateInfo info = {};
info.pNext = &amp;features;</pre></div>
<p>Use the <code>VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT</code> enum to reserve a binding slot.</p>
<h2>
<a id="user-content-gpu-assisted-validation-limitations" class="anchor" href="#user-content-gpu-assisted-validation-limitations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GPU-Assisted Validation Limitations</h2>
<p>There are several limitations that may impede the operation of GPU-Assisted Validation:</p>
<h3>
<a id="user-content-vulkan-11" class="anchor" href="#user-content-vulkan-11" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Vulkan 1.1</h3>
<p>Vulkan 1.1 or later is required because the GPU instrumentation code uses SPIR-V 1.3 features.
Vulkan 1,1 is required to ensure that SPIR-V 1.3 is available.</p>
<h3>
<a id="user-content-descriptor-types" class="anchor" href="#user-content-descriptor-types" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Descriptor Types</h3>
<p>The current implementation works with image and texel descriptor types.
A complete list appears later in this document.</p>
<h3>
<a id="user-content-descriptor-set-binding-limit" class="anchor" href="#user-content-descriptor-set-binding-limit" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Descriptor Set Binding Limit</h3>
<p>This is probably the most important limitation and is related to the
<code>VkPhysicalDeviceLimits::maxBoundDescriptorSets</code> device limit.</p>
<p>When applications use all the available descriptor set binding slots,
GPU-Assisted Validation cannot be performed because it needs a descriptor set to
locate the memory for writing the error report record.</p>
<p>This problem is most likely to occur on devices, often mobile, that support only the
minimum required value for <code>VkPhysicalDeviceLimits::maxBoundDescriptorSets</code>, which is 4.
Some applications may be written to use 4 slots since this is the highest value that
is guaranteed by the specification.
When such an application using 4 slots runs on a device with only 4 slots,
then GPU-Assisted Validation cannot be performed.</p>
<p>In this implementation, this condition is detected and gracefully recovered from by
building the graphics pipeline with non-instrumented shaders instead of instrumented ones.
An error message is also displayed informing the user of the condition.</p>
<p>Applications don't have many options in this situation and it is anticipated that
changing the application to free a slot is difficult.</p>
<h3>
<a id="user-content-device-memory" class="anchor" href="#user-content-device-memory" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Device Memory</h3>
<p>GPU-Assisted Validation does allocate device memory for the error report buffers.
This can lead to a greater chance of memory exhaustion, especially in cases where
the application is trying to use all of the available memory.
The extra memory allocations are also not visible to the application, making it
impossible for the application to account for them.</p>
<p>If GPU-Assisted Validation device memory allocations fail, the device could become
unstable because some previously-built pipelines may contain instrumented shaders.
This is a condition that is nearly impossible to recover from, so the layer just
prints an error message and refrains from any further allocations or instrumentations.
There is a reasonable chance to recover from these conditions,
especially if the instrumentation does not write any error records.</p>
<h3>
<a id="user-content-descriptors" class="anchor" href="#user-content-descriptors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Descriptors</h3>
<p>This is roughly the same problem as the device memory problem mentioned above,
but for descriptors.
Any failure to allocate a descriptor set means that the instrumented shader code
won't have a place to write error records, resulting in unpredictable device
behavior.</p>
<h3>
<a id="user-content-other-device-limits" class="anchor" href="#user-content-other-device-limits" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Other Device Limits</h3>
<p>This implementation uses additional resources that may count against the following limits,
and possibly others:</p>
<ul>
<li><code>maxMemoryAllocationCount</code></li>
<li><code>maxBoundDescriptorSets</code></li>
<li><code>maxPerStageDescriptorStorageBuffers</code></li>
<li><code>maxPerStageResources</code></li>
<li><code>maxDescriptorSetStorageBuffers</code></li>
<li><code>maxFragmentCombinedOutputResources</code></li>
</ul>
<p>The implementation does not take steps to avoid exceeding these limits
and does not update the tracking performed by other validation functions.</p>
<h3>
<a id="user-content-a-note-about-the-vk_ext_buffer_device_address-extension" class="anchor" href="#user-content-a-note-about-the-vk_ext_buffer_device_address-extension" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A Note About the <code>VK_EXT_buffer_device_address</code> Extension</h3>
<p>The recently introduced <code>VK_EXT_buffer_device_address</code> extension can be used
to implement GPU-Assisted Validation without some of the limitations described above.
This approach would use this extension to obtain a GPU device pointer to a storage
buffer and make it available to the shader via a specialization constant.
This technique removes the need to create descriptors, use a descriptor set slot,
modify pipeline layouts, etc, and would relax some of the limitations listed above.</p>
<p>This alternate implementation is under consideration.</p>
<h2>
<a id="user-content-gpu-assisted-validation-internal-design" class="anchor" href="#user-content-gpu-assisted-validation-internal-design" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GPU-Assisted Validation Internal Design</h2>
<p>This section may be of interest to readers who are interested on how GPU-Assisted Validation is implemented.
It isn't necessarily required for using the feature.</p>
<h3>
<a id="user-content-general" class="anchor" href="#user-content-general" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>General</h3>
<p>In general, the implementation does:</p>
<ul>
<li>
<p>For each draw call, allocate a buffer with enough device memory to hold a single debug output record written by the
instrumented shader code.
The Vulkan Memory Allocator is used to handle this efficiently.</p>
<p>There is probably little advantage in providing a larger buffer in order to obtain more debug records.
It is likely, especially for fragment shaders, that multiple errors occurring near each other have the same root cause.</p>
<p>A block is allocated on a per draw basis to make it possible to associate a shader debug error record with
a draw within a command buffer.
This is done partly to give the user more information in the error report, namely the command buffer handle/name and the draw within that command buffer.
An alternative design allocates this block on a per-device or per-queue basis and should work.
However, it is not possible to identify the command buffer that causes the error if multiple command buffers
are submitted at once.</p>
</li>
<li>
<p>For each draw call, allocate a descriptor set and update it to point to the block of device memory just allocated.
There is a descriptor set manager to handle this efficiently.
Also make an additional call down the chain to create a bind descriptor set command to bind our descriptor set at the desired index.
This has the effect of binding the device memory block belonging to this draw so that the GPU instrumentation
writes into this buffer for when the draw is executed.
The end result is that each draw call has its own buffer containing GPU instrumentation error
records, if any occurred while executing that draw.</p>
</li>
<li>
<p>Determine the descriptor set binding index that is eventually used to bind the descriptor set just allocated and updated.
Usually, it is <code>VkPhysicalDeviceLimits::maxBoundDescriptorSets</code> minus one.
For devices that have a very high or no limit on this bound, pick an index that isn't too high, but above most other device
maxima such as 32.</p>
</li>
<li>
<p>When creating a ShaderModule, pass the SPIR-V bytecode to the SPIR-V optimizer to perform the instrumentation pass.
Pass the desired descriptor set binding index to the optimizer via a parameter so that the instrumented
code knows which descriptor to use for writing error report data to the memory block.
Use the instrumented bytecode to create the ShaderModule.</p>
</li>
<li>
<p>For all pipeline layouts, add our descriptor set to the layout, at the binding index determined earlier.
Fill any gaps with empty descriptor sets.</p>
<p>If the incoming layout already has a descriptor set placed at our desired index, the layer must not add its
descriptor set to the layout, replacing the one in the incoming layout.
Instead, the layer leaves the layout alone and later replaces the instrumented shaders with
non-instrumented ones when the pipeline layout is later used to create a graphics pipeline.
The layer issues an error message to report this condition.</p>
</li>
<li>
<p>When creating a GraphicsPipeline, check to see if the pipeline is using the debug binding index.
If it is, replace the instrumented shaders in the pipeline with non-instrumented ones.</p>
</li>
<li>
<p>After calling QueueSubmit, perform a wait on the queue to allow the queue to finish executing.
Then map and examine the device memory block for each draw that was submitted.
If any debug record is found, generate a validation error message for each record found.</p>
</li>
</ul>
<p>The above describes only the high-level details of GPU-Assisted Validation operation.
More detail is found in the discussion of the individual hooked functions below.</p>
<h3>
<a id="user-content-initialization" class="anchor" href="#user-content-initialization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Initialization</h3>
<p>When the validation layer loads, it examines the user options from both the layer settings file and the
<code>VK_EXT_validation_features</code> extension.
Note that it also processes the subsumed <code>VK_EXT_validation_flags</code> extension for simple backwards compatibility.
From these options, the layer sets instance-scope flags in the validation layer tracking data to indicate if
GPU-Assisted Validation has been requested, along with any other associated options.</p>
<h3>
<a id="user-content-calling-down-the-chain" class="anchor" href="#user-content-calling-down-the-chain" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>"Calling Down the Chain"</h3>
<p>Much of the GPU-Assisted Validation implementation involves making "application level" Vulkan API
calls outside of the application's API usage to create resources and perform its required operations
inside of the validation layer.
These calls are not routed up through the top of the loader/layer/driver call stack via the loader.
Instead, they are simply dispatched via the containing layer's dispatch table.</p>
<p>These calls therefore don't pass through any validation checks that occur before the gpu validation checks are run.
This doesn't present any particular problem, but it does raise some issues:</p>
<ul>
<li>
<p>The additional API calls are not fully validated</p>
<p>This implies that this additional code may never be checked for validation errors.
To address this, the code can "just" be written carefully so that it is "valid" Vulkan,
which is hard to do.</p>
<p>Or, this code can be checked by loading a khronos validation layer with
GPU validation enabled on top of "normal" standard validation in the
layer stack, which effectively validates the API usage of this code.
This sort of checking is performed by layer developers to check that the additional
Vulkan usage is valid.</p>
<p>This validation can be accomplished by:</p>
<ul>
<li>Building the validation layer with a hack to force GPU-Assisted Validation to be enabled.
Can't use the exposed mechanisms because we probably don't want it on twice.</li>
<li>Rename this layer binary to something else like "khronos_validation2" to keep it apart from the
"normal" khronos validation.</li>
<li>Create a new JSON file with the new layer name.</li>
<li>Set up the layer stack so that the "khronos_validation2" layer is on top of or before the actual khronos
validation layer</li>
<li>Then run tests and check for validation errors pointing to API usage in the "khronos_validation2" layer.</li>
</ul>
<p>This should only need to be done after making any major changes to the implementation.</p>
<p>Another approach involves capturing an application trace with <code>vktrace</code> and then playing
it back with <code>vkreplay</code>.</p>
</li>
<li>
<p>The additional API calls are not state-tracked</p>
<p>This means that things like device memory allocations and descriptor allocations are not
tracked and do not show up in any of the bookkeeping performed by the validation layers.
For example, any device memory allocation performed by GPU-Assisted Validation won't be
counted towards the maximum number of allocations allowed by a device.
This could lead to an early allocation failure that is not accompanied by a validation error.</p>
<p>This shortcoming is left as not addressed in this implementation because it is anticipated that
a later implementation of GPU-Assisted Validation using the <code>VK_EXT_buffer_device_address</code>
extension will have less of a need to allocate these
tracked resources and it therefore becomes less of an issue.</p>
</li>
</ul>
<h3>
<a id="user-content-code-structure-and-relationship-to-the-core-validation-layer" class="anchor" href="#user-content-code-structure-and-relationship-to-the-core-validation-layer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Code Structure and Relationship to the Core Validation Layer</h3>
<p>The GPU-Assisted Validation code is largely contained in one
<a href="https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/master/layers/gpu_validation.cpp" TARGET="_blank">file</a>, with "hooks" in
the other validation code that call functions in this file.
These hooks in the validation code look something like this:</p>
<div class="highlight highlight-source-c"><pre><span class="pl-k">if</span> (GetEnables(dev_data)-&gt;gpu_validation) {
    <span class="pl-c1">GpuPreCallRecordDestroyPipeline</span>(dev_data, pipeline_state);
}</pre></div>
<p>The GPU-Assisted Validation code is linked into the shared library for the khronos and core validation layers.</p>
<h4>
<a id="user-content-review-of-khronos-validation-code-structure" class="anchor" href="#user-content-review-of-khronos-validation-code-structure" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Review of Khronos Validation Code Structure</h4>
<p>Each function for a Vulkan API command intercepted in the khronos validation layer is usually split up
into several decomposed functions in order to organize the implementation.
These functions take the form of:</p>
<ul>
<li>PreCallValidate&lt;foo&gt;: Perform validation steps before calling down the chain</li>
<li>PostCallValidate&lt;foo&gt;: Perform validation steps after calling down the chain</li>
<li>PreCallRecord&lt;foo&gt;: Perform state recording before calling down the chain</li>
<li>PostCallRecord&lt;foo&gt;: Perform state recording after calling down the chain</li>
</ul>
<p>The GPU-Assisted Validation functions follow this pattern not by hooking into the top-level validation API shim, but
by hooking one of these decomposed functions.</p>
<p>The design of each hooked function follows:</p>
<h4>
<a id="user-content-gpuprecallrecordcreatedevice" class="anchor" href="#user-content-gpuprecallrecordcreatedevice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuPreCallRecordCreateDevice</h4>
<ul>
<li>Modify the <code>VkPhysicalDeviceFeatures</code> to turn on two additional physical device features:
<ul>
<li><code>fragmentStoresAndAtomics</code></li>
<li><code>vertexPipelineStoresAndAtomics</code></li>
</ul>
</li>
</ul>
<h4>
<a id="user-content-gpupostcallrecordcreatedevice" class="anchor" href="#user-content-gpupostcallrecordcreatedevice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuPostCallRecordCreateDevice</h4>
<ul>
<li>Determine and record (save in device state) the desired descriptor set binding index.</li>
<li>Initialize Vulkan Memory Allocator
<ul>
<li>Determine error record block size based on the maximum size of the error record and alignment limits of the device.</li>
</ul>
</li>
<li>Initialize descriptor set manager</li>
<li>Make a descriptor set layout to describe our descriptor set</li>
<li>Make a descriptor set layout to describe a "dummy" descriptor set that contains no descriptors
<ul>
<li>This is used to "pad" pipeline layouts to fill any gaps between the used bind indices and our bind index</li>
</ul>
</li>
<li>Record these objects in the per-device state</li>
</ul>
<h4>
<a id="user-content-gpuprecallrecorddestroydevice" class="anchor" href="#user-content-gpuprecallrecorddestroydevice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuPreCallRecordDestroyDevice</h4>
<ul>
<li>Destroy descriptor set layouts created in CreateDevice</li>
<li>Clean up descriptor set manager</li>
<li>Clean up Vulkan Memory Allocator (VMA)</li>
<li>Clean up device state</li>
</ul>
<h4>
<a id="user-content-gpuallocatevalidationresources" class="anchor" href="#user-content-gpuallocatevalidationresources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuAllocateValidationResources</h4>
<ul>
<li>For each Draw or Dispatch call:
<ul>
<li>Get a descriptor set from the descriptor set manager</li>
<li>Get a buffer and associated memory from VMA</li>
<li>Update (write) the descriptor set with the memory info</li>
<li>Check to see if the layout for the pipeline just bound is using our selected bind index</li>
<li>If no conflict, add an additional command to the command buffer to bind our descriptor set at our selected index</li>
</ul>
</li>
<li>Record the above objects in the per-CB state
Note that the Draw and Dispatch calls include vkCmdDraw, vkCmdDrawIndexed, vkCmdDrawIndirect, vkCmdDrawIndexedIndirect, vkCmdDispatch, and vkCmdDispatchIndirect.</li>
</ul>
<h4>
<a id="user-content-gpuprecallrecordfreecommandbuffers" class="anchor" href="#user-content-gpuprecallrecordfreecommandbuffers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuPreCallRecordFreeCommandBuffers</h4>
<ul>
<li>For each command buffer:
<ul>
<li>Destroy the VMA buffer, releasing the memory</li>
<li>Give the descriptor sets back to the descriptor set manager</li>
<li>Clean up CB state</li>
</ul>
</li>
</ul>
<h4>
<a id="user-content-gpuoverridedispatchcreateshadermodule" class="anchor" href="#user-content-gpuoverridedispatchcreateshadermodule" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuOverrideDispatchCreateShaderModule</h4>
<p>This function is called from PreCallRecordCreateShaderModule.
This routine sets up to call the SPIR-V optimizer to run the "BindlessCheckPass", replacing the original SPIR-V with the instrumented SPIR-V
which is then used in the call down the chain to CreateShaderModule.</p>
<p>This function generates a "unique shader ID" that is passed to the SPIR-V optimizer,
which the instrumented code puts in the debug error record to identify the shader.
This ID is returned by this function so it can be recorded in the shader module at PostCallRecord time.
It would have been convenient to use the shader module handle returned from the driver to use as this shader ID.
But the shader needs to be instrumented before creating the shader module and therefore the handle is not available to use
as this ID to pass to the optimizer.
Therefore, the layer keeps a "counter" in per-device state that is incremented each time a shader is instrumented
to generate unique IDs.
This unique ID is given to the SPIR-V optimizer and is stored in the shader module state tracker after the shader module is created, which creates the necessary association between the ID and the shader module.</p>
<p>The process of instrumenting the SPIR-V also includes passing the selected descriptor set binding index
to the SPIR-V optimizer which the instrumented
code uses to locate the memory block used to write the debug error record.
An instrumented shader is now "hard-wired" to write error records via the descriptor set at that binding
if it detects an error.
This implies that the instrumented shaders should only be allowed to run when the correct bindings are in place.</p>
<p>The original SPIR-V bytecode is left stored in the shader module tracking data.
This is important because the layer may need to replace the instrumented shader with the original shader if, for example,
there is a binding index conflict.
The application cannot destroy the shader module until it has used the shader module to create the pipeline.
This ensures that the original SPIR-V bytecode is available if we need it to replace the instrumented shader.</p>
<h4>
<a id="user-content-gpuoverridedispatchcreatepipelinelayout" class="anchor" href="#user-content-gpuoverridedispatchcreatepipelinelayout" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuOverrideDispatchCreatePipelineLayout</h4>
<p>This is function is called through PreCallRecordCreatePipelineLayout.</p>
<ul>
<li>Check for a descriptor set binding index conflict.
<ul>
<li>If there is one, issue an error message and leave the pipeline layout unmodified</li>
<li>If no conflict, for each pipeline layout:
<ul>
<li>Create a new pipeline layout</li>
<li>Copy the original descriptor set layouts into the new pipeline layout</li>
<li>Pad the new pipeline layout with dummy descriptor set layouts up to but not including the last one</li>
<li>Add our descriptor set layout as the last one in the new pipeline layout</li>
</ul>
</li>
</ul>
</li>
<li>Create the pipeline layouts by calling down the chain with the original or modified create info</li>
</ul>
<h4>
<a id="user-content-gpupostcallqueuesubmit" class="anchor" href="#user-content-gpupostcallqueuesubmit" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuPostCallQueueSubmit</h4>
<ul>
<li>Submit a command buffer containing a memory barrier to make GPU writes available to the host domain.</li>
<li>Call QueueWaitIdle.</li>
<li>For each primary and secondary command buffer in the submission:
<ul>
<li>Call a helper function to process the instrumentation debug buffers (described later)</li>
</ul>
</li>
</ul>
<h4>
<a id="user-content-gpuprecallvalidatecmdwaitevents" class="anchor" href="#user-content-gpuprecallvalidatecmdwaitevents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuPreCallValidateCmdWaitEvents</h4>
<ul>
<li>Report an error about a possible deadlock if CmdWaitEvents is recorded with VK_PIPELINE_STAGE_HOST_BIT set.</li>
</ul>
<h4>
<a id="user-content-gpuprecallrecordcreategraphicspipelines" class="anchor" href="#user-content-gpuprecallrecordcreategraphicspipelines" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuPreCallRecordCreateGraphicsPipelines</h4>
<ul>
<li>Examine the pipelines to see if any use the debug descriptor set binding index</li>
<li>For those that do:
<ul>
<li>Create non-instrumented shader modules from the saved original SPIR-V</li>
<li>Modify the CreateInfo data to use these non-instrumented shaders.
<ul>
<li>This prevents instrumented shaders from using the application's descriptor set.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>
<a id="user-content-gpupostcallrecordcreategraphicspipelines" class="anchor" href="#user-content-gpupostcallrecordcreategraphicspipelines" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuPostCallRecordCreateGraphicsPipelines</h4>
<ul>
<li>For every shader in the pipeline:
<ul>
<li>Destroy the shader module created in GpuPreCallRecordCreateGraphicsPipelines, if any
<ul>
<li>These are found in the CreateInfo used to create the pipeline and not in the shader_module</li>
</ul>
</li>
<li>Create a shader tracking record that saves:
<ul>
<li>shader module handle</li>
<li>unique shader id</li>
<li>graphics pipeline handle</li>
<li>shader bytecode if it contains debug info</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This tracker is used to attach the shader bytecode to the shader in case it is needed
later to get the shader source code debug info.</p>
<p>The current shader module tracker in the validation code stores the bytecode,
but this tracker has the same life cycle as the shader module itself.
It is possible for the application to destroy the shader module after
creating graphics pipeline and before submitting work that uses the shader,
making the shader bytecode unavailable if needed for later analysis.
Therefore, the bytecode must be saved at this opportunity.</p>
<p>This tracker exists as long as the graphics pipeline exists,
so the graphics pipeline handle is also stored in this tracker so that it can
be looked up when the graphics pipeline is destroyed.
At that point, it is safe to free the bytecode since the pipeline is never used again.</p>
<h4>
<a id="user-content-gpuprecallrecorddestroypipeline" class="anchor" href="#user-content-gpuprecallrecorddestroypipeline" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GpuPreCallRecordDestroyPipeline</h4>
<ul>
<li>Find the shader tracker(s) with the graphics pipeline handle and free the tracker, along with any bytecode it has stored in it.</li>
</ul>
<h3>
<a id="user-content-shader-instrumentation-scope" class="anchor" href="#user-content-shader-instrumentation-scope" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Shader Instrumentation Scope</h3>
<p>The shader instrumentation process performed by the SPIR-V optimizer applies descriptor index bounds checking
to descriptors of the following types:</p>
<pre><code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
</code></pre>
<p>Instrumentation is applied to the following SPIR-V operations:</p>
<pre><code>OpImageSampleImplicitLod
OpImageSampleExplicitLod
OpImageSampleDrefImplicitLod
OpImageSampleDrefExplicitLod
OpImageSampleProjImplicitLod
OpImageSampleProjExplicitLod
OpImageSampleProjDrefImplicitLod
OpImageSampleProjDrefExplicitLod
OpImageGather
OpImageDrefGather
OpImageQueryLod
OpImageSparseSampleImplicitLod
OpImageSparseSampleExplicitLod
OpImageSparseSampleDrefImplicitLod
OpImageSparseSampleDrefExplicitLod
OpImageSparseSampleProjImplicitLod
OpImageSparseSampleProjExplicitLod
OpImageSparseSampleProjDrefImplicitLod
OpImageSparseSampleProjDrefExplicitLod
OpImageSparseGather
OpImageSparseDrefGather
OpImageFetch
OpImageRead
OpImageQueryFormat
OpImageQueryOrder
OpImageQuerySizeLod
OpImageQuerySize
OpImageQueryLevels
OpImageQuerySamples
OpImageSparseFetch
OpImageSparseRead
OpImageWrite
</code></pre>
<h3>
<a id="user-content-shader-instrumentation-error-record-format" class="anchor" href="#user-content-shader-instrumentation-error-record-format" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Shader Instrumentation Error Record Format</h3>
<p>The instrumented shader code generates "error records" in a specific format.</p>
<p>This description includes the support for future GPU-Assisted Validation features
such as checking for uninitialized descriptors in the partially-bound scenario.
These items are not used in the current implementation for descriptor array
bounds checking, but are provided here to complete the description of the
error record format.</p>
<p>The format of this buffer is as follows:</p>
<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> DebugOutputBuffer_t
{
   <span class="pl-c1">uint</span> DataWrittenLength;
   <span class="pl-c1">uint</span> Data[];
}</pre></div>
<p><code>DataWrittenLength</code> is the number of uint32_t words that have been attempted to be written.
It should be initialized to 0.</p>
<p>The <code>Data</code> array is the uint32_t words written by the shaders of the pipeline to record bindless validation errors.
All elements of <code>Data</code> should be initialized to 0.
Note that the <code>Data</code> array has runtime length.
The shader queries the length of the <code>Data</code> array to make sure that it does not write past the end of <code>Data</code>.
The shader only writes complete records.
The layer uses the length of <code>Data</code> to control the number of records written by the shaders.</p>
<p>The <code>DataWrittenLength</code> is atomically updated by the shaders so that shaders do not overwrite each others data.
The shader takes the value it gets from the atomic update.
If the value plus the record length is greater than the length of <code>Data</code>, it does not write the record.</p>
<p>Given this protocol, the value in <code>DataWrittenLength</code> is not very meaningful if it is greater than the length of <code>Data</code>.
However, the format of the written records plus the fact that <code>Data</code> is initialized to 0 should be enough to determine
the records that were written.</p>
<h3>
<a id="user-content-record-format" class="anchor" href="#user-content-record-format" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Record Format</h3>
<p>The format of an output record is the following:</p>
<pre><code>Word 0: Record size
Word 1: Shader ID
Word 2: Instruction Index
Word 3: Stage
&lt;Stage-Specific Words&gt;
&lt;Validation-Specific Words&gt;
</code></pre>
<p>The Record Size is the number of words in this record, including the the Record Size.</p>
<p>The Shader ID is a handle that was provided by the layer when the shader was instrumented.</p>
<p>The Instruction Index is the instruction within the original function at which the error occurred.
For bindless, this will be the instruction which consumes the descriptor in question,
or the instruction that consumes the OpSampledImage that consumes the descriptor.</p>
<p>The Stage is the integer value used in SPIR-V for each of the Graphics Execution Models:</p>
<table>
<thead>
<tr>
<th>Stage</th>
<th align="center">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vertex</td>
<td align="center">0</td>
</tr>
<tr>
<td>TessCtrl</td>
<td align="center">1</td>
</tr>
<tr>
<td>TessEval</td>
<td align="center">2</td>
</tr>
<tr>
<td>Geometry</td>
<td align="center">3</td>
</tr>
<tr>
<td>Fragment</td>
<td align="center">4</td>
</tr>
<tr>
<td>Compute</td>
<td align="center">5</td>
</tr>
</tbody>
</table>
<h3>
<a id="user-content-stage-specific-words" class="anchor" href="#user-content-stage-specific-words" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Stage Specific Words</h3>
<p>These are words that identify which "instance" of the shader the validation error occurred in.
Here are words for each stage:</p>
<table>
<thead>
<tr>
<th>Stage</th>
<th>Word 0</th>
<th>Word 1</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vertex</td>
<td>VertexID</td>
<td>InstanceID</td>
</tr>
<tr>
<td>Tess*</td>
<td>InvocationID</td>
<td>unused</td>
</tr>
<tr>
<td>Geometry</td>
<td>PrimitiveID</td>
<td>InvocationID</td>
</tr>
<tr>
<td>Fragment</td>
<td>FragCoord.x</td>
<td>FragCoord.y</td>
</tr>
<tr>
<td>Compute</td>
<td>GlobalInvocationID</td>
<td>unused</td>
</tr>
</tbody>
</table>
<p>"unused" means not relevant, but still present.</p>
<h3>
<a id="user-content-validation-specific-words" class="anchor" href="#user-content-validation-specific-words" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Validation-Specific Words</h3>
<p>These are words that are specific to the validation being done.
For bindless validation, they are variable.</p>
<p>The first word is the Error Code.</p>
<p>For the *OutOfBounds errors, two words will follow: Word0:DescriptorIndex, Word1:DescriptorArrayLength</p>
<p>For the *Uninitialized errors, one word will follow: Word0:DescriptorIndex</p>
<table>
<thead>
<tr>
<th>Error</th>
<th align="center">Code</th>
<th>Word 0</th>
<th>Word 1</th>
</tr>
</thead>
<tbody>
<tr>
<td>IndexOutOfBounds</td>
<td align="center">0</td>
<td>Descriptor Index</td>
<td>Descriptor Array Length</td>
</tr>
<tr>
<td>DescriptorUninitialized</td>
<td align="center">1</td>
<td>Descriptor Index</td>
<td>unused</td>
</tr>
</tbody>
</table>
<p>So the words written for an image descriptor bounds error in a fragment shader is:</p>
<pre><code>Word 0: Record size (9)
Word 1: Shader ID
Word 2: Instruction Index
Word 3: Stage (4:Fragment)
Word 4: FragCoord.x
Word 5: FragCoord.y
Word 6: Error (0: ImageIndexOutOfBounds)
Word 7: DescriptorIndex
Word 8: DescriptorArrayLength
</code></pre>
<p>If another error is encountered, that record is written starting at Word 10, if the whole record will not overflow Data.
If overflow will happen, no words are written..</p>
<p>The validation layer can continue to read valid records until it sees a Record Length of 0 or the end of Data is reached.</p>
<h4>
<a id="user-content-programmatic-interface" class="anchor" href="#user-content-programmatic-interface" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Programmatic interface</h4>
<p>The programmatic interface for the above informal description is codified in the
<a href="https://github.com/KhronosGroup/SPIRV-Tools" TARGET="_blank">SPIRV-Tools</a> repository in file
<a href="https://github.com/KhronosGroup/SPIRV-Tools/blob/master/include/spirv-tools/instrument.hpp" TARGET="_blank"><code>instrument.hpp</code></a>.
It consists largely of integer constant definitions for the codes and values mentioned above and
offsets into the record for locating each item.</p>
<h2>
<a id="user-content-gpu-assisted-validation-error-report" class="anchor" href="#user-content-gpu-assisted-validation-error-report" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GPU-Assisted Validation Error Report</h2>
<p>This is a fairly simple process of mapping the debug report buffer associated with
each draw in the command buffer that was just submitted and looking to see if the GPU instrumentation
code wrote anything.
Each draw in the command buffer should have a corresponding result buffer in the command buffer's list of result buffers.
The report generating code loops through the result buffers, maps each of them, checks for errors, and unmaps them.
The layer clears the buffer to zeros when it is allocated and after processing any
buffer that was written to.
The instrumented shader code expects these buffers to be cleared to zeros before it
writes to them.</p>
<p>The layer then prepares a "common" validation error message containing:</p>
<ul>
<li>command buffer handle - This is easily obtained because we are looping over the command
buffers just submitted.</li>
<li>draw number - keep track of how many draws we've processed for a given command buffer.</li>
<li>pipeline handle - The shader tracker discussed earlier contains this handle</li>
<li>shader module handle - The "Shader ID" (Word 1 in the record) is used to lookup
the shader tracker which is then used to obtain the shader module and pipeline handles</li>
<li>instruction index - This is the SPIR-V instruction index where the invalid array access occurred.
It is not that useful by itself, since the user would have to use it to locate a SPIR-V instruction
in a SPIR-V disassembly and somehow relate it back to the shader source code.
But it could still be useful to some and it is easy to report.
The user can build the shader with debug information to get source-level information.</li>
</ul>
<p>For all objects, the layer also looks up the objects in the Debug Utils object name map in
case the application used that extension to name any objects.
If a name exists for that object, it is included in the error message.</p>
<p>The layer then adds on error message text obtained from decoding the stage-specific and
validation-specific data as described earlier.</p>
<p>This completes the error report when there is no source-level debug information in the shader.</p>
<h3>
<a id="user-content-source-level-debug-information" class="anchor" href="#user-content-source-level-debug-information" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Source-Level Debug Information</h3>
<p>This is one of the more complicated and code-heavy parts of the GPU-Assisted Validation feature
and all it really does is display source-level information when the shader is compiled
with debugging info (<code>-g</code> option in the case of <code>glslangValidator</code>).</p>
<p>The process breaks down into two steps:</p>
<h4>
<a id="user-content-opline-processing" class="anchor" href="#user-content-opline-processing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>OpLine Processing</h4>
<p>The SPIR-V generator (e.g., glslangValidator) places an OpLine SPIR-V instruction in the
shader program ahead of code generated for each source code statement.
The OpLine instruction contains the filename id (for an OpString),
the source code line number and the source code column number.
It is possible to have two source code statements on the same line in the source file,
which explains the need for the column number.</p>
<p>The layer scans the SPIR-V looking for the last OpLine instruction that appears before the instruction
at the instruction index obtained from the debug report.
This OpLine then contains the correct filename id, line number, and column number of the
statement causing the error.
The filename itself is obtained by scanning the SPIR-V again for an OpString instruction that
matches the id from the OpLine.
This OpString contains the text string representing the filename.
This information is added to the validation error message.</p>
<p>For online compilation when there is no "file", only the line number information is reported.</p>
<h4>
<a id="user-content-opsource-processing" class="anchor" href="#user-content-opsource-processing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>OpSource Processing</h4>
<p>The SPIR-V built with source-level debug info also contains OpSource instructions that
have a string containing the source code, delimited by newlines.
Due to possible pre-processing, the layer just cannot simply use the source file line number
from the OpLine to index into this set of source code lines.</p>
<p>Instead, the correct source code line is found by first locating the "#line" directive in the
source that specifies a line number closest to and less than the source line number reported
by the OpLine located in the previous step.
The correct "#line" directive must also match its filename, if specified,
with the filename from the OpLine.</p>
<p>Then the difference between the "#line" line number and the OpLine line number is added
to the place where the "#line" was found to locate the actual line of source, which is
then added to the validation error message.</p>
<p>For example, if the OpLine line number is 15, and there is a "#line 10" on line 40
in the OpSource source, then line 45 in the OpSource contains the correct source line.</p>
<h2>
<a id="user-content-gpu-assisted-validation-testing" class="anchor" href="#user-content-gpu-assisted-validation-testing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GPU-Assisted Validation Testing</h2>
<p>Validation Layer Tests (VLTs) exist for GPU-Assisted Validation.
They cannot be run with the "mock ICD" in headless CI environments because they need to
actually execute shaders.
But they are still useful to run on real devices to check for regressions.</p>
<p>There isn't anything else that remarkable or different about these tests.
They activate GPU-Assisted Validation via the programmatic
interface as described earlier.</p>
<p>The tests exercise the extraction of source code information when the shader
is built with debug info.</p>
</article>
</body>
</html>
